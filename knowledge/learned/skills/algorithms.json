{
  "category": "algorithms",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "skills": [
    {"id": "alg01", "type": "basics", "name": "Algorithm Basics", "description": "Problem solving", "pattern": "Input → Process → Output", "example": "Step-by-step"},
    {"id": "alg02", "type": "bigO", "name": "Big O Notation", "description": "Complexity analysis", "pattern": "Worst case, growth rate", "example": "O(n), O(n²)"},
    {"id": "alg03", "type": "linear", "name": "Linear Search", "description": "Sequential search", "pattern": "O(n), check each element", "example": "Unsorted data"},
    {"id": "alg04", "type": "binary", "name": "Binary Search", "description": "Divide and conquer", "pattern": "O(log n), sorted array", "example": "Fast lookup"},
    {"id": "alg05", "type": "bubble", "name": "Bubble Sort", "description": "Simple sort", "pattern": "O(n²), swap adjacent", "example": "Educational"},
    {"id": "alg06", "type": "selection", "name": "Selection Sort", "description": "Find minimum", "pattern": "O(n²), select smallest", "example": "Simple"},
    {"id": "alg07", "type": "insertion", "name": "Insertion Sort", "description": "Build sorted array", "pattern": "O(n²), good for small/nearly sorted", "example": "Cards"},
    {"id": "alg08", "type": "merge", "name": "Merge Sort", "description": "Divide and conquer", "pattern": "O(n log n), stable, divide-merge", "example": "Reliable"},
    {"id": "alg09", "type": "quick", "name": "Quick Sort", "description": "Partition-based", "pattern": "O(n log n) avg, pivot selection", "example": "Fast in practice"},
    {"id": "alg10", "type": "heap", "name": "Heap Sort", "description": "Heap-based", "pattern": "O(n log n), in-place", "example": "Memory efficient"},
    {"id": "alg11", "type": "counting", "name": "Counting Sort", "description": "Non-comparison", "pattern": "O(n + k), integer keys", "example": "Limited range"},
    {"id": "alg12", "type": "radix", "name": "Radix Sort", "description": "Digit-by-digit", "pattern": "O(nk), stable", "example": "Integers/strings"},
    {"id": "alg13", "type": "bfs", "name": "Breadth-First Search", "description": "Level-order traversal", "pattern": "O(V+E), queue, shortest path", "example": "Graph traversal"},
    {"id": "alg14", "type": "dfs", "name": "Depth-First Search", "description": "Go deep first", "pattern": "O(V+E), stack/recursion", "example": "Path finding"},
    {"id": "alg15", "type": "dijkstra", "name": "Dijkstra's Algorithm", "description": "Shortest path", "pattern": "O((V+E) log V), non-negative weights", "example": "GPS routing"},
    {"id": "alg16", "type": "bellman", "name": "Bellman-Ford", "description": "Shortest path", "pattern": "O(VE), handles negative weights", "example": "Negative edges"},
    {"id": "alg17", "type": "floyd", "name": "Floyd-Warshall", "description": "All pairs shortest", "pattern": "O(V³), dynamic programming", "example": "All paths"},
    {"id": "alg18", "type": "kruskal", "name": "Kruskal's Algorithm", "description": "Minimum spanning tree", "pattern": "O(E log E), union-find", "example": "Network design"},
    {"id": "alg19", "type": "prim", "name": "Prim's Algorithm", "description": "Minimum spanning tree", "pattern": "O((V+E) log V), grow tree", "example": "MST alternative"},
    {"id": "alg20", "type": "topological", "name": "Topological Sort", "description": "DAG ordering", "pattern": "O(V+E), dependencies first", "example": "Build order"},
    {"id": "alg21", "type": "dp", "name": "Dynamic Programming", "description": "Optimal substructure", "pattern": "Memoization, tabulation", "example": "Fibonacci"},
    {"id": "alg22", "type": "greedy", "name": "Greedy Algorithms", "description": "Local optimum", "pattern": "Best immediate choice", "example": "Coin change"},
    {"id": "alg23", "type": "backtrack", "name": "Backtracking", "description": "Try all possibilities", "pattern": "Explore, backtrack on failure", "example": "N-Queens"},
    {"id": "alg24", "type": "divideConquer", "name": "Divide and Conquer", "description": "Split problem", "pattern": "Divide, conquer, combine", "example": "Merge sort"},
    {"id": "alg25", "type": "twoPointer", "name": "Two Pointer", "description": "Array technique", "pattern": "Left/right pointers", "example": "Pair sum"},
    {"id": "alg26", "type": "sliding", "name": "Sliding Window", "description": "Window technique", "pattern": "Fixed/variable window", "example": "Max subarray"},
    {"id": "alg27", "type": "recursion", "name": "Recursion", "description": "Self-reference", "pattern": "Base case + recursive case", "example": "Tree traversal"},
    {"id": "alg28", "type": "knapsack", "name": "Knapsack Problem", "description": "Optimization", "pattern": "DP: 0/1 knapsack", "example": "Resource allocation"},
    {"id": "alg29", "type": "kadane", "name": "Kadane's Algorithm", "description": "Max subarray sum", "pattern": "O(n), track current/global max", "example": "Contiguous sum"},
    {"id": "alg30", "type": "astar", "name": "A* Algorithm", "description": "Pathfinding", "pattern": "g(n) + h(n), heuristic", "example": "Game AI"}
  ]
}
