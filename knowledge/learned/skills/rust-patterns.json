{
  "category": "rust-patterns",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Rust Programming Patterns",
  "skills": [
    {"id": "rsp01", "type": "ownership", "name": "Ownership", "description": "Memory ownership", "pattern": "One owner at a time", "example": "Move semantics"},
    {"id": "rsp02", "type": "ownership", "name": "Borrowing", "description": "References", "pattern": "&T, &mut T", "example": "Non-owning access"},
    {"id": "rsp03", "type": "ownership", "name": "Lifetimes", "description": "Reference validity", "pattern": "'a annotations", "example": "Prevent dangling refs"},
    {"id": "rsp04", "type": "ownership", "name": "Clone vs Copy", "description": "Duplication semantics", "pattern": "Copy: bitwise, Clone: explicit", "example": "Value copying"},
    {"id": "rsp05", "type": "types", "name": "Option<T>", "description": "Nullable type", "pattern": "Some(T) | None", "example": "Safe null handling"},
    {"id": "rsp06", "type": "types", "name": "Result<T, E>", "description": "Error handling", "pattern": "Ok(T) | Err(E)", "example": "Recoverable errors"},
    {"id": "rsp07", "type": "types", "name": "Enums", "description": "Sum types", "pattern": "Variants with data", "example": "State machines"},
    {"id": "rsp08", "type": "types", "name": "Structs", "description": "Product types", "pattern": "Named fields", "example": "Data containers"},
    {"id": "rsp09", "type": "traits", "name": "Traits", "description": "Shared behavior", "pattern": "Interface abstraction", "example": "Polymorphism"},
    {"id": "rsp10", "type": "traits", "name": "Trait Bounds", "description": "Generic constraints", "pattern": "T: Trait", "example": "Type requirements"},
    {"id": "rsp11", "type": "traits", "name": "Derive Macros", "description": "Auto-implement traits", "pattern": "#[derive(...)]", "example": "Debug, Clone, Eq"},
    {"id": "rsp12", "type": "traits", "name": "dyn Trait", "description": "Dynamic dispatch", "pattern": "Trait objects", "example": "Runtime polymorphism"},
    {"id": "rsp13", "type": "patterns", "name": "Pattern Matching", "description": "Destructuring", "pattern": "match expression", "example": "Control flow"},
    {"id": "rsp14", "type": "patterns", "name": "if let", "description": "Single pattern", "pattern": "if let Some(x) = opt", "example": "Conditional binding"},
    {"id": "rsp15", "type": "patterns", "name": "while let", "description": "Loop pattern", "pattern": "while let Some(x) = iter.next()", "example": "Iterator consumption"},
    {"id": "rsp16", "type": "error", "name": "? Operator", "description": "Error propagation", "pattern": "result?", "example": "Early return"},
    {"id": "rsp17", "type": "error", "name": "thiserror", "description": "Custom errors", "pattern": "#[error(...)]", "example": "Error types"},
    {"id": "rsp18", "type": "error", "name": "anyhow", "description": "Error context", "pattern": ".context()", "example": "Error chains"},
    {"id": "rsp19", "type": "iterators", "name": "Iterator Trait", "description": "Lazy sequences", "pattern": ".iter().map().filter()", "example": "Functional style"},
    {"id": "rsp20", "type": "iterators", "name": "Iterator Adapters", "description": "Transform iterators", "pattern": "map, filter, take", "example": "Chain operations"},
    {"id": "rsp21", "type": "iterators", "name": "Collect", "description": "Consume iterator", "pattern": ".collect::<Vec<_>>()", "example": "Gather results"},
    {"id": "rsp22", "type": "async", "name": "async/await", "description": "Async functions", "pattern": "async fn, .await", "example": "Non-blocking"},
    {"id": "rsp23", "type": "async", "name": "Tokio", "description": "Async runtime", "pattern": "#[tokio::main]", "example": "Async execution"},
    {"id": "rsp24", "type": "async", "name": "Futures", "description": "Async values", "pattern": "Future trait", "example": "Lazy async"},
    {"id": "rsp25", "type": "concurrency", "name": "Arc<T>", "description": "Shared ownership", "pattern": "Atomic reference count", "example": "Thread-safe sharing"},
    {"id": "rsp26", "type": "concurrency", "name": "Mutex<T>", "description": "Mutual exclusion", "pattern": ".lock().unwrap()", "example": "Thread-safe mutation"},
    {"id": "rsp27", "type": "concurrency", "name": "Channels", "description": "Message passing", "pattern": "mpsc::channel()", "example": "Thread communication"},
    {"id": "rsp28", "type": "unsafe", "name": "Unsafe Rust", "description": "Escape hatch", "pattern": "unsafe { ... }", "example": "Raw pointers, FFI"},
    {"id": "rsp29", "type": "macros", "name": "Declarative Macros", "description": "macro_rules!", "pattern": "Pattern-based", "example": "Code generation"},
    {"id": "rsp30", "type": "macros", "name": "Procedural Macros", "description": "Code transforms", "pattern": "#[derive], #[...]", "example": "Custom derives"}
  ]
}
