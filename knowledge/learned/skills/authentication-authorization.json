{
  "category": "authentication-authorization",
  "version": "1.0.0",
  "generatedBy": "Claude Opus 4.5 - Module de référence pour Ana SUPERIA",
  "skills": [
    {"id": "auth01", "type": "jwt", "name": "JWT Creation", "description": "Create JSON Web Tokens", "pattern": "const token = jwt.sign(\n  { userId: user.id, role: user.role },\n  process.env.JWT_SECRET,\n  { algorithm: 'RS256', expiresIn: '15m' }\n);", "example": "Short-lived access tokens with RS256"},
    {"id": "auth02", "type": "jwt", "name": "JWT Verification", "description": "Verify and decode JWT", "pattern": "try {\n  const decoded = jwt.verify(token, publicKey, { algorithms: ['RS256'] });\n  req.user = decoded;\n} catch (err) {\n  if (err.name === 'TokenExpiredError') return res.status(401).json({ error: 'Token expired' });\n  throw err;\n}", "example": "Handle expiration and invalid tokens"},
    {"id": "auth03", "type": "refresh", "name": "Refresh Token Flow", "description": "Implement refresh token rotation", "pattern": "// Store refresh token in DB\nconst refreshToken = crypto.randomBytes(64).toString('hex');\nawait db.refreshTokens.create({ token: hash(refreshToken), userId, expiresAt });\n\n// On refresh: invalidate old, issue new\nawait db.refreshTokens.delete(oldToken);\nconst newRefresh = generateRefreshToken();", "example": "Rotate refresh tokens on each use"},
    {"id": "auth04", "type": "oauth", "name": "OAuth2 Authorization Code", "description": "Implement OAuth2 authorization code flow", "pattern": "// Step 1: Redirect to provider\nres.redirect(`https://oauth.provider.com/authorize?\n  client_id=${CLIENT_ID}&\n  redirect_uri=${CALLBACK_URL}&\n  scope=email profile&\n  state=${csrfToken}`);\n\n// Step 2: Exchange code for tokens\nconst { access_token } = await fetch('/token', { code, client_secret });", "example": "Server-side OAuth for web apps"},
    {"id": "auth05", "type": "oauth", "name": "PKCE Flow", "description": "OAuth2 with PKCE for SPAs/mobile", "pattern": "// Generate code verifier and challenge\nconst verifier = crypto.randomBytes(32).toString('base64url');\nconst challenge = crypto.createHash('sha256').update(verifier).digest('base64url');\n\n// Include in auth request\n&code_challenge=${challenge}&code_challenge_method=S256", "example": "Secure OAuth without client secret"},
    {"id": "auth06", "type": "session", "name": "Session Management", "description": "Secure session handling", "pattern": "app.use(session({\n  secret: process.env.SESSION_SECRET,\n  resave: false,\n  saveUninitialized: false,\n  cookie: {\n    secure: true,\n    httpOnly: true,\n    sameSite: 'strict',\n    maxAge: 3600000\n  },\n  store: new RedisStore({ client: redisClient })\n}));", "example": "Redis-backed secure sessions"},
    {"id": "auth07", "type": "password", "name": "Password Hashing", "description": "Secure password storage with Argon2", "pattern": "const argon2 = require('argon2');\n\n// Hash password\nconst hash = await argon2.hash(password, {\n  type: argon2.argon2id,\n  memoryCost: 65536,\n  timeCost: 3,\n  parallelism: 4\n});\n\n// Verify\nconst valid = await argon2.verify(hash, password);", "example": "Argon2id with high memory cost"},
    {"id": "auth08", "type": "mfa", "name": "TOTP 2FA", "description": "Time-based one-time password", "pattern": "const speakeasy = require('speakeasy');\n\n// Generate secret\nconst secret = speakeasy.generateSecret({ name: 'MyApp' });\n\n// Verify token\nconst valid = speakeasy.totp.verify({\n  secret: user.totpSecret,\n  encoding: 'base32',\n  token: userInput,\n  window: 1\n});", "example": "Google Authenticator compatible"},
    {"id": "auth09", "type": "mfa", "name": "WebAuthn/Passkeys", "description": "Passwordless authentication", "pattern": "// Registration\nconst options = generateRegistrationOptions({\n  rpName: 'My App',\n  userID: user.id,\n  userName: user.email,\n  attestationType: 'none'\n});\n\n// Verification\nconst verification = await verifyRegistrationResponse({\n  response: credential,\n  expectedChallenge,\n  expectedOrigin\n});", "example": "FIDO2 passwordless login"},
    {"id": "auth10", "type": "rbac", "name": "Role-Based Access Control", "description": "RBAC implementation", "pattern": "const permissions = {\n  admin: ['read', 'write', 'delete', 'manage_users'],\n  editor: ['read', 'write'],\n  viewer: ['read']\n};\n\nfunction hasPermission(user, action) {\n  return permissions[user.role]?.includes(action) ?? false;\n}", "example": "Simple role-permission mapping"},
    {"id": "auth11", "type": "abac", "name": "Attribute-Based Access", "description": "ABAC with policy engine", "pattern": "const policy = {\n  effect: 'allow',\n  condition: {\n    'resource.owner': '${user.id}',\n    'user.department': 'engineering',\n    'time.hour': { gte: 9, lte: 17 }\n  }\n};\n\nfunction evaluate(user, resource, action, context) {\n  return policies.some(p => matchesPolicy(p, user, resource, action, context));\n}", "example": "Fine-grained attribute-based control"},
    {"id": "auth12", "type": "middleware", "name": "Auth Middleware", "description": "Express authentication middleware", "pattern": "const authenticate = async (req, res, next) => {\n  const token = req.headers.authorization?.replace('Bearer ', '');\n  if (!token) return res.status(401).json({ error: 'No token' });\n  \n  try {\n    req.user = jwt.verify(token, SECRET);\n    next();\n  } catch { res.status(401).json({ error: 'Invalid token' }); }\n};\n\nconst authorize = (...roles) => (req, res, next) => {\n  if (!roles.includes(req.user.role)) return res.status(403).json({ error: 'Forbidden' });\n  next();\n};", "example": "Composable auth middleware"},
    {"id": "auth13", "type": "api", "name": "API Key Authentication", "description": "Secure API key management", "pattern": "// Generate API key\nconst apiKey = `${prefix}_${crypto.randomBytes(32).toString('hex')}`;\nconst hashedKey = crypto.createHash('sha256').update(apiKey).digest('hex');\nawait db.apiKeys.create({ hash: hashedKey, userId, scopes });\n\n// Verify\nconst hash = sha256(providedKey);\nconst key = await db.apiKeys.findByHash(hash);", "example": "Hashed storage, scoped keys"},
    {"id": "auth14", "type": "sso", "name": "SAML SSO", "description": "SAML 2.0 single sign-on", "pattern": "const saml = require('samlify');\n\nconst sp = saml.ServiceProvider({\n  metadata: spMetadata,\n  privateKey: spPrivateKey\n});\n\nconst idp = saml.IdentityProvider({\n  metadata: idpMetadata\n});\n\n// Handle login response\nconst { extract } = await sp.parseLoginResponse(idp, 'post', req);", "example": "Enterprise SSO integration"},
    {"id": "auth15", "type": "sso", "name": "OIDC Integration", "description": "OpenID Connect client", "pattern": "const { Issuer, generators } = require('openid-client');\n\nconst issuer = await Issuer.discover('https://accounts.google.com');\nconst client = new issuer.Client({\n  client_id: CLIENT_ID,\n  client_secret: CLIENT_SECRET,\n  redirect_uris: [CALLBACK_URL]\n});\n\nconst tokenSet = await client.callback(CALLBACK_URL, params, { code_verifier });", "example": "Google/Azure AD login"},
    {"id": "auth16", "type": "security", "name": "Brute Force Protection", "description": "Rate limit login attempts", "pattern": "const loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  keyGenerator: (req) => req.body.email,\n  handler: (req, res) => {\n    res.status(429).json({ error: 'Too many attempts', retryAfter: '15 minutes' });\n  }\n});\n\napp.post('/login', loginLimiter, loginHandler);", "example": "Per-user rate limiting"},
    {"id": "auth17", "type": "security", "name": "Account Lockout", "description": "Lock accounts after failed attempts", "pattern": "async function handleFailedLogin(userId) {\n  const attempts = await redis.incr(`failed:${userId}`);\n  await redis.expire(`failed:${userId}`, 900);\n  \n  if (attempts >= 5) {\n    await db.users.update(userId, { lockedUntil: Date.now() + 900000 });\n    await sendLockoutEmail(userId);\n  }\n}", "example": "Progressive lockout with notification"},
    {"id": "auth18", "type": "security", "name": "Secure Password Reset", "description": "Password reset flow", "pattern": "// Generate token\nconst token = crypto.randomBytes(32).toString('hex');\nconst hash = crypto.createHash('sha256').update(token).digest('hex');\nawait db.passwordResets.create({ hash, userId, expiresAt: Date.now() + 3600000 });\n\n// Send email with token (not hash)\nawait sendEmail(user.email, `Reset: ${FRONTEND_URL}/reset?token=${token}`);\n\n// Verify and reset\nconst hash = sha256(providedToken);\nconst reset = await db.passwordResets.findByHash(hash);", "example": "Time-limited, single-use tokens"},
    {"id": "auth19", "type": "security", "name": "Secure Headers", "description": "Security headers for auth", "pattern": "app.use(helmet());\napp.use(helmet.contentSecurityPolicy({\n  directives: {\n    defaultSrc: [\"'self'\"],\n    scriptSrc: [\"'self'\"],\n    frameSrc: [\"'none'\"]\n  }\n}));\napp.use(helmet.hsts({ maxAge: 31536000, includeSubDomains: true }));", "example": "CSP, HSTS, X-Frame-Options"},
    {"id": "auth20", "type": "token", "name": "Token Blacklisting", "description": "Revoke JWT tokens", "pattern": "// On logout/revoke\nawait redis.setex(`blacklist:${token}`, TOKEN_TTL, '1');\n\n// In middleware\nconst isBlacklisted = await redis.get(`blacklist:${token}`);\nif (isBlacklisted) return res.status(401).json({ error: 'Token revoked' });", "example": "Redis-based token revocation"},
    {"id": "auth21", "type": "audit", "name": "Auth Audit Logging", "description": "Log authentication events", "pattern": "const logAuthEvent = async (event) => {\n  await db.authLogs.create({\n    type: event.type,\n    userId: event.userId,\n    ip: event.ip,\n    userAgent: event.userAgent,\n    success: event.success,\n    reason: event.reason,\n    timestamp: new Date()\n  });\n};", "example": "Track logins, failures, password changes"},
    {"id": "auth22", "type": "device", "name": "Device Management", "description": "Track and manage devices", "pattern": "const device = {\n  id: crypto.randomUUID(),\n  userId: user.id,\n  name: parseUserAgent(req.headers['user-agent']),\n  lastIp: req.ip,\n  lastSeen: new Date(),\n  trusted: false\n};\n\n// New device notification\nif (!existingDevices.some(d => d.fingerprint === fingerprint)) {\n  await sendNewDeviceAlert(user, device);\n}", "example": "Device fingerprinting and alerts"},
    {"id": "auth23", "type": "magic", "name": "Magic Link Auth", "description": "Passwordless email login", "pattern": "// Generate magic link\nconst token = crypto.randomBytes(32).toString('base64url');\nawait redis.setex(`magic:${token}`, 600, JSON.stringify({ email, createdAt: Date.now() }));\n\nawait sendEmail(email, `Login: ${URL}/auth/magic?token=${token}`);\n\n// Verify (single use)\nconst data = await redis.get(`magic:${token}`);\nif (!data) throw new Error('Invalid or expired link');\nawait redis.del(`magic:${token}`);", "example": "10-minute expiry, single use"},
    {"id": "auth24", "type": "social", "name": "Social Login", "description": "OAuth social providers", "pattern": "passport.use(new GoogleStrategy({\n  clientID: GOOGLE_CLIENT_ID,\n  clientSecret: GOOGLE_CLIENT_SECRET,\n  callbackURL: '/auth/google/callback'\n}, async (accessToken, refreshToken, profile, done) => {\n  let user = await db.users.findByGoogleId(profile.id);\n  if (!user) user = await db.users.create({ googleId: profile.id, email: profile.emails[0].value });\n  done(null, user);\n}));", "example": "Google, GitHub, Facebook login"},
    {"id": "auth25", "type": "impersonation", "name": "Admin Impersonation", "description": "Safely impersonate users", "pattern": "app.post('/admin/impersonate/:userId', requireAdmin, async (req, res) => {\n  const originalUser = req.user;\n  const targetUser = await db.users.findById(req.params.userId);\n  \n  const impersonationToken = jwt.sign({\n    userId: targetUser.id,\n    impersonatorId: originalUser.id,\n    impersonating: true\n  }, SECRET, { expiresIn: '1h' });\n  \n  await logAuditEvent('impersonation_start', { admin: originalUser.id, target: targetUser.id });\n  res.json({ token: impersonationToken });\n});", "example": "Audit-logged admin access"},
    {"id": "auth26", "type": "scope", "name": "OAuth Scopes", "description": "Granular API permissions", "pattern": "const scopes = {\n  'read:profile': 'Read your profile information',\n  'write:profile': 'Update your profile',\n  'read:data': 'Access your data',\n  'delete:data': 'Delete your data'\n};\n\nconst requireScope = (scope) => (req, res, next) => {\n  if (!req.token.scopes?.includes(scope)) {\n    return res.status(403).json({ error: `Requires scope: ${scope}` });\n  }\n  next();\n};", "example": "Fine-grained API permissions"},
    {"id": "auth27", "type": "consent", "name": "OAuth Consent Screen", "description": "User consent management", "pattern": "// Check existing consent\nconst consent = await db.consents.find({ userId, clientId, scopes });\nif (!consent) {\n  return res.render('consent', { client, requestedScopes });\n}\n\n// Store consent\nawait db.consents.upsert({\n  userId, clientId,\n  scopes: approvedScopes,\n  grantedAt: new Date()\n});", "example": "Remember user consent decisions"},
    {"id": "auth28", "type": "claims", "name": "JWT Claims", "description": "Standard and custom claims", "pattern": "const payload = {\n  // Standard claims\n  sub: user.id,\n  iss: 'https://myapp.com',\n  aud: ['api.myapp.com'],\n  iat: Math.floor(Date.now() / 1000),\n  exp: Math.floor(Date.now() / 1000) + 900,\n  \n  // Custom claims\n  role: user.role,\n  permissions: user.permissions,\n  tenant: user.tenantId\n};", "example": "Standard JWT claims with extensions"},
    {"id": "auth29", "type": "rotation", "name": "Key Rotation", "description": "Rotate signing keys", "pattern": "const keys = await jwks.getSigningKeys();\nconst currentKey = keys[0];\nconst previousKey = keys[1];\n\n// Sign with current key\nconst token = jwt.sign(payload, currentKey.privateKey, { keyid: currentKey.kid });\n\n// Verify accepts both keys during rotation\nconst decoded = jwt.verify(token, (header, callback) => {\n  const key = keys.find(k => k.kid === header.kid);\n  callback(null, key.publicKey);\n});", "example": "Graceful key rotation with JWKS"},
    {"id": "auth30", "type": "zero-trust", "name": "Zero Trust Auth", "description": "Continuous verification", "pattern": "const verifyRequest = async (req) => {\n  // Verify token\n  const user = verifyToken(req.token);\n  \n  // Check device trust\n  const device = await verifyDevice(req.deviceFingerprint);\n  if (!device.trusted) await requireMFA(user);\n  \n  // Check context\n  if (isNewLocation(req.ip, user)) await sendSecurityAlert(user);\n  if (isSuspiciousTime(user)) await requireReauth(user);\n  \n  // Check session freshness\n  if (Date.now() - user.lastAuth > 300000) await requireReauth(user);\n};", "example": "Continuous authentication checks"}
  ]
}
