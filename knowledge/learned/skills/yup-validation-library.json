{
  "category": "yup-validation-library",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Yup validation library patterns",
  "skills": [
    {"id": "yup01", "type": "setup", "name": "Install Yup", "description": "NPM install", "pattern": "npm install yup", "example": "Install"},
    {"id": "yup02", "type": "basic", "name": "Basic Types", "description": "Primitives", "pattern": "import * as yup from 'yup';\n\nyup.string()\nyup.number()\nyup.boolean()\nyup.date()\nyup.array()\nyup.object()", "example": "Basic"},
    {"id": "yup03", "type": "object", "name": "Object Schema", "description": "Object validation", "pattern": "const userSchema = yup.object({\n  name: yup.string().required(),\n  email: yup.string().email().required(),\n  age: yup.number().positive().integer()\n});", "example": "Object"},
    {"id": "yup04", "type": "validate", "name": "Validate Data", "description": "Run validation", "pattern": "// Async (default)\ntry {\n  const user = await userSchema.validate(data);\n} catch (err) {\n  console.log(err.errors);\n}\n\n// Sync\nconst user = userSchema.validateSync(data);\n\n// Check without throwing\nconst isValid = await userSchema.isValid(data);", "example": "Validate"},
    {"id": "yup05", "type": "string", "name": "String Validations", "description": "String methods", "pattern": "yup.string()\n  .required()\n  .min(5)\n  .max(100)\n  .email()\n  .url()\n  .uuid()\n  .matches(/^[a-z]+$/)\n  .trim()\n  .lowercase()\n  .uppercase()", "example": "String"},
    {"id": "yup06", "type": "number", "name": "Number Validations", "description": "Number methods", "pattern": "yup.number()\n  .required()\n  .min(0)\n  .max(100)\n  .positive()\n  .negative()\n  .integer()\n  .moreThan(5)\n  .lessThan(10)\n  .truncate()\n  .round()", "example": "Number"},
    {"id": "yup07", "type": "array", "name": "Array Schema", "description": "Array validation", "pattern": "yup.array()\n  .of(yup.string())\n  .required()\n  .min(1)\n  .max(10)\n  .length(5)\n  .ensure()  // Default to []\n  .compact()  // Remove falsy", "example": "Array"},
    {"id": "yup08", "type": "required", "name": "Required/Optional", "description": "Optionality", "pattern": "yup.string().required('Name is required')\nyup.string().optional()\nyup.string().nullable()\nyup.string().defined()  // Not undefined\nyup.string().notRequired()", "example": "Required"},
    {"id": "yup09", "type": "default", "name": "Default Values", "description": "Set defaults", "pattern": "yup.string().default('Anonymous')\nyup.number().default(0)\nyup.date().default(() => new Date())", "example": "Default"},
    {"id": "yup10", "type": "when", "name": "Conditional Validation", "description": "When clause", "pattern": "const schema = yup.object({\n  isBusiness: yup.boolean(),\n  companyName: yup.string().when('isBusiness', {\n    is: true,\n    then: (schema) => schema.required('Company name required'),\n    otherwise: (schema) => schema.optional()\n  })\n});", "example": "When"},
    {"id": "yup11", "type": "ref", "name": "Reference Fields", "description": "Cross-field", "pattern": "const schema = yup.object({\n  password: yup.string().required(),\n  confirm: yup.string()\n    .oneOf([yup.ref('password')], 'Passwords must match')\n    .required()\n});", "example": "Ref"},
    {"id": "yup12", "type": "test", "name": "Custom Test", "description": "Custom validation", "pattern": "yup.string().test(\n  'is-valid-username',\n  'Username is not valid',\n  (value) => /^[a-z0-9_]+$/.test(value)\n);\n\n// Async test\nyup.string().test(\n  'is-unique',\n  'Email already exists',\n  async (value) => {\n    const exists = await checkEmail(value);\n    return !exists;\n  }\n);", "example": "Test"},
    {"id": "yup13", "type": "transform", "name": "Transform", "description": "Transform values", "pattern": "yup.string()\n  .transform((value) => value.toLowerCase())\n  .trim();\n\nyup.number()\n  .transform((value, original) => {\n    return original === '' ? undefined : value;\n  });", "example": "Transform"},
    {"id": "yup14", "type": "cast", "name": "Cast Data", "description": "Coerce values", "pattern": "const schema = yup.object({\n  age: yup.number()\n});\n\nconst casted = schema.cast({ age: '25' });\n// { age: 25 }\n\n// With validation\nconst result = await schema.validate({ age: '25' });", "example": "Cast"},
    {"id": "yup15", "type": "oneOf", "name": "Enum Values", "description": "Allowed values", "pattern": "yup.string().oneOf(['admin', 'user', 'guest'])\nyup.number().oneOf([1, 2, 3])\n\n// Exclude values\nyup.string().notOneOf(['admin'])", "example": "OneOf"},
    {"id": "yup16", "type": "mixed", "name": "Mixed Type", "description": "Any type", "pattern": "yup.mixed()\n  .required()\n  .oneOf([null, 'value'])\n  .test('is-file', 'Must be a file', (value) => value instanceof File)", "example": "Mixed"},
    {"id": "yup17", "type": "lazy", "name": "Lazy Schema", "description": "Dynamic schema", "pattern": "const schema = yup.lazy((value) => {\n  if (typeof value === 'string') {\n    return yup.string().required();\n  }\n  return yup.number().required();\n});", "example": "Lazy"},
    {"id": "yup18", "type": "concat", "name": "Concat Schemas", "description": "Combine schemas", "pattern": "const baseSchema = yup.object({ id: yup.number() });\nconst extendedSchema = baseSchema.concat(\n  yup.object({ name: yup.string() })\n);", "example": "Concat"},
    {"id": "yup19", "type": "pick", "name": "Pick/Omit", "description": "Select fields", "pattern": "const fullSchema = yup.object({\n  name: yup.string(),\n  email: yup.string(),\n  password: yup.string()\n});\n\nconst loginSchema = fullSchema.pick(['email', 'password']);\nconst publicSchema = fullSchema.omit(['password']);", "example": "Pick"},
    {"id": "yup20", "type": "shape", "name": "Shape", "description": "Partial update", "pattern": "const schema = yup.object({\n  name: yup.string(),\n  email: yup.string()\n});\n\nconst updatedSchema = schema.shape({\n  name: yup.string().required()  // Override name only\n});", "example": "Shape"},
    {"id": "yup21", "type": "error", "name": "Error Messages", "description": "Custom messages", "pattern": "yup.string()\n  .required('Name is required')\n  .min(2, 'Too short')\n  .max(50, 'Too long');\n\n// With params\nyup.string().min(5, ({ min }) => `Must be at least ${min} characters`);", "example": "Errors"},
    {"id": "yup22", "type": "locale", "name": "Localization", "description": "Global messages", "pattern": "import { setLocale } from 'yup';\n\nsetLocale({\n  mixed: {\n    required: 'Field is required',\n    notType: 'Invalid type'\n  },\n  string: {\n    email: 'Invalid email',\n    min: 'Must be at least ${min} characters'\n  }\n});", "example": "Locale"},
    {"id": "yup23", "type": "abort", "name": "Abort Early", "description": "Validation options", "pattern": "// Stop on first error (default)\nawait schema.validate(data);\n\n// Collect all errors\nawait schema.validate(data, { abortEarly: false });\n\n// Get all errors\ntry {\n  await schema.validate(data, { abortEarly: false });\n} catch (err) {\n  console.log(err.errors);  // All error messages\n}", "example": "Abort"},
    {"id": "yup24", "type": "strip", "name": "Strip Unknown", "description": "Handle extra keys", "pattern": "const schema = yup.object({\n  name: yup.string()\n}).strict();  // Error on unknown keys\n\nconst schema = yup.object({\n  name: yup.string()\n}).noUnknown();  // Remove unknown keys", "example": "Strip"},
    {"id": "yup25", "type": "formik", "name": "Formik Integration", "description": "React forms", "pattern": "import { Formik, Form, Field } from 'formik';\n\nconst schema = yup.object({\n  email: yup.string().email().required()\n});\n\n<Formik\n  validationSchema={schema}\n  initialValues={{ email: '' }}\n  onSubmit={handleSubmit}\n>\n  <Form>\n    <Field name=\"email\" />\n  </Form>\n</Formik>", "example": "Formik"},
    {"id": "yup26", "type": "hook", "name": "React Hook Form", "description": "RHF integration", "pattern": "import { yupResolver } from '@hookform/resolvers/yup';\n\nconst { register, handleSubmit, errors } = useForm({\n  resolver: yupResolver(schema)\n});", "example": "React Hook Form"},
    {"id": "yup27", "type": "typescript", "name": "TypeScript", "description": "Type inference", "pattern": "import * as yup from 'yup';\nimport { InferType } from 'yup';\n\nconst schema = yup.object({\n  name: yup.string().required(),\n  age: yup.number()\n});\n\ntype User = InferType<typeof schema>;\n// { name: string; age?: number | undefined }", "example": "TypeScript"},
    {"id": "yup28", "type": "async", "name": "Async Validation", "description": "Server validation", "pattern": "const schema = yup.object({\n  email: yup.string()\n    .email()\n    .test('unique', 'Email taken', async (value) => {\n      const exists = await checkEmailExists(value);\n      return !exists;\n    })\n});\n\nawait schema.validate({ email: 'test@example.com' });", "example": "Async"},
    {"id": "yup29", "type": "api", "name": "API Validation", "description": "Express middleware", "pattern": "const validateBody = (schema) => async (req, res, next) => {\n  try {\n    req.body = await schema.validate(req.body, { abortEarly: false });\n    next();\n  } catch (err) {\n    res.status(400).json({ errors: err.errors });\n  }\n};\n\napp.post('/users', validateBody(userSchema), createUser);", "example": "API"},
    {"id": "yup30", "type": "pattern", "name": "Best Practices", "description": "Patterns", "pattern": "// 1. Define schemas separately\n// 2. Reuse with concat/shape\n// 3. Use InferType for types\n// 4. Custom error messages\n// 5. abortEarly: false for forms", "example": "Patterns"}
  ]
}
