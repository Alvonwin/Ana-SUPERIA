{
  "category": "bull-job-queue",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Bull/BullMQ job queue patterns",
  "skills": [
    {"id": "bul01", "type": "setup", "name": "Install Bull", "description": "NPM install", "pattern": "npm install bull\n// or BullMQ (newer)\nnpm install bullmq", "example": "Install"},
    {"id": "bul02", "type": "queue", "name": "Create Queue", "description": "Initialize queue", "pattern": "import Bull from 'bull';\n\nconst emailQueue = new Bull('email', {\n  redis: {\n    host: 'localhost',\n    port: 6379\n  }\n});", "example": "Queue"},
    {"id": "bul03", "type": "bullmq", "name": "BullMQ Queue", "description": "BullMQ syntax", "pattern": "import { Queue } from 'bullmq';\n\nconst connection = {\n  host: 'localhost',\n  port: 6379\n};\n\nconst emailQueue = new Queue('email', { connection });", "example": "BullMQ"},
    {"id": "bul04", "type": "add", "name": "Add Job", "description": "Add to queue", "pattern": "// Add single job\nawait emailQueue.add('send-email', {\n  to: 'user@example.com',\n  subject: 'Welcome',\n  body: 'Hello!'\n});\n\n// With options\nawait emailQueue.add('send-email', data, {\n  priority: 1,\n  delay: 5000,\n  attempts: 3\n});", "example": "Add"},
    {"id": "bul05", "type": "process", "name": "Process Jobs", "description": "Bull processor", "pattern": "emailQueue.process(async (job) => {\n  const { to, subject, body } = job.data;\n  \n  await sendEmail(to, subject, body);\n  \n  return { sent: true };\n});", "example": "Process"},
    {"id": "bul06", "type": "worker", "name": "BullMQ Worker", "description": "Worker process", "pattern": "import { Worker } from 'bullmq';\n\nconst worker = new Worker('email', async (job) => {\n  const { to, subject } = job.data;\n  await sendEmail(to, subject);\n  return { success: true };\n}, { connection });\n\nworker.on('completed', (job, result) => {\n  console.log(`Job ${job.id} completed:`, result);\n});", "example": "Worker"},
    {"id": "bul07", "type": "progress", "name": "Progress", "description": "Report progress", "pattern": "emailQueue.process(async (job) => {\n  const users = job.data.users;\n  \n  for (let i = 0; i < users.length; i++) {\n    await sendEmail(users[i]);\n    await job.progress((i + 1) / users.length * 100);\n  }\n  \n  return { sent: users.length };\n});", "example": "Progress"},
    {"id": "bul08", "type": "events", "name": "Events", "description": "Job events", "pattern": "emailQueue.on('completed', (job, result) => {\n  console.log(`Job ${job.id} completed:`, result);\n});\n\nemailQueue.on('failed', (job, err) => {\n  console.log(`Job ${job.id} failed:`, err.message);\n});\n\nemailQueue.on('progress', (job, progress) => {\n  console.log(`Job ${job.id} progress:`, progress);\n});", "example": "Events"},
    {"id": "bul09", "type": "delay", "name": "Delayed Jobs", "description": "Schedule jobs", "pattern": "// Delay by milliseconds\nawait emailQueue.add('reminder', data, {\n  delay: 60 * 60 * 1000  // 1 hour\n});\n\n// BullMQ with specific time\nawait emailQueue.add('scheduled', data, {\n  delay: new Date('2024-12-25').getTime() - Date.now()\n});", "example": "Delay"},
    {"id": "bul10", "type": "repeat", "name": "Repeatable Jobs", "description": "Recurring jobs", "pattern": "// Repeat every hour\nawait emailQueue.add('newsletter', data, {\n  repeat: {\n    every: 60 * 60 * 1000\n  }\n});\n\n// Cron pattern\nawait emailQueue.add('daily-report', data, {\n  repeat: {\n    cron: '0 9 * * *'  // Every day at 9 AM\n  }\n});", "example": "Repeat"},
    {"id": "bul11", "type": "retry", "name": "Retries", "description": "Retry failed jobs", "pattern": "await emailQueue.add('send-email', data, {\n  attempts: 5,\n  backoff: {\n    type: 'exponential',\n    delay: 1000  // 1s, 2s, 4s, 8s, 16s\n  }\n});\n\n// Or fixed backoff\nawait emailQueue.add('task', data, {\n  attempts: 3,\n  backoff: {\n    type: 'fixed',\n    delay: 5000\n  }\n});", "example": "Retry"},
    {"id": "bul12", "type": "priority", "name": "Priority", "description": "Job priority", "pattern": "// Lower number = higher priority\nawait emailQueue.add('urgent', data, { priority: 1 });\nawait emailQueue.add('normal', data, { priority: 5 });\nawait emailQueue.add('low', data, { priority: 10 });", "example": "Priority"},
    {"id": "bul13", "type": "concurrency", "name": "Concurrency", "description": "Parallel processing", "pattern": "// Bull\nemailQueue.process(5, async (job) => {\n  // Process up to 5 jobs concurrently\n});\n\n// BullMQ\nconst worker = new Worker('email', handler, {\n  connection,\n  concurrency: 5\n});", "example": "Concurrency"},
    {"id": "bul14", "type": "ratelimit", "name": "Rate Limiting", "description": "Limit throughput", "pattern": "// Bull\nconst rateLimitedQueue = new Bull('api-calls', {\n  limiter: {\n    max: 100,\n    duration: 60000  // 100 jobs per minute\n  }\n});\n\n// BullMQ\nconst worker = new Worker('api', handler, {\n  limiter: {\n    max: 100,\n    duration: 60000\n  }\n});", "example": "Rate"},
    {"id": "bul15", "type": "named", "name": "Named Processors", "description": "Multiple processors", "pattern": "// Add with name\nawait emailQueue.add('welcome', { userId: 1 });\nawait emailQueue.add('reset-password', { userId: 2 });\n\n// Process by name\nemailQueue.process('welcome', async (job) => {\n  await sendWelcomeEmail(job.data.userId);\n});\n\nemailQueue.process('reset-password', async (job) => {\n  await sendResetEmail(job.data.userId);\n});", "example": "Named"},
    {"id": "bul16", "type": "remove", "name": "Remove Jobs", "description": "Delete jobs", "pattern": "// Remove by job instance\nconst job = await emailQueue.add('task', data);\nawait job.remove();\n\n// Remove completed jobs\nawait emailQueue.clean(1000, 'completed');  // Older than 1s\n\n// Remove failed jobs\nawait emailQueue.clean(1000, 'failed');", "example": "Remove"},
    {"id": "bul17", "type": "pause", "name": "Pause/Resume", "description": "Control queue", "pattern": "// Pause queue\nawait emailQueue.pause();\n\n// Resume queue\nawait emailQueue.resume();\n\n// Check if paused\nconst isPaused = await emailQueue.isPaused();", "example": "Pause"},
    {"id": "bul18", "type": "get", "name": "Get Jobs", "description": "Query jobs", "pattern": "// Get job by ID\nconst job = await emailQueue.getJob(jobId);\n\n// Get jobs by state\nconst waiting = await emailQueue.getWaiting();\nconst active = await emailQueue.getActive();\nconst completed = await emailQueue.getCompleted();\nconst failed = await emailQueue.getFailed();\n\n// Get counts\nconst counts = await emailQueue.getJobCounts();", "example": "Get"},
    {"id": "bul19", "type": "flow", "name": "Flow (BullMQ)", "description": "Job dependencies", "pattern": "import { FlowProducer } from 'bullmq';\n\nconst flow = new FlowProducer({ connection });\n\nawait flow.add({\n  name: 'process-order',\n  queueName: 'orders',\n  data: { orderId: 123 },\n  children: [\n    { name: 'charge-card', queueName: 'payments', data: {} },\n    { name: 'send-email', queueName: 'emails', data: {} }\n  ]\n});", "example": "Flow"},
    {"id": "bul20", "type": "sandboxed", "name": "Sandboxed Process", "description": "Separate process", "pattern": "// processor.js\nmodule.exports = async function(job) {\n  const result = await heavyComputation(job.data);\n  return result;\n};\n\n// main.js\nemailQueue.process('./processor.js');", "example": "Sandboxed"},
    {"id": "bul21", "type": "stalled", "name": "Stalled Jobs", "description": "Handle stalled", "pattern": "emailQueue.on('stalled', (jobId) => {\n  console.log(`Job ${jobId} stalled`);\n});\n\n// Configure stall detection\nconst queue = new Bull('email', {\n  settings: {\n    stalledInterval: 30000,  // Check every 30s\n    maxStalledCount: 2       // Max stall retries\n  }\n});", "example": "Stalled"},
    {"id": "bul22", "type": "global", "name": "Global Events", "description": "Cross-process events", "pattern": "// Global events (require Redis)\nconst queueEvents = new QueueEvents('email', { connection });\n\nqueueEvents.on('completed', ({ jobId, returnvalue }) => {\n  console.log(`Job ${jobId} completed globally`);\n});\n\nqueueEvents.on('failed', ({ jobId, failedReason }) => {\n  console.log(`Job ${jobId} failed:`, failedReason);\n});", "example": "Global"},
    {"id": "bul23", "type": "board", "name": "Bull Board", "description": "Admin UI", "pattern": "import { createBullBoard } from '@bull-board/api';\nimport { BullAdapter } from '@bull-board/api/bullAdapter';\nimport { ExpressAdapter } from '@bull-board/express';\n\nconst serverAdapter = new ExpressAdapter();\nserverAdapter.setBasePath('/admin/queues');\n\ncreateBullBoard({\n  queues: [new BullAdapter(emailQueue)],\n  serverAdapter\n});\n\napp.use('/admin/queues', serverAdapter.getRouter());", "example": "Board"},
    {"id": "bul24", "type": "batch", "name": "Batch Add", "description": "Add multiple", "pattern": "// Bull\nawait emailQueue.addBulk([\n  { name: 'email', data: { to: 'user1@example.com' } },\n  { name: 'email', data: { to: 'user2@example.com' } },\n  { name: 'email', data: { to: 'user3@example.com' } }\n]);", "example": "Batch"},
    {"id": "bul25", "type": "drain", "name": "Drain Queue", "description": "Empty queue", "pattern": "// Wait for all jobs to complete and remove\nawait emailQueue.drain();\n\n// Empty queue immediately\nawait emailQueue.empty();", "example": "Drain"},
    {"id": "bul26", "type": "ttl", "name": "Job TTL", "description": "Auto remove", "pattern": "await emailQueue.add('task', data, {\n  removeOnComplete: true,  // Remove when done\n  removeOnFail: 1000,      // Keep last 1000 failed\n});", "example": "TTL"},
    {"id": "bul27", "type": "unique", "name": "Unique Jobs", "description": "Prevent duplicates", "pattern": "// Use jobId for uniqueness\nawait emailQueue.add('send', data, {\n  jobId: `email-${userId}-${type}`  // Unique key\n});\n\n// BullMQ with deduplication\nawait emailQueue.add('task', data, {\n  jobId: uniqueId,\n  deduplication: {\n    id: 'unique-task-id'\n  }\n});", "example": "Unique"},
    {"id": "bul28", "type": "typescript", "name": "TypeScript", "description": "Type safety", "pattern": "import { Queue, Worker, Job } from 'bullmq';\n\ninterface EmailJobData {\n  to: string;\n  subject: string;\n  body: string;\n}\n\nconst emailQueue = new Queue<EmailJobData>('email', { connection });\n\nconst worker = new Worker<EmailJobData>('email', async (job: Job<EmailJobData>) => {\n  const { to, subject, body } = job.data;\n});", "example": "TypeScript"},
    {"id": "bul29", "type": "test", "name": "Testing", "description": "Test jobs", "pattern": "import { Queue, Worker } from 'bullmq';\nimport { GenericContainer } from 'testcontainers';\n\ndescribe('Email Queue', () => {\n  let container, queue;\n  \n  beforeAll(async () => {\n    container = await new GenericContainer('redis').withExposedPorts(6379).start();\n    queue = new Queue('test', {\n      connection: { host: 'localhost', port: container.getMappedPort(6379) }\n    });\n  });\n});", "example": "Testing"},
    {"id": "bul30", "type": "pattern", "name": "Best Practices", "description": "Patterns", "pattern": "// 1. Use separate queues for different job types\n// 2. Implement proper error handling\n// 3. Set appropriate retry strategies\n// 4. Monitor queue health with Bull Board\n// 5. Use rate limiting for external APIs", "example": "Patterns"}
  ]
}
