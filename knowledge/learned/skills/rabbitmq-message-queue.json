{
  "category": "rabbitmq-message-queue",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "RabbitMQ message queue patterns",
  "skills": [
    {"id": "rmq01", "type": "setup", "name": "Install amqplib", "description": "NPM install", "pattern": "npm install amqplib\nnpm install @types/amqplib --save-dev", "example": "Install"},
    {"id": "rmq02", "type": "connect", "name": "Connect", "description": "Create connection", "pattern": "import amqp from 'amqplib';\n\nconst connection = await amqp.connect('amqp://localhost');\nconst channel = await connection.createChannel();\n\n// Close gracefully\nprocess.on('SIGINT', async () => {\n  await channel.close();\n  await connection.close();\n  process.exit(0);\n});", "example": "Connect"},
    {"id": "rmq03", "type": "queue", "name": "Declare Queue", "description": "Create queue", "pattern": "await channel.assertQueue('tasks', {\n  durable: true,      // Survives restart\n  exclusive: false,   // Not exclusive to connection\n  autoDelete: false,  // Don't delete when unused\n  maxLength: 10000    // Max messages\n});", "example": "Queue"},
    {"id": "rmq04", "type": "send", "name": "Send Message", "description": "Publish to queue", "pattern": "const message = { userId: 123, action: 'process' };\n\nchannel.sendToQueue('tasks', Buffer.from(JSON.stringify(message)), {\n  persistent: true,       // Survives restart\n  contentType: 'application/json'\n});", "example": "Send"},
    {"id": "rmq05", "type": "consume", "name": "Consume Messages", "description": "Receive messages", "pattern": "channel.consume('tasks', (msg) => {\n  if (msg) {\n    const content = JSON.parse(msg.content.toString());\n    console.log('Received:', content);\n    \n    // Acknowledge message\n    channel.ack(msg);\n  }\n}, { noAck: false });", "example": "Consume"},
    {"id": "rmq06", "type": "ack", "name": "Acknowledgment", "description": "Message ack/nack", "pattern": "channel.consume('tasks', async (msg) => {\n  try {\n    await processMessage(msg);\n    channel.ack(msg);            // Success\n  } catch (err) {\n    channel.nack(msg, false, true);  // Requeue\n    // channel.nack(msg, false, false);  // Discard\n  }\n});", "example": "Ack"},
    {"id": "rmq07", "type": "prefetch", "name": "Prefetch", "description": "Limit unacked", "pattern": "// Process one message at a time\nawait channel.prefetch(1);\n\n// Or per-channel limit\nawait channel.prefetch(10, true);", "example": "Prefetch"},
    {"id": "rmq08", "type": "exchange", "name": "Exchanges", "description": "Message routing", "pattern": "// Direct exchange\nawait channel.assertExchange('logs', 'direct', { durable: true });\n\n// Fanout (broadcast)\nawait channel.assertExchange('notifications', 'fanout', { durable: true });\n\n// Topic (pattern matching)\nawait channel.assertExchange('events', 'topic', { durable: true });\n\n// Headers (header matching)\nawait channel.assertExchange('headers', 'headers', { durable: true });", "example": "Exchanges"},
    {"id": "rmq09", "type": "bind", "name": "Bind Queue", "description": "Connect to exchange", "pattern": "await channel.assertQueue('user-logs');\nawait channel.bindQueue('user-logs', 'logs', 'user.*');\n\n// Multiple bindings\nawait channel.bindQueue('errors', 'logs', 'error');\nawait channel.bindQueue('errors', 'logs', 'fatal');", "example": "Bind"},
    {"id": "rmq10", "type": "publish", "name": "Publish", "description": "Publish to exchange", "pattern": "channel.publish('logs', 'user.created', Buffer.from(JSON.stringify({\n  userId: 123,\n  event: 'created'\n})), {\n  persistent: true,\n  contentType: 'application/json'\n});", "example": "Publish"},
    {"id": "rmq11", "type": "fanout", "name": "Fanout Pattern", "description": "Broadcast", "pattern": "// Publisher\nawait channel.assertExchange('broadcast', 'fanout');\nchannel.publish('broadcast', '', Buffer.from('Hello everyone'));\n\n// Subscriber\nconst { queue } = await channel.assertQueue('', { exclusive: true });\nawait channel.bindQueue(queue, 'broadcast', '');\nchannel.consume(queue, (msg) => console.log(msg.content.toString()));", "example": "Fanout"},
    {"id": "rmq12", "type": "topic", "name": "Topic Pattern", "description": "Pattern routing", "pattern": "// Publisher\nawait channel.assertExchange('events', 'topic');\nchannel.publish('events', 'user.created.us', Buffer.from(data));\nchannel.publish('events', 'order.paid.eu', Buffer.from(data));\n\n// Subscriber\nawait channel.bindQueue(queue, 'events', 'user.#');     // All user events\nawait channel.bindQueue(queue, 'events', '*.created.*'); // All created events", "example": "Topic"},
    {"id": "rmq13", "type": "rpc", "name": "RPC Pattern", "description": "Request/reply", "pattern": "// Client\nconst { queue: replyQueue } = await channel.assertQueue('', { exclusive: true });\nconst correlationId = uuid();\n\nchannel.consume(replyQueue, (msg) => {\n  if (msg.properties.correlationId === correlationId) {\n    console.log('Response:', msg.content.toString());\n  }\n});\n\nchannel.sendToQueue('rpc_queue', Buffer.from(request), {\n  correlationId,\n  replyTo: replyQueue\n});\n\n// Server\nchannel.consume('rpc_queue', async (msg) => {\n  const response = await process(msg);\n  channel.sendToQueue(msg.properties.replyTo, Buffer.from(response), {\n    correlationId: msg.properties.correlationId\n  });\n  channel.ack(msg);\n});", "example": "RPC"},
    {"id": "rmq14", "type": "dead", "name": "Dead Letter", "description": "Failed messages", "pattern": "// Dead letter exchange\nawait channel.assertExchange('dlx', 'direct');\nawait channel.assertQueue('dead-letters');\nawait channel.bindQueue('dead-letters', 'dlx', '');\n\n// Main queue with DLX\nawait channel.assertQueue('tasks', {\n  deadLetterExchange: 'dlx',\n  messageTtl: 60000  // Optional TTL\n});", "example": "Dead Letter"},
    {"id": "rmq15", "type": "priority", "name": "Priority Queue", "description": "Message priority", "pattern": "await channel.assertQueue('priority-queue', {\n  maxPriority: 10\n});\n\nchannel.sendToQueue('priority-queue', Buffer.from('High priority'), {\n  priority: 9\n});\n\nchannel.sendToQueue('priority-queue', Buffer.from('Low priority'), {\n  priority: 1\n});", "example": "Priority"},
    {"id": "rmq16", "type": "delay", "name": "Delayed Message", "description": "Delay delivery", "pattern": "// Using TTL and DLX\nawait channel.assertQueue('delay-5s', {\n  messageTtl: 5000,\n  deadLetterExchange: '',\n  deadLetterRoutingKey: 'target-queue'\n});\n\nchannel.sendToQueue('delay-5s', Buffer.from('Delayed message'));\n// Message arrives in target-queue after 5 seconds", "example": "Delay"},
    {"id": "rmq17", "type": "confirm", "name": "Publisher Confirms", "description": "Delivery confirmation", "pattern": "const confirmChannel = await connection.createConfirmChannel();\n\nconfirmChannel.sendToQueue('tasks', Buffer.from(message), {}, (err, ok) => {\n  if (err) console.error('Message not confirmed');\n  else console.log('Message confirmed');\n});\n\n// Or with waitForConfirms\nawait confirmChannel.waitForConfirms();", "example": "Confirm"},
    {"id": "rmq18", "type": "headers", "name": "Headers Exchange", "description": "Header routing", "pattern": "await channel.assertExchange('headers-ex', 'headers');\n\nawait channel.bindQueue(queue, 'headers-ex', '', {\n  'x-match': 'all',  // or 'any'\n  format: 'pdf',\n  type: 'report'\n});\n\nchannel.publish('headers-ex', '', Buffer.from(data), {\n  headers: { format: 'pdf', type: 'report' }\n});", "example": "Headers"},
    {"id": "rmq19", "type": "cluster", "name": "Cluster Connection", "description": "High availability", "pattern": "const connection = await amqp.connect([\n  'amqp://node1.example.com',\n  'amqp://node2.example.com',\n  'amqp://node3.example.com'\n]);\n\n// Or with heartbeat\nconst connection = await amqp.connect('amqp://localhost?heartbeat=30');", "example": "Cluster"},
    {"id": "rmq20", "type": "reconnect", "name": "Reconnection", "description": "Handle disconnects", "pattern": "async function connect() {\n  try {\n    const connection = await amqp.connect('amqp://localhost');\n    connection.on('error', (err) => {\n      console.error('Connection error:', err);\n    });\n    connection.on('close', () => {\n      console.log('Reconnecting...');\n      setTimeout(connect, 5000);\n    });\n    return connection;\n  } catch (err) {\n    setTimeout(connect, 5000);\n  }\n}", "example": "Reconnect"},
    {"id": "rmq21", "type": "ttl", "name": "Message TTL", "description": "Expiration", "pattern": "// Per-message TTL\nchannel.sendToQueue('tasks', Buffer.from(message), {\n  expiration: '60000'  // 60 seconds\n});\n\n// Per-queue TTL\nawait channel.assertQueue('temp-queue', {\n  messageTtl: 300000  // 5 minutes\n});", "example": "TTL"},
    {"id": "rmq22", "type": "cancel", "name": "Cancel Consumer", "description": "Stop consuming", "pattern": "const { consumerTag } = await channel.consume('tasks', handler);\n\n// Cancel later\nawait channel.cancel(consumerTag);", "example": "Cancel"},
    {"id": "rmq23", "type": "purge", "name": "Purge Queue", "description": "Delete messages", "pattern": "await channel.purgeQueue('tasks');\n// All messages in queue deleted", "example": "Purge"},
    {"id": "rmq24", "type": "delete", "name": "Delete Queue", "description": "Remove queue", "pattern": "await channel.deleteQueue('old-queue');\n\n// Delete only if empty\nawait channel.deleteQueue('queue', { ifEmpty: true });\n\n// Delete only if unused\nawait channel.deleteQueue('queue', { ifUnused: true });", "example": "Delete"},
    {"id": "rmq25", "type": "check", "name": "Check Queue", "description": "Queue info", "pattern": "const { queue, messageCount, consumerCount } = await channel.checkQueue('tasks');\nconsole.log(`Messages: ${messageCount}, Consumers: ${consumerCount}`);", "example": "Check"},
    {"id": "rmq26", "type": "get", "name": "Get Message", "description": "Pull message", "pattern": "const msg = await channel.get('tasks', { noAck: false });\nif (msg) {\n  console.log(msg.content.toString());\n  channel.ack(msg);\n} else {\n  console.log('Queue empty');\n}", "example": "Get"},
    {"id": "rmq27", "type": "typescript", "name": "TypeScript", "description": "Type safety", "pattern": "import amqp, { Connection, Channel, ConsumeMessage } from 'amqplib';\n\ninterface TaskMessage {\n  userId: number;\n  action: string;\n}\n\nfunction parseMessage(msg: ConsumeMessage): TaskMessage {\n  return JSON.parse(msg.content.toString());\n}", "example": "TypeScript"},
    {"id": "rmq28", "type": "test", "name": "Testing", "description": "Test with mock", "pattern": "// Use testcontainers for integration tests\nimport { GenericContainer } from 'testcontainers';\n\nconst container = await new GenericContainer('rabbitmq:3')\n  .withExposedPorts(5672)\n  .start();\n\nconst connection = await amqp.connect(\n  `amqp://localhost:${container.getMappedPort(5672)}`\n);", "example": "Testing"},
    {"id": "rmq29", "type": "docker", "name": "Docker Setup", "description": "Container", "pattern": "# docker-compose.yml\nservices:\n  rabbitmq:\n    image: rabbitmq:3-management\n    ports:\n      - '5672:5672'\n      - '15672:15672'  # Management UI\n    environment:\n      RABBITMQ_DEFAULT_USER: user\n      RABBITMQ_DEFAULT_PASS: password", "example": "Docker"},
    {"id": "rmq30", "type": "pattern", "name": "Best Practices", "description": "Patterns", "pattern": "// 1. Use durable queues and persistent messages\n// 2. Set prefetch for fair dispatch\n// 3. Handle reconnection\n// 4. Use publisher confirms\n// 5. Implement dead letter queues", "example": "Patterns"}
  ]
}
