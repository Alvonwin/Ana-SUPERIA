{
  "category": "functional-programming",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Functional Programming Concepts",
  "skills": [
    {"id": "fp01", "type": "core", "name": "Pure Functions", "description": "No side effects", "pattern": "Same input → same output", "example": "Predictable"},
    {"id": "fp02", "type": "core", "name": "Immutability", "description": "No mutation", "pattern": "Create new values", "example": "Thread-safe"},
    {"id": "fp03", "type": "core", "name": "First-Class Functions", "description": "Functions as values", "pattern": "Pass, return functions", "example": "Callbacks"},
    {"id": "fp04", "type": "core", "name": "Higher-Order Functions", "description": "Functions on functions", "pattern": "map, filter, reduce", "example": "Abstraction"},
    {"id": "fp05", "type": "core", "name": "Referential Transparency", "description": "Expression substitution", "pattern": "Replace with value", "example": "Reasoning"},
    {"id": "fp06", "type": "composition", "name": "Function Composition", "description": "Combine functions", "pattern": "f ∘ g = f(g(x))", "example": "Build pipelines"},
    {"id": "fp07", "type": "composition", "name": "Currying", "description": "Partial application", "pattern": "f(a)(b) vs f(a, b)", "example": "Specialize functions"},
    {"id": "fp08", "type": "composition", "name": "Partial Application", "description": "Fix some arguments", "pattern": "bind, partial", "example": "Create variants"},
    {"id": "fp09", "type": "composition", "name": "Point-Free Style", "description": "No explicit arguments", "pattern": "compose(f, g)", "example": "Tacit programming"},
    {"id": "fp10", "type": "collections", "name": "Map", "description": "Transform elements", "pattern": "f(x) for each x", "example": "Apply function"},
    {"id": "fp11", "type": "collections", "name": "Filter", "description": "Select elements", "pattern": "Keep if predicate", "example": "Subset selection"},
    {"id": "fp12", "type": "collections", "name": "Reduce/Fold", "description": "Aggregate values", "pattern": "Accumulate result", "example": "Sum, concat"},
    {"id": "fp13", "type": "collections", "name": "FlatMap", "description": "Map then flatten", "pattern": "Chain operations", "example": "Nested transforms"},
    {"id": "fp14", "type": "types", "name": "Algebraic Data Types", "description": "Sum and product types", "pattern": "Enum, struct", "example": "Data modeling"},
    {"id": "fp15", "type": "types", "name": "Pattern Matching", "description": "Destructure types", "pattern": "match expression", "example": "Type-safe branching"},
    {"id": "fp16", "type": "types", "name": "Option/Maybe", "description": "Nullable alternative", "pattern": "Some/None", "example": "Safe null handling"},
    {"id": "fp17", "type": "types", "name": "Either/Result", "description": "Error handling", "pattern": "Left/Right", "example": "Typed errors"},
    {"id": "fp18", "type": "monads", "name": "Functors", "description": "Mappable containers", "pattern": "map method", "example": "Context-aware map"},
    {"id": "fp19", "type": "monads", "name": "Applicatives", "description": "Apply in context", "pattern": "apply method", "example": "Multiple contexts"},
    {"id": "fp20", "type": "monads", "name": "Monads", "description": "Chainable containers", "pattern": "flatMap/bind", "example": "Sequential operations"},
    {"id": "fp21", "type": "monads", "name": "Monad Laws", "description": "Monad properties", "pattern": "Left/right identity, associativity", "example": "Valid monads"},
    {"id": "fp22", "type": "monads", "name": "IO Monad", "description": "Side effect container", "pattern": "Defer effects", "example": "Pure I/O"},
    {"id": "fp23", "type": "techniques", "name": "Recursion", "description": "Self-reference", "pattern": "Base case + recursive", "example": "Loop alternative"},
    {"id": "fp24", "type": "techniques", "name": "Tail Recursion", "description": "Optimized recursion", "pattern": "Accumulator pattern", "example": "Stack-safe"},
    {"id": "fp25", "type": "techniques", "name": "Lazy Evaluation", "description": "Defer computation", "pattern": "Evaluate when needed", "example": "Infinite lists"},
    {"id": "fp26", "type": "techniques", "name": "Memoization", "description": "Cache results", "pattern": "Store computed values", "example": "Performance"},
    {"id": "fp27", "type": "concepts", "name": "Declarative Style", "description": "What not how", "pattern": "Describe outcome", "example": "vs imperative"},
    {"id": "fp28", "type": "concepts", "name": "Expression-Based", "description": "Everything returns", "pattern": "No statements", "example": "Composable"},
    {"id": "fp29", "type": "concepts", "name": "Type Classes", "description": "Ad-hoc polymorphism", "pattern": "Interface + instances", "example": "Show, Eq"},
    {"id": "fp30", "type": "concepts", "name": "Lenses", "description": "Immutable updates", "pattern": "Focus on nested data", "example": "Deep updates"}
  ]
}
