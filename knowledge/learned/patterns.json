{
  "code": [
    {
      "name": "Express Route Handler",
      "pattern": "router.get...",
      "usage": "API REST endpoints"
    },
    {
      "name": "Async File Operation",
      "pattern": "await fs.promises.readFile...",
      "usage": "Lecture fichier avec fallback"
    },
    {
      "name": "Safe JSON Parse",
      "pattern": "try/catch JSON.parse",
      "usage": "Parser JSON sans crasher"
    },
    {
      "name": "Debounced Function",
      "pattern": "clearTimeout/setTimeout",
      "usage": "Eviter les appels repetitifs"
    },
    {
      "name": "Retry with Backoff",
      "pattern": "for loop with exponential delay",
      "usage": "Retenter les operations"
    },
    {
      "name": "Pipeline Pattern",
      "pattern": "pipe(validate, transform, enrich, save)",
      "usage": "Chainer les transformations"
    },
    {
      "name": "Factory Function",
      "pattern": "createService = (config) => ({ methods })",
      "usage": "Instances configurables"
    }
  ],
  "conversation": [
    {
      "trigger": "demande de code",
      "response_style": "code d abord, explication ensuite",
      "rule": "Montrer le code fonctionnel avant d expliquer"
    },
    {
      "trigger": "erreur/bug",
      "response_style": "diagnostic puis solution",
      "rule": "1) Identifier 2) Expliquer 3) Solution"
    },
    {
      "trigger": "question vague",
      "response_style": "clarifier avant d agir",
      "rule": "Poser des questions pour comprendre le contexte"
    }
  ],
  "problem_solving": [
    {
      "error_type": "TypeError: Cannot read property of undefined",
      "cause": "Acces a propriete null/undefined",
      "fix": "Utiliser optional chaining: obj?.prop"
    },
    {
      "error_type": "ENOENT",
      "cause": "Fichier inexistant",
      "fix": "fs.existsSync ou mkdirSync recursive"
    },
    {
      "error_type": "EADDRINUSE",
      "cause": "Port deja utilise",
      "fix": "netstat -ano | findstr :PORT puis taskkill"
    },
    {
      "error_type": "SyntaxError JSON",
      "cause": "JSON mal forme",
      "fix": "try/catch JSON.parse"
    },
    {
      "error_type": "UnhandledPromiseRejection",
      "cause": "Promise sans catch",
      "fix": ".catch() ou try/catch async"
    }
  ],
  "avoid": [
    {
      "mistake_type": "VOUVOIEMENT",
      "what_went_wrong": "Utiliser vous au lieu de tu",
      "improvement_rule": "TOUJOURS tutoyer Alain",
      "anti_pattern": "Vous pouvez -> Tu peux"
    },
    {
      "mistake_type": "God Function",
      "what_went_wrong": "Fonction trop longue",
      "improvement_rule": "Max 10-20 lignes",
      "anti_pattern": "function doEverything()"
    },
    {
      "mistake_type": "Silent Failures",
      "what_went_wrong": "catch vide",
      "improvement_rule": "Toujours logger",
      "anti_pattern": "catch(e) {}"
    },
    {
      "mistake_type": "Magic Numbers",
      "what_went_wrong": "Nombres hardcodes",
      "improvement_rule": "const MAX_RETRIES = 3",
      "anti_pattern": "if (x > 3)"
    },
    {
      "mistake_type": "Callback Hell",
      "what_went_wrong": "Callbacks imbriques",
      "improvement_rule": "async/await",
      "anti_pattern": "fn1(() => fn2(() => fn3()))"
    },
    {
      "mistake_type": "Copy-Paste",
      "what_went_wrong": "Code duplique",
      "improvement_rule": "Factoriser si > 3 lignes",
      "anti_pattern": "// meme bloc 5 fois"
    },
    {
      "mistake_type": "Hardcoded Secrets",
      "what_went_wrong": "API keys dans code",
      "improvement_rule": "Variables environnement",
      "anti_pattern": "const KEY = sk-..."
    },
    {
      "mistake_type": "SQL Injection",
      "what_went_wrong": "Pas de validation input",
      "improvement_rule": "Prepared statements",
      "anti_pattern": "WHERE id = .params.id"
    }
  ],
  "userPreferences": {
    "language": "fr",
    "codeStyle": "clean",
    "verbosity": "concise"
  },
  "lastUpdated": "2025-12-22T03:49:59.989Z"
}