{
  "category": "oauth2-authorization",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "OAuth 2.0 authorization patterns",
  "skills": [
    {"id": "oa201", "type": "concept", "name": "OAuth 2.0 Flows", "description": "Grant types", "pattern": "// Authorization Code - Web apps with backend\n// PKCE - SPAs and mobile apps\n// Client Credentials - Server-to-server\n// Device Code - Limited input devices\n// Refresh Token - Get new access tokens", "example": "Flows"},
    {"id": "oa202", "type": "auth", "name": "Authorization Code", "description": "Standard flow", "pattern": "// 1. Redirect to authorization\nconst authUrl = new URL('https://auth.example.com/authorize');\nauthUrl.searchParams.set('client_id', CLIENT_ID);\nauthUrl.searchParams.set('redirect_uri', REDIRECT_URI);\nauthUrl.searchParams.set('response_type', 'code');\nauthUrl.searchParams.set('scope', 'read write');\nauthUrl.searchParams.set('state', generateState());\n\n// 2. User authorizes, redirected back with code\n// 3. Exchange code for tokens", "example": "Auth Code"},
    {"id": "oa203", "type": "exchange", "name": "Token Exchange", "description": "Get tokens", "pattern": "// Exchange authorization code for tokens\nconst response = await fetch('https://auth.example.com/token', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n  body: new URLSearchParams({\n    grant_type: 'authorization_code',\n    code: authorizationCode,\n    redirect_uri: REDIRECT_URI,\n    client_id: CLIENT_ID,\n    client_secret: CLIENT_SECRET\n  })\n});\n\nconst { access_token, refresh_token, expires_in } = await response.json();", "example": "Exchange"},
    {"id": "oa204", "type": "pkce", "name": "PKCE Flow", "description": "Proof Key", "pattern": "import crypto from 'crypto';\n\n// Generate code verifier (random string)\nconst codeVerifier = crypto.randomBytes(32).toString('base64url');\n\n// Generate code challenge (SHA256 hash)\nconst codeChallenge = crypto\n  .createHash('sha256')\n  .update(codeVerifier)\n  .digest('base64url');\n\n// 1. Include in authorization request\nauthUrl.searchParams.set('code_challenge', codeChallenge);\nauthUrl.searchParams.set('code_challenge_method', 'S256');\n\n// 2. Include verifier in token exchange\nbody.set('code_verifier', codeVerifier);", "example": "PKCE"},
    {"id": "oa205", "type": "client", "name": "Client Credentials", "description": "Server-to-server", "pattern": "const response = await fetch('https://auth.example.com/token', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'Authorization': `Basic ${Buffer.from(`${CLIENT_ID}:${CLIENT_SECRET}`).toString('base64')}`\n  },\n  body: new URLSearchParams({\n    grant_type: 'client_credentials',\n    scope: 'api:read'\n  })\n});", "example": "Client Creds"},
    {"id": "oa206", "type": "refresh", "name": "Refresh Token", "description": "Get new access", "pattern": "const response = await fetch('https://auth.example.com/token', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/x-www-form-urlencoded' },\n  body: new URLSearchParams({\n    grant_type: 'refresh_token',\n    refresh_token: storedRefreshToken,\n    client_id: CLIENT_ID,\n    client_secret: CLIENT_SECRET\n  })\n});", "example": "Refresh"},
    {"id": "oa207", "type": "state", "name": "State Parameter", "description": "CSRF protection", "pattern": "// Generate state before redirect\nconst state = crypto.randomBytes(32).toString('hex');\nsessionStorage.setItem('oauth_state', state);\n\n// Verify on callback\nconst returnedState = new URLSearchParams(window.location.search).get('state');\nconst savedState = sessionStorage.getItem('oauth_state');\n\nif (returnedState !== savedState) {\n  throw new Error('State mismatch - possible CSRF attack');\n}", "example": "State"},
    {"id": "oa208", "type": "scope", "name": "Scopes", "description": "Permissions", "pattern": "// Common scopes\nconst scopes = [\n  'openid',        // OIDC\n  'profile',       // User profile\n  'email',         // Email address\n  'read:user',     // Read user data\n  'write:posts',   // Create/update posts\n  'offline_access' // Get refresh token\n].join(' ');\n\nauthUrl.searchParams.set('scope', scopes);", "example": "Scopes"},
    {"id": "oa209", "type": "google", "name": "Google OAuth", "description": "Google provider", "pattern": "const googleAuthUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth');\ngoogleAuthUrl.searchParams.set('client_id', GOOGLE_CLIENT_ID);\ngoogleAuthUrl.searchParams.set('redirect_uri', REDIRECT_URI);\ngoogleAuthUrl.searchParams.set('response_type', 'code');\ngoogleAuthUrl.searchParams.set('scope', 'openid email profile');\ngoogleAuthUrl.searchParams.set('access_type', 'offline');  // Get refresh token\ngoogleAuthUrl.searchParams.set('prompt', 'consent');\n\n// Token endpoint: https://oauth2.googleapis.com/token", "example": "Google"},
    {"id": "oa210", "type": "github", "name": "GitHub OAuth", "description": "GitHub provider", "pattern": "const githubAuthUrl = new URL('https://github.com/login/oauth/authorize');\ngithubAuthUrl.searchParams.set('client_id', GITHUB_CLIENT_ID);\ngithubAuthUrl.searchParams.set('redirect_uri', REDIRECT_URI);\ngithubAuthUrl.searchParams.set('scope', 'read:user user:email');\n\n// Token endpoint: https://github.com/login/oauth/access_token\n// User endpoint: https://api.github.com/user", "example": "GitHub"},
    {"id": "oa211", "type": "passport", "name": "Passport.js", "description": "Express OAuth", "pattern": "import passport from 'passport';\nimport { Strategy as GoogleStrategy } from 'passport-google-oauth20';\n\npassport.use(new GoogleStrategy({\n  clientID: GOOGLE_CLIENT_ID,\n  clientSecret: GOOGLE_CLIENT_SECRET,\n  callbackURL: '/auth/google/callback'\n}, async (accessToken, refreshToken, profile, done) => {\n  const user = await findOrCreateUser(profile);\n  done(null, user);\n}));\n\napp.get('/auth/google', passport.authenticate('google', { scope: ['profile', 'email'] }));\napp.get('/auth/google/callback', passport.authenticate('google'), (req, res) => {\n  res.redirect('/dashboard');\n});", "example": "Passport"},
    {"id": "oa212", "type": "nextauth", "name": "NextAuth.js", "description": "Next.js OAuth", "pattern": "// pages/api/auth/[...nextauth].ts\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\nimport GitHubProvider from 'next-auth/providers/github';\n\nexport default NextAuth({\n  providers: [\n    GoogleProvider({\n      clientId: process.env.GOOGLE_ID,\n      clientSecret: process.env.GOOGLE_SECRET\n    }),\n    GitHubProvider({\n      clientId: process.env.GITHUB_ID,\n      clientSecret: process.env.GITHUB_SECRET\n    })\n  ]\n});", "example": "NextAuth"},
    {"id": "oa213", "type": "device", "name": "Device Code Flow", "description": "TV/CLI apps", "pattern": "// 1. Request device code\nconst response = await fetch('https://auth.example.com/device/code', {\n  method: 'POST',\n  body: new URLSearchParams({ client_id: CLIENT_ID, scope: 'read' })\n});\nconst { device_code, user_code, verification_uri, interval } = await response.json();\n\nconsole.log(`Go to ${verification_uri} and enter: ${user_code}`);\n\n// 2. Poll for token\nwhile (true) {\n  await sleep(interval * 1000);\n  const tokenResponse = await fetch('https://auth.example.com/token', {\n    method: 'POST',\n    body: new URLSearchParams({\n      grant_type: 'urn:ietf:params:oauth:grant-type:device_code',\n      device_code,\n      client_id: CLIENT_ID\n    })\n  });\n  if (tokenResponse.ok) break;\n}", "example": "Device"},
    {"id": "oa214", "type": "introspect", "name": "Token Introspection", "description": "Validate token", "pattern": "const response = await fetch('https://auth.example.com/introspect', {\n  method: 'POST',\n  headers: {\n    'Authorization': `Basic ${credentials}`,\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: new URLSearchParams({ token: accessToken })\n});\n\nconst { active, scope, client_id, exp } = await response.json();\nif (!active) throw new Error('Token invalid');", "example": "Introspect"},
    {"id": "oa215", "type": "revoke", "name": "Token Revocation", "description": "Revoke tokens", "pattern": "await fetch('https://auth.example.com/revoke', {\n  method: 'POST',\n  headers: {\n    'Authorization': `Basic ${credentials}`,\n    'Content-Type': 'application/x-www-form-urlencoded'\n  },\n  body: new URLSearchParams({\n    token: refreshToken,\n    token_type_hint: 'refresh_token'\n  })\n});", "example": "Revoke"},
    {"id": "oa216", "type": "oidc", "name": "OpenID Connect", "description": "OIDC extension", "pattern": "// OIDC adds identity layer to OAuth 2.0\n// Request 'openid' scope\nauthUrl.searchParams.set('scope', 'openid profile email');\n\n// Response includes id_token (JWT with user info)\nconst { access_token, id_token } = await response.json();\n\n// Decode id_token for user info\nconst userInfo = jwt.decode(id_token);", "example": "OIDC"},
    {"id": "oa217", "type": "discovery", "name": "OIDC Discovery", "description": "Provider config", "pattern": "// Fetch provider configuration\nconst config = await fetch(\n  'https://auth.example.com/.well-known/openid-configuration'\n).then(r => r.json());\n\n// Use discovered endpoints\nconst authEndpoint = config.authorization_endpoint;\nconst tokenEndpoint = config.token_endpoint;\nconst userinfoEndpoint = config.userinfo_endpoint;\nconst jwksUri = config.jwks_uri;", "example": "Discovery"},
    {"id": "oa218", "type": "userinfo", "name": "UserInfo Endpoint", "description": "Get user data", "pattern": "const userInfo = await fetch('https://auth.example.com/userinfo', {\n  headers: {\n    'Authorization': `Bearer ${accessToken}`\n  }\n}).then(r => r.json());\n\nconsole.log(userInfo);  // { sub, name, email, picture, ... }", "example": "UserInfo"},
    {"id": "oa219", "type": "callback", "name": "Callback Handler", "description": "Process redirect", "pattern": "app.get('/auth/callback', async (req, res) => {\n  const { code, state, error } = req.query;\n  \n  if (error) {\n    return res.redirect(`/login?error=${error}`);\n  }\n  \n  // Verify state\n  if (state !== req.session.oauthState) {\n    return res.status(400).send('Invalid state');\n  }\n  \n  // Exchange code\n  const tokens = await exchangeCode(code);\n  \n  // Store tokens and redirect\n  req.session.tokens = tokens;\n  res.redirect('/dashboard');\n});", "example": "Callback"},
    {"id": "oa220", "type": "spa", "name": "SPA Implementation", "description": "Frontend OAuth", "pattern": "// Use PKCE for SPAs (no client secret)\nclass OAuthClient {\n  async login() {\n    const verifier = this.generateVerifier();\n    const challenge = await this.generateChallenge(verifier);\n    sessionStorage.setItem('code_verifier', verifier);\n    \n    const authUrl = new URL(AUTH_ENDPOINT);\n    authUrl.searchParams.set('code_challenge', challenge);\n    authUrl.searchParams.set('code_challenge_method', 'S256');\n    // ... other params\n    \n    window.location.href = authUrl.toString();\n  }\n  \n  async handleCallback() {\n    const code = new URLSearchParams(location.search).get('code');\n    const verifier = sessionStorage.getItem('code_verifier');\n    return this.exchangeCode(code, verifier);\n  }\n}", "example": "SPA"},
    {"id": "oa221", "type": "bff", "name": "Backend-for-Frontend", "description": "BFF pattern", "pattern": "// Frontend calls BFF, BFF handles OAuth\n// More secure - tokens never exposed to frontend\n\napp.get('/api/auth/login', (req, res) => {\n  // Redirect to provider\n});\n\napp.get('/api/auth/callback', async (req, res) => {\n  // Exchange code, store tokens in session\n});\n\napp.get('/api/me', async (req, res) => {\n  // Use stored tokens to call API\n  const data = await fetchWithToken(req.session.accessToken);\n  res.json(data);\n});", "example": "BFF"},
    {"id": "oa222", "type": "store", "name": "Token Storage", "description": "Secure storage", "pattern": "// Server-side (most secure)\nreq.session.accessToken = token;\n\n// httpOnly cookie\nres.cookie('access_token', token, {\n  httpOnly: true,\n  secure: true,\n  sameSite: 'strict'\n});\n\n// SPA - memory only (cleared on refresh)\nlet accessToken = response.access_token;\n\n// Avoid localStorage for tokens!", "example": "Storage"},
    {"id": "oa223", "type": "refresh", "name": "Auto Refresh", "description": "Token rotation", "pattern": "async function fetchWithAuth(url, options = {}) {\n  let response = await fetch(url, {\n    ...options,\n    headers: { ...options.headers, Authorization: `Bearer ${accessToken}` }\n  });\n  \n  if (response.status === 401) {\n    await refreshAccessToken();\n    response = await fetch(url, {\n      ...options,\n      headers: { ...options.headers, Authorization: `Bearer ${accessToken}` }\n    });\n  }\n  \n  return response;\n}", "example": "Auto Refresh"},
    {"id": "oa224", "type": "error", "name": "Error Handling", "description": "OAuth errors", "pattern": "// Common OAuth errors\nswitch (error) {\n  case 'access_denied':\n    // User denied authorization\n    break;\n  case 'invalid_request':\n    // Missing required parameter\n    break;\n  case 'invalid_client':\n    // Client authentication failed\n    break;\n  case 'invalid_grant':\n    // Code expired or already used\n    break;\n  case 'unauthorized_client':\n    // Client not authorized for this grant type\n    break;\n}", "example": "Errors"},
    {"id": "oa225", "type": "logout", "name": "Logout", "description": "End session", "pattern": "async function logout() {\n  // Revoke tokens\n  await revokeToken(refreshToken);\n  \n  // Clear local storage\n  accessToken = null;\n  sessionStorage.clear();\n  \n  // OIDC end session\n  const logoutUrl = new URL('https://auth.example.com/logout');\n  logoutUrl.searchParams.set('id_token_hint', idToken);\n  logoutUrl.searchParams.set('post_logout_redirect_uri', window.location.origin);\n  \n  window.location.href = logoutUrl.toString();\n}", "example": "Logout"},
    {"id": "oa226", "type": "test", "name": "Testing OAuth", "description": "Mock providers", "pattern": "import nock from 'nock';\n\nbeforeEach(() => {\n  nock('https://auth.example.com')\n    .post('/token')\n    .reply(200, {\n      access_token: 'test-token',\n      expires_in: 3600\n    });\n});\n\ntest('exchanges code for token', async () => {\n  const result = await exchangeCode('test-code');\n  expect(result.access_token).toBe('test-token');\n});", "example": "Testing"},
    {"id": "oa227", "type": "security", "name": "Security Checklist", "description": "Best practices", "pattern": "// 1. Always use HTTPS\n// 2. Use PKCE for public clients\n// 3. Validate state parameter\n// 4. Validate redirect_uri on server\n// 5. Store tokens securely (httpOnly cookies)\n// 6. Use short-lived access tokens\n// 7. Rotate refresh tokens\n// 8. Validate token signatures\n// 9. Check token audience and issuer", "example": "Security"},
    {"id": "oa228", "type": "implicit", "name": "Implicit Flow (Legacy)", "description": "Deprecated flow", "pattern": "// NOT RECOMMENDED - Use PKCE instead\n// Tokens exposed in URL fragment\n// No refresh tokens\n// Vulnerable to token leakage\n\n// Only use if PKCE not supported\nauthUrl.searchParams.set('response_type', 'token');", "example": "Implicit"},
    {"id": "oa229", "type": "well-known", "name": "Well-Known URIs", "description": "Discovery URLs", "pattern": "// OAuth 2.0 Authorization Server Metadata\n/.well-known/oauth-authorization-server\n\n// OpenID Connect Discovery\n/.well-known/openid-configuration\n\n// JSON Web Key Set\n/.well-known/jwks.json", "example": "Well-Known"},
    {"id": "oa230", "type": "api", "name": "API Authorization", "description": "Protect APIs", "pattern": "// Middleware to verify access token\nfunction requireAuth(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  if (!token) return res.status(401).json({ error: 'No token' });\n  \n  // Verify with provider or locally (JWT)\n  const valid = await introspectToken(token);\n  if (!valid.active) return res.status(401).json({ error: 'Invalid token' });\n  \n  req.user = { sub: valid.sub, scope: valid.scope };\n  next();\n}", "example": "API Auth"}
  ]
}
