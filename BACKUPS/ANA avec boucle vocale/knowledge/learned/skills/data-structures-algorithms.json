{
  "category": "data-structures-algorithms",
  "version": "1.0.0",
  "generatedBy": "Claude Opus 4.5 - Module de référence pour Ana SUPERIA",
  "skills": [
    {"id": "dsa01", "type": "array", "name": "Array Operations", "description": "Common array manipulations", "pattern": "// Two pointers\nfunction twoSum(arr, target) {\n  let left = 0, right = arr.length - 1;\n  while (left < right) {\n    const sum = arr[left] + arr[right];\n    if (sum === target) return [left, right];\n    if (sum < target) left++;\n    else right--;\n  }\n  return null;\n}\n\n// Sliding window\nfunction maxSubarray(arr, k) {\n  let max = 0, windowSum = 0;\n  for (let i = 0; i < arr.length; i++) {\n    windowSum += arr[i];\n    if (i >= k - 1) {\n      max = Math.max(max, windowSum);\n      windowSum -= arr[i - k + 1];\n    }\n  }\n  return max;\n}", "example": "Two pointers O(n), sliding window O(n)"},
    {"id": "dsa02", "type": "linkedlist", "name": "Linked List", "description": "Linked list implementation and operations", "pattern": "class ListNode {\n  constructor(val, next = null) {\n    this.val = val;\n    this.next = next;\n  }\n}\n\nfunction reverseList(head) {\n  let prev = null, curr = head;\n  while (curr) {\n    const next = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = next;\n  }\n  return prev;\n}\n\nfunction hasCycle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) return true;\n  }\n  return false;\n}", "example": "Reverse O(n), cycle detection O(n)"},
    {"id": "dsa03", "type": "stack", "name": "Stack Operations", "description": "Stack-based algorithms", "pattern": "// Valid parentheses\nfunction isValid(s) {\n  const stack = [];\n  const pairs = { ')': '(', '}': '{', ']': '[' };\n  for (const c of s) {\n    if ('({['.includes(c)) stack.push(c);\n    else if (stack.pop() !== pairs[c]) return false;\n  }\n  return stack.length === 0;\n}\n\n// Monotonic stack - next greater element\nfunction nextGreater(arr) {\n  const result = new Array(arr.length).fill(-1);\n  const stack = [];\n  for (let i = 0; i < arr.length; i++) {\n    while (stack.length && arr[i] > arr[stack.at(-1)]) {\n      result[stack.pop()] = arr[i];\n    }\n    stack.push(i);\n  }\n  return result;\n}", "example": "Parentheses O(n), monotonic stack O(n)"},
    {"id": "dsa04", "type": "queue", "name": "Queue and Deque", "description": "Queue-based algorithms", "pattern": "// BFS with queue\nfunction bfs(graph, start) {\n  const visited = new Set([start]);\n  const queue = [start];\n  while (queue.length) {\n    const node = queue.shift();\n    for (const neighbor of graph[node]) {\n      if (!visited.has(neighbor)) {\n        visited.add(neighbor);\n        queue.push(neighbor);\n      }\n    }\n  }\n  return visited;\n}\n\n// Sliding window max with deque\nfunction maxSlidingWindow(nums, k) {\n  const result = [], deque = [];\n  for (let i = 0; i < nums.length; i++) {\n    while (deque.length && deque[0] <= i - k) deque.shift();\n    while (deque.length && nums[deque.at(-1)] < nums[i]) deque.pop();\n    deque.push(i);\n    if (i >= k - 1) result.push(nums[deque[0]]);\n  }\n  return result;\n}", "example": "BFS O(V+E), sliding window max O(n)"},
    {"id": "dsa05", "type": "hashtable", "name": "Hash Table Patterns", "description": "Hash-based problem solving", "pattern": "// Two sum with hash\nfunction twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) return [map.get(complement), i];\n    map.set(nums[i], i);\n  }\n  return null;\n}\n\n// Group anagrams\nfunction groupAnagrams(strs) {\n  const map = new Map();\n  for (const s of strs) {\n    const key = [...s].sort().join('');\n    if (!map.has(key)) map.set(key, []);\n    map.get(key).push(s);\n  }\n  return [...map.values()];\n}", "example": "Hash lookup O(1), grouping O(n*k)"},
    {"id": "dsa06", "type": "tree", "name": "Binary Tree Traversals", "description": "Tree traversal algorithms", "pattern": "// Recursive traversals\nfunction inorder(root, result = []) {\n  if (root) {\n    inorder(root.left, result);\n    result.push(root.val);\n    inorder(root.right, result);\n  }\n  return result;\n}\n\n// Iterative inorder\nfunction inorderIterative(root) {\n  const result = [], stack = [];\n  let curr = root;\n  while (curr || stack.length) {\n    while (curr) { stack.push(curr); curr = curr.left; }\n    curr = stack.pop();\n    result.push(curr.val);\n    curr = curr.right;\n  }\n  return result;\n}\n\n// Level order (BFS)\nfunction levelOrder(root) {\n  if (!root) return [];\n  const result = [], queue = [root];\n  while (queue.length) {\n    const level = [];\n    for (let i = queue.length; i > 0; i--) {\n      const node = queue.shift();\n      level.push(node.val);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    result.push(level);\n  }\n  return result;\n}", "example": "Inorder, preorder, postorder, level order"},
    {"id": "dsa07", "type": "bst", "name": "Binary Search Tree", "description": "BST operations", "pattern": "class BST {\n  insert(root, val) {\n    if (!root) return new TreeNode(val);\n    if (val < root.val) root.left = this.insert(root.left, val);\n    else root.right = this.insert(root.right, val);\n    return root;\n  }\n  \n  search(root, val) {\n    if (!root || root.val === val) return root;\n    return val < root.val ? this.search(root.left, val) : this.search(root.right, val);\n  }\n  \n  delete(root, val) {\n    if (!root) return null;\n    if (val < root.val) root.left = this.delete(root.left, val);\n    else if (val > root.val) root.right = this.delete(root.right, val);\n    else {\n      if (!root.left) return root.right;\n      if (!root.right) return root.left;\n      let min = root.right;\n      while (min.left) min = min.left;\n      root.val = min.val;\n      root.right = this.delete(root.right, min.val);\n    }\n    return root;\n  }\n}", "example": "Insert/search/delete O(log n) average"},
    {"id": "dsa08", "type": "heap", "name": "Heap/Priority Queue", "description": "Heap-based algorithms", "pattern": "class MinHeap {\n  constructor() { this.heap = []; }\n  \n  push(val) {\n    this.heap.push(val);\n    this.bubbleUp(this.heap.length - 1);\n  }\n  \n  pop() {\n    const min = this.heap[0];\n    const last = this.heap.pop();\n    if (this.heap.length) {\n      this.heap[0] = last;\n      this.bubbleDown(0);\n    }\n    return min;\n  }\n  \n  bubbleUp(i) {\n    while (i > 0) {\n      const parent = Math.floor((i - 1) / 2);\n      if (this.heap[parent] <= this.heap[i]) break;\n      [this.heap[parent], this.heap[i]] = [this.heap[i], this.heap[parent]];\n      i = parent;\n    }\n  }\n  \n  bubbleDown(i) {\n    while (true) {\n      let smallest = i;\n      const left = 2 * i + 1, right = 2 * i + 2;\n      if (left < this.heap.length && this.heap[left] < this.heap[smallest]) smallest = left;\n      if (right < this.heap.length && this.heap[right] < this.heap[smallest]) smallest = right;\n      if (smallest === i) break;\n      [this.heap[i], this.heap[smallest]] = [this.heap[smallest], this.heap[i]];\n      i = smallest;\n    }\n  }\n}", "example": "Push/pop O(log n), peek O(1)"},
    {"id": "dsa09", "type": "graph", "name": "Graph Algorithms", "description": "Graph traversal and shortest path", "pattern": "// DFS\nfunction dfs(graph, start, visited = new Set()) {\n  visited.add(start);\n  for (const neighbor of graph[start] || []) {\n    if (!visited.has(neighbor)) dfs(graph, neighbor, visited);\n  }\n  return visited;\n}\n\n// Dijkstra\nfunction dijkstra(graph, start) {\n  const dist = { [start]: 0 };\n  const pq = [[0, start]]; // [distance, node]\n  while (pq.length) {\n    pq.sort((a, b) => a[0] - b[0]);\n    const [d, u] = pq.shift();\n    if (d > (dist[u] ?? Infinity)) continue;\n    for (const [v, w] of graph[u] || []) {\n      const newDist = d + w;\n      if (newDist < (dist[v] ?? Infinity)) {\n        dist[v] = newDist;\n        pq.push([newDist, v]);\n      }\n    }\n  }\n  return dist;\n}", "example": "DFS O(V+E), Dijkstra O((V+E)logV)"},
    {"id": "dsa10", "type": "graph", "name": "Topological Sort", "description": "DAG ordering algorithms", "pattern": "// Kahn's algorithm (BFS)\nfunction topologicalSort(numNodes, edges) {\n  const graph = Array.from({ length: numNodes }, () => []);\n  const inDegree = new Array(numNodes).fill(0);\n  \n  for (const [from, to] of edges) {\n    graph[from].push(to);\n    inDegree[to]++;\n  }\n  \n  const queue = [];\n  for (let i = 0; i < numNodes; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n  \n  const result = [];\n  while (queue.length) {\n    const node = queue.shift();\n    result.push(node);\n    for (const neighbor of graph[node]) {\n      if (--inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n  \n  return result.length === numNodes ? result : []; // Empty if cycle\n}", "example": "Course scheduling, build order O(V+E)"},
    {"id": "dsa11", "type": "dp", "name": "Dynamic Programming 1D", "description": "Linear DP patterns", "pattern": "// Fibonacci\nfunction fib(n) {\n  if (n <= 1) return n;\n  let prev = 0, curr = 1;\n  for (let i = 2; i <= n; i++) {\n    [prev, curr] = [curr, prev + curr];\n  }\n  return curr;\n}\n\n// Climbing stairs\nfunction climbStairs(n) {\n  let dp = [1, 1];\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i-1] + dp[i-2];\n  }\n  return dp[n];\n}\n\n// House robber\nfunction rob(nums) {\n  let prev = 0, curr = 0;\n  for (const num of nums) {\n    [prev, curr] = [curr, Math.max(curr, prev + num)];\n  }\n  return curr;\n}", "example": "Optimal substructure, memoization"},
    {"id": "dsa12", "type": "dp", "name": "Dynamic Programming 2D", "description": "Grid and string DP", "pattern": "// Longest Common Subsequence\nfunction lcs(s1, s2) {\n  const m = s1.length, n = s2.length;\n  const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (s1[i-1] === s2[j-1]) dp[i][j] = dp[i-1][j-1] + 1;\n      else dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n    }\n  }\n  return dp[m][n];\n}\n\n// Edit distance\nfunction editDistance(s1, s2) {\n  const m = s1.length, n = s2.length;\n  const dp = Array.from({ length: m + 1 }, (_, i) => \n    Array.from({ length: n + 1 }, (_, j) => i === 0 ? j : j === 0 ? i : 0)\n  );\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (s1[i-1] === s2[j-1]) dp[i][j] = dp[i-1][j-1];\n      else dp[i][j] = 1 + Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]);\n    }\n  }\n  return dp[m][n];\n}", "example": "LCS O(mn), edit distance O(mn)"},
    {"id": "dsa13", "type": "backtracking", "name": "Backtracking", "description": "Exhaustive search with pruning", "pattern": "// Permutations\nfunction permute(nums) {\n  const result = [];\n  function backtrack(path, used) {\n    if (path.length === nums.length) {\n      result.push([...path]);\n      return;\n    }\n    for (let i = 0; i < nums.length; i++) {\n      if (used[i]) continue;\n      path.push(nums[i]);\n      used[i] = true;\n      backtrack(path, used);\n      path.pop();\n      used[i] = false;\n    }\n  }\n  backtrack([], new Array(nums.length).fill(false));\n  return result;\n}\n\n// Subsets\nfunction subsets(nums) {\n  const result = [];\n  function backtrack(start, path) {\n    result.push([...path]);\n    for (let i = start; i < nums.length; i++) {\n      path.push(nums[i]);\n      backtrack(i + 1, path);\n      path.pop();\n    }\n  }\n  backtrack(0, []);\n  return result;\n}", "example": "Permutations O(n!), subsets O(2^n)"},
    {"id": "dsa14", "type": "sorting", "name": "Sorting Algorithms", "description": "Common sorting implementations", "pattern": "// Quick sort\nfunction quickSort(arr, lo = 0, hi = arr.length - 1) {\n  if (lo < hi) {\n    const pivot = partition(arr, lo, hi);\n    quickSort(arr, lo, pivot - 1);\n    quickSort(arr, pivot + 1, hi);\n  }\n  return arr;\n}\n\nfunction partition(arr, lo, hi) {\n  const pivot = arr[hi];\n  let i = lo - 1;\n  for (let j = lo; j < hi; j++) {\n    if (arr[j] < pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n  [arr[i + 1], arr[hi]] = [arr[hi], arr[i + 1]];\n  return i + 1;\n}\n\n// Merge sort\nfunction mergeSort(arr) {\n  if (arr.length <= 1) return arr;\n  const mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n  return merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  while (left.length && right.length) {\n    result.push(left[0] < right[0] ? left.shift() : right.shift());\n  }\n  return [...result, ...left, ...right];\n}", "example": "QuickSort O(nlogn) avg, MergeSort O(nlogn)"},
    {"id": "dsa15", "type": "search", "name": "Binary Search", "description": "Binary search variations", "pattern": "// Standard binary search\nfunction binarySearch(arr, target) {\n  let lo = 0, hi = arr.length - 1;\n  while (lo <= hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (arr[mid] === target) return mid;\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return -1;\n}\n\n// Lower bound (first >= target)\nfunction lowerBound(arr, target) {\n  let lo = 0, hi = arr.length;\n  while (lo < hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (arr[mid] < target) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n\n// Search in rotated sorted array\nfunction searchRotated(nums, target) {\n  let lo = 0, hi = nums.length - 1;\n  while (lo <= hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (nums[mid] === target) return mid;\n    if (nums[lo] <= nums[mid]) {\n      if (nums[lo] <= target && target < nums[mid]) hi = mid - 1;\n      else lo = mid + 1;\n    } else {\n      if (nums[mid] < target && target <= nums[hi]) lo = mid + 1;\n      else hi = mid - 1;\n    }\n  }\n  return -1;\n}", "example": "Binary search O(log n)"},
    {"id": "dsa16", "type": "trie", "name": "Trie Data Structure", "description": "Prefix tree for strings", "pattern": "class TrieNode {\n  constructor() {\n    this.children = {};\n    this.isEnd = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode();\n  }\n  \n  insert(word) {\n    let node = this.root;\n    for (const c of word) {\n      if (!node.children[c]) node.children[c] = new TrieNode();\n      node = node.children[c];\n    }\n    node.isEnd = true;\n  }\n  \n  search(word) {\n    const node = this.traverse(word);\n    return node !== null && node.isEnd;\n  }\n  \n  startsWith(prefix) {\n    return this.traverse(prefix) !== null;\n  }\n  \n  traverse(str) {\n    let node = this.root;\n    for (const c of str) {\n      if (!node.children[c]) return null;\n      node = node.children[c];\n    }\n    return node;\n  }\n}", "example": "Insert/search O(m), autocomplete"},
    {"id": "dsa17", "type": "unionfind", "name": "Union Find", "description": "Disjoint set data structure", "pattern": "class UnionFind {\n  constructor(n) {\n    this.parent = Array.from({ length: n }, (_, i) => i);\n    this.rank = new Array(n).fill(0);\n  }\n  \n  find(x) {\n    if (this.parent[x] !== x) {\n      this.parent[x] = this.find(this.parent[x]); // Path compression\n    }\n    return this.parent[x];\n  }\n  \n  union(x, y) {\n    const px = this.find(x), py = this.find(y);\n    if (px === py) return false;\n    // Union by rank\n    if (this.rank[px] < this.rank[py]) this.parent[px] = py;\n    else if (this.rank[px] > this.rank[py]) this.parent[py] = px;\n    else { this.parent[py] = px; this.rank[px]++; }\n    return true;\n  }\n  \n  connected(x, y) {\n    return this.find(x) === this.find(y);\n  }\n}", "example": "Find/union nearly O(1) amortized"},
    {"id": "dsa18", "type": "interval", "name": "Interval Problems", "description": "Merge and schedule intervals", "pattern": "// Merge intervals\nfunction mergeIntervals(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n  const result = [intervals[0]];\n  for (let i = 1; i < intervals.length; i++) {\n    const last = result.at(-1);\n    if (intervals[i][0] <= last[1]) {\n      last[1] = Math.max(last[1], intervals[i][1]);\n    } else {\n      result.push(intervals[i]);\n    }\n  }\n  return result;\n}\n\n// Meeting rooms II - min rooms needed\nfunction minMeetingRooms(intervals) {\n  const starts = intervals.map(i => i[0]).sort((a, b) => a - b);\n  const ends = intervals.map(i => i[1]).sort((a, b) => a - b);\n  let rooms = 0, maxRooms = 0, e = 0;\n  for (const start of starts) {\n    if (start < ends[e]) rooms++;\n    else e++;\n    maxRooms = Math.max(maxRooms, rooms);\n  }\n  return maxRooms;\n}", "example": "Merge O(nlogn), meeting rooms O(nlogn)"},
    {"id": "dsa19", "type": "bit", "name": "Bit Manipulation", "description": "Bitwise operations", "pattern": "// Count set bits\nfunction countBits(n) {\n  let count = 0;\n  while (n) {\n    count += n & 1;\n    n >>= 1;\n  }\n  return count;\n}\n\n// Single number (XOR)\nfunction singleNumber(nums) {\n  return nums.reduce((a, b) => a ^ b, 0);\n}\n\n// Power of 2\nfunction isPowerOfTwo(n) {\n  return n > 0 && (n & (n - 1)) === 0;\n}\n\n// Get/set/clear bit\nconst getBit = (n, i) => (n >> i) & 1;\nconst setBit = (n, i) => n | (1 << i);\nconst clearBit = (n, i) => n & ~(1 << i);", "example": "Bit tricks O(1) or O(log n)"},
    {"id": "dsa20", "type": "string", "name": "String Algorithms", "description": "String matching and manipulation", "pattern": "// KMP pattern matching\nfunction kmp(text, pattern) {\n  const lps = buildLPS(pattern);\n  const result = [];\n  let i = 0, j = 0;\n  while (i < text.length) {\n    if (text[i] === pattern[j]) { i++; j++; }\n    if (j === pattern.length) {\n      result.push(i - j);\n      j = lps[j - 1];\n    } else if (i < text.length && text[i] !== pattern[j]) {\n      j > 0 ? j = lps[j - 1] : i++;\n    }\n  }\n  return result;\n}\n\nfunction buildLPS(pattern) {\n  const lps = [0];\n  let len = 0, i = 1;\n  while (i < pattern.length) {\n    if (pattern[i] === pattern[len]) lps[i++] = ++len;\n    else if (len > 0) len = lps[len - 1];\n    else lps[i++] = 0;\n  }\n  return lps;\n}\n\n// Longest palindromic substring\nfunction longestPalindrome(s) {\n  let start = 0, maxLen = 1;\n  function expand(l, r) {\n    while (l >= 0 && r < s.length && s[l] === s[r]) { l--; r++; }\n    if (r - l - 1 > maxLen) { start = l + 1; maxLen = r - l - 1; }\n  }\n  for (let i = 0; i < s.length; i++) {\n    expand(i, i);     // Odd length\n    expand(i, i + 1); // Even length\n  }\n  return s.slice(start, start + maxLen);\n}", "example": "KMP O(n+m), palindrome O(n^2)"},
    {"id": "dsa21", "type": "greedy", "name": "Greedy Algorithms", "description": "Locally optimal choices", "pattern": "// Activity selection\nfunction activitySelection(activities) {\n  activities.sort((a, b) => a.end - b.end);\n  const result = [activities[0]];\n  for (let i = 1; i < activities.length; i++) {\n    if (activities[i].start >= result.at(-1).end) {\n      result.push(activities[i]);\n    }\n  }\n  return result;\n}\n\n// Jump game\nfunction canJump(nums) {\n  let maxReach = 0;\n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;\n    maxReach = Math.max(maxReach, i + nums[i]);\n  }\n  return true;\n}\n\n// Gas station\nfunction canCompleteCircuit(gas, cost) {\n  let total = 0, tank = 0, start = 0;\n  for (let i = 0; i < gas.length; i++) {\n    const diff = gas[i] - cost[i];\n    total += diff;\n    tank += diff;\n    if (tank < 0) { start = i + 1; tank = 0; }\n  }\n  return total >= 0 ? start : -1;\n}", "example": "Activity selection O(nlogn)"},
    {"id": "dsa22", "type": "matrix", "name": "Matrix Algorithms", "description": "2D grid operations", "pattern": "// Rotate matrix 90 degrees\nfunction rotate(matrix) {\n  const n = matrix.length;\n  // Transpose\n  for (let i = 0; i < n; i++) {\n    for (let j = i; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  // Reverse each row\n  for (const row of matrix) row.reverse();\n}\n\n// Spiral order\nfunction spiralOrder(matrix) {\n  const result = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  while (top <= bottom && left <= right) {\n    for (let i = left; i <= right; i++) result.push(matrix[top][i]);\n    top++;\n    for (let i = top; i <= bottom; i++) result.push(matrix[i][right]);\n    right--;\n    if (top <= bottom) {\n      for (let i = right; i >= left; i--) result.push(matrix[bottom][i]);\n      bottom--;\n    }\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) result.push(matrix[i][left]);\n      left++;\n    }\n  }\n  return result;\n}", "example": "Rotate O(n^2), spiral O(mn)"},
    {"id": "dsa23", "type": "advanced", "name": "Segment Tree", "description": "Range query data structure", "pattern": "class SegmentTree {\n  constructor(arr) {\n    this.n = arr.length;\n    this.tree = new Array(4 * this.n).fill(0);\n    this.build(arr, 0, 0, this.n - 1);\n  }\n  \n  build(arr, node, start, end) {\n    if (start === end) {\n      this.tree[node] = arr[start];\n    } else {\n      const mid = Math.floor((start + end) / 2);\n      this.build(arr, 2 * node + 1, start, mid);\n      this.build(arr, 2 * node + 2, mid + 1, end);\n      this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n    }\n  }\n  \n  query(node, start, end, l, r) {\n    if (r < start || l > end) return 0;\n    if (l <= start && end <= r) return this.tree[node];\n    const mid = Math.floor((start + end) / 2);\n    return this.query(2 * node + 1, start, mid, l, r) +\n           this.query(2 * node + 2, mid + 1, end, l, r);\n  }\n  \n  update(node, start, end, idx, val) {\n    if (start === end) {\n      this.tree[node] = val;\n    } else {\n      const mid = Math.floor((start + end) / 2);\n      if (idx <= mid) this.update(2 * node + 1, start, mid, idx, val);\n      else this.update(2 * node + 2, mid + 1, end, idx, val);\n      this.tree[node] = this.tree[2 * node + 1] + this.tree[2 * node + 2];\n    }\n  }\n}", "example": "Range sum query O(log n)"},
    {"id": "dsa24", "type": "advanced", "name": "LRU Cache", "description": "Least Recently Used cache", "pattern": "class LRUCache {\n  constructor(capacity) {\n    this.capacity = capacity;\n    this.cache = new Map();\n  }\n  \n  get(key) {\n    if (!this.cache.has(key)) return -1;\n    const value = this.cache.get(key);\n    // Move to end (most recent)\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    return value;\n  }\n  \n  put(key, value) {\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Remove oldest (first key)\n      this.cache.delete(this.cache.keys().next().value);\n    }\n    this.cache.set(key, value);\n  }\n}", "example": "Get/put O(1) with Map"},
    {"id": "dsa25", "type": "advanced", "name": "Bloom Filter", "description": "Probabilistic set membership", "pattern": "class BloomFilter {\n  constructor(size = 1000, numHashes = 3) {\n    this.size = size;\n    this.numHashes = numHashes;\n    this.bits = new Array(size).fill(false);\n  }\n  \n  hash(str, seed) {\n    let h = seed;\n    for (const c of str) {\n      h = (h * 31 + c.charCodeAt(0)) % this.size;\n    }\n    return h;\n  }\n  \n  add(item) {\n    for (let i = 0; i < this.numHashes; i++) {\n      const idx = this.hash(item, i + 1);\n      this.bits[idx] = true;\n    }\n  }\n  \n  mightContain(item) {\n    for (let i = 0; i < this.numHashes; i++) {\n      const idx = this.hash(item, i + 1);\n      if (!this.bits[idx]) return false;\n    }\n    return true; // Might be false positive\n  }\n}", "example": "Space-efficient membership test"},
    {"id": "dsa26", "type": "complexity", "name": "Time Complexity Analysis", "description": "Big O notation guide", "pattern": "// O(1) - Constant\nconst getFirst = arr => arr[0];\n\n// O(log n) - Logarithmic\nconst binarySearch = (arr, target) => { /* ... */ };\n\n// O(n) - Linear\nconst findMax = arr => Math.max(...arr);\n\n// O(n log n) - Linearithmic\nconst mergeSort = arr => { /* ... */ };\n\n// O(n^2) - Quadratic\nconst bubbleSort = arr => { /* ... */ };\n\n// O(2^n) - Exponential\nconst allSubsets = arr => { /* ... */ };\n\n// O(n!) - Factorial\nconst allPermutations = arr => { /* ... */ };\n\n// Common operations:\n// Array access: O(1)\n// Array search: O(n), O(log n) if sorted\n// Hash table: O(1) average\n// BST: O(log n) average\n// Heap: O(log n) insert/delete", "example": "Know your complexity!"},
    {"id": "dsa27", "type": "pattern", "name": "Fast and Slow Pointers", "description": "Tortoise and hare technique", "pattern": "// Find middle of linked list\nfunction findMiddle(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n  }\n  return slow;\n}\n\n// Detect cycle start\nfunction detectCycleStart(head) {\n  let slow = head, fast = head;\n  while (fast && fast.next) {\n    slow = slow.next;\n    fast = fast.next.next;\n    if (slow === fast) break;\n  }\n  if (!fast || !fast.next) return null;\n  slow = head;\n  while (slow !== fast) {\n    slow = slow.next;\n    fast = fast.next;\n  }\n  return slow;\n}", "example": "Middle O(n/2), cycle O(n)"},
    {"id": "dsa28", "type": "pattern", "name": "Prefix Sum", "description": "Cumulative sum for range queries", "pattern": "// Build prefix sum\nfunction buildPrefixSum(arr) {\n  const prefix = [0];\n  for (const num of arr) {\n    prefix.push(prefix.at(-1) + num);\n  }\n  return prefix;\n}\n\n// Range sum query\nfunction rangeSum(prefix, l, r) {\n  return prefix[r + 1] - prefix[l];\n}\n\n// Subarray sum equals k\nfunction subarraySum(nums, k) {\n  const prefixCount = new Map([[0, 1]]);\n  let sum = 0, count = 0;\n  for (const num of nums) {\n    sum += num;\n    count += prefixCount.get(sum - k) || 0;\n    prefixCount.set(sum, (prefixCount.get(sum) || 0) + 1);\n  }\n  return count;\n}", "example": "Build O(n), query O(1)"},
    {"id": "dsa29", "type": "pattern", "name": "Modified Binary Search", "description": "Binary search variations", "pattern": "// Find peak element\nfunction findPeak(nums) {\n  let lo = 0, hi = nums.length - 1;\n  while (lo < hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    if (nums[mid] < nums[mid + 1]) lo = mid + 1;\n    else hi = mid;\n  }\n  return lo;\n}\n\n// Search in 2D matrix\nfunction searchMatrix(matrix, target) {\n  const m = matrix.length, n = matrix[0].length;\n  let lo = 0, hi = m * n - 1;\n  while (lo <= hi) {\n    const mid = Math.floor((lo + hi) / 2);\n    const val = matrix[Math.floor(mid / n)][mid % n];\n    if (val === target) return true;\n    if (val < target) lo = mid + 1;\n    else hi = mid - 1;\n  }\n  return false;\n}", "example": "Adapt binary search to problem"},
    {"id": "dsa30", "type": "pattern", "name": "Top K Elements", "description": "Find k largest/smallest elements", "pattern": "// Using heap (for streaming data)\nfunction topKFrequent(nums, k) {\n  const freq = new Map();\n  for (const n of nums) freq.set(n, (freq.get(n) || 0) + 1);\n  \n  // Min heap of size k\n  const heap = [];\n  for (const [num, count] of freq) {\n    heap.push([count, num]);\n    heap.sort((a, b) => a[0] - b[0]);\n    if (heap.length > k) heap.shift();\n  }\n  return heap.map(x => x[1]);\n}\n\n// Using quickselect for kth largest\nfunction findKthLargest(nums, k) {\n  k = nums.length - k;\n  function quickSelect(lo, hi) {\n    const pivot = nums[hi];\n    let p = lo;\n    for (let i = lo; i < hi; i++) {\n      if (nums[i] <= pivot) [nums[p++], nums[i]] = [nums[i], nums[p]];\n    }\n    [nums[p], nums[hi]] = [nums[hi], nums[p]];\n    if (p === k) return nums[p];\n    return p < k ? quickSelect(p + 1, hi) : quickSelect(lo, p - 1);\n  }\n  return quickSelect(0, nums.length - 1);\n}", "example": "Heap O(nlogk), quickselect O(n) avg"}
  ]
}
