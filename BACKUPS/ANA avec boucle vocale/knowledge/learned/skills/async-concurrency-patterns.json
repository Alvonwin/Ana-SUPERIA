{
  "category": "async-concurrency-patterns",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Asynchronous programming and concurrency patterns",
  "skills": [
    {"id": "asy01", "type": "promise", "name": "Promise Creation", "description": "Create promise", "pattern": "new Promise((resolve, reject) => { })", "example": "Wrap async operation"},
    {"id": "asy02", "type": "promise", "name": "Promise.resolve", "description": "Immediate resolve", "pattern": "Promise.resolve(value)", "example": "Wrap sync value"},
    {"id": "asy03", "type": "promise", "name": "Promise.reject", "description": "Immediate reject", "pattern": "Promise.reject(error)", "example": "Create failed promise"},
    {"id": "asy04", "type": "promise", "name": "Promise.all", "description": "Parallel execution", "pattern": "Promise.all([p1, p2, p3])", "example": "All must succeed"},
    {"id": "asy05", "type": "promise", "name": "Promise.allSettled", "description": "All outcomes", "pattern": "Promise.allSettled([p1, p2])", "example": "Get all results"},
    {"id": "asy06", "type": "promise", "name": "Promise.race", "description": "First to complete", "pattern": "Promise.race([p1, timeout])", "example": "Timeout pattern"},
    {"id": "asy07", "type": "promise", "name": "Promise.any", "description": "First success", "pattern": "Promise.any([p1, p2])", "example": "At least one succeeds"},
    {"id": "asy08", "type": "async", "name": "Async Function", "description": "Async declaration", "pattern": "async function fn() { return value }", "example": "Returns promise"},
    {"id": "asy09", "type": "async", "name": "Await Expression", "description": "Wait for promise", "pattern": "const result = await promise", "example": "Pause until resolved"},
    {"id": "asy10", "type": "async", "name": "Parallel Await", "description": "Concurrent async calls", "pattern": "const [a, b] = await Promise.all([fn1(), fn2()])", "example": "Don't await sequentially"},
    {"id": "asy11", "type": "async", "name": "Sequential Await", "description": "Order-dependent calls", "pattern": "const a = await fn1(); const b = await fn2(a)", "example": "When needed"},
    {"id": "asy12", "type": "async", "name": "Top-Level Await", "description": "Module-level await", "pattern": "const data = await fetch(url) // in ESM", "example": "ES modules only"},
    {"id": "asy13", "type": "pattern", "name": "Async Queue", "description": "Rate-limited execution", "pattern": "Process items with concurrency limit", "example": "p-queue package"},
    {"id": "asy14", "type": "pattern", "name": "Semaphore", "description": "Limit concurrent access", "pattern": "Max N concurrent operations", "example": "Database connections"},
    {"id": "asy15", "type": "pattern", "name": "Mutex", "description": "Exclusive access", "pattern": "Only one at a time", "example": "async-mutex package"},
    {"id": "asy16", "type": "pattern", "name": "Debounce", "description": "Delay until settled", "pattern": "Wait until no new calls for N ms", "example": "Search input"},
    {"id": "asy17", "type": "pattern", "name": "Throttle", "description": "Rate limit calls", "pattern": "Max one call per N ms", "example": "Scroll handlers"},
    {"id": "asy18", "type": "pattern", "name": "Batch Processing", "description": "Group operations", "pattern": "Collect items, process together", "example": "Bulk API calls"},
    {"id": "asy19", "type": "iterator", "name": "Async Iterator", "description": "Async for-of", "pattern": "for await (const item of asyncIterable) { }", "example": "Stream processing"},
    {"id": "asy20", "type": "iterator", "name": "Async Generator", "description": "Yield async values", "pattern": "async function* gen() { yield await fn() }", "example": "Lazy async sequence"},
    {"id": "asy21", "type": "callback", "name": "Callback to Promise", "description": "Promisify callbacks", "pattern": "util.promisify(callbackFn)", "example": "Node.js util"},
    {"id": "asy22", "type": "event", "name": "Event Emitter", "description": "Pub/sub pattern", "pattern": "emitter.on('event', handler); emitter.emit('event', data)", "example": "Node EventEmitter"},
    {"id": "asy23", "type": "event", "name": "Once Event", "description": "Single event listener", "pattern": "events.once(emitter, 'event')", "example": "Returns promise"},
    {"id": "asy24", "type": "cancel", "name": "AbortController", "description": "Cancel async operation", "pattern": "const ctrl = new AbortController(); fetch(url, { signal: ctrl.signal })", "example": "ctrl.abort()"},
    {"id": "asy25", "type": "cancel", "name": "Timeout Promise", "description": "Time-limited operation", "pattern": "Promise.race([operation, timeout])", "example": "Abort after N ms"},
    {"id": "asy26", "type": "worker", "name": "Web Workers", "description": "Background threads", "pattern": "new Worker('worker.js')", "example": "Parallel processing"},
    {"id": "asy27", "type": "worker", "name": "Worker Threads (Node)", "description": "Node.js threads", "pattern": "const { Worker } = require('worker_threads')", "example": "CPU-intensive tasks"},
    {"id": "asy28", "type": "stream", "name": "Node Streams", "description": "Data streaming", "pattern": "readable.pipe(transform).pipe(writable)", "example": "Memory efficient"},
    {"id": "asy29", "type": "stream", "name": "Async Stream Processing", "description": "Process stream async", "pattern": "for await (const chunk of stream) { }", "example": "Backpressure handled"},
    {"id": "asy30", "type": "rxjs", "name": "RxJS Observables", "description": "Reactive streams", "pattern": "observable.pipe(map, filter, debounceTime)", "example": "Complex async flows"}
  ]
}
