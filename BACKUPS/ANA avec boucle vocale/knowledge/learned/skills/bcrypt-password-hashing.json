{
  "category": "bcrypt-password-hashing",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "bcrypt password hashing patterns",
  "skills": [
    {"id": "bcp01", "type": "setup", "name": "Install bcrypt", "description": "NPM install", "pattern": "npm install bcrypt\nnpm install @types/bcrypt --save-dev\n\n// Or bcryptjs (pure JS, no native deps)\nnpm install bcryptjs", "example": "Install"},
    {"id": "bcp02", "type": "hash", "name": "Hash Password", "description": "Create hash", "pattern": "import bcrypt from 'bcrypt';\n\nconst saltRounds = 10;\nconst password = 'user-password';\n\n// Async (recommended)\nconst hash = await bcrypt.hash(password, saltRounds);\n\n// Sync\nconst hashSync = bcrypt.hashSync(password, saltRounds);", "example": "Hash"},
    {"id": "bcp03", "type": "compare", "name": "Compare Password", "description": "Verify password", "pattern": "const isMatch = await bcrypt.compare(password, storedHash);\n\nif (isMatch) {\n  console.log('Password correct');\n} else {\n  console.log('Password incorrect');\n}", "example": "Compare"},
    {"id": "bcp04", "type": "salt", "name": "Generate Salt", "description": "Manual salt", "pattern": "// Auto-generate with hash\nconst hash = await bcrypt.hash(password, 10);\n\n// Manual salt generation\nconst salt = await bcrypt.genSalt(12);\nconst hash = await bcrypt.hash(password, salt);", "example": "Salt"},
    {"id": "bcp05", "type": "rounds", "name": "Salt Rounds", "description": "Cost factor", "pattern": "// Salt rounds = cost factor (2^n iterations)\n// Higher = more secure but slower\n\nconst saltRounds = 10;  // ~100ms (recommended minimum)\nconst saltRounds = 12;  // ~300ms\nconst saltRounds = 14;  // ~1 second\n\n// Test your hardware\nconst start = Date.now();\nawait bcrypt.hash('test', 12);\nconsole.log(`Time: ${Date.now() - start}ms`);", "example": "Rounds"},
    {"id": "bcp06", "type": "signup", "name": "User Registration", "description": "Sign up flow", "pattern": "async function registerUser(email, password) {\n  // Validate password strength\n  if (password.length < 8) {\n    throw new Error('Password too short');\n  }\n  \n  // Hash password\n  const hashedPassword = await bcrypt.hash(password, 10);\n  \n  // Store user\n  const user = await db.user.create({\n    data: {\n      email,\n      password: hashedPassword\n    }\n  });\n  \n  return user;\n}", "example": "Signup"},
    {"id": "bcp07", "type": "login", "name": "User Login", "description": "Authentication", "pattern": "async function login(email, password) {\n  const user = await db.user.findUnique({ where: { email } });\n  \n  if (!user) {\n    throw new Error('User not found');\n  }\n  \n  const isValid = await bcrypt.compare(password, user.password);\n  \n  if (!isValid) {\n    throw new Error('Invalid password');\n  }\n  \n  return user;\n}", "example": "Login"},
    {"id": "bcp08", "type": "change", "name": "Change Password", "description": "Update password", "pattern": "async function changePassword(userId, currentPassword, newPassword) {\n  const user = await db.user.findUnique({ where: { id: userId } });\n  \n  // Verify current password\n  const isValid = await bcrypt.compare(currentPassword, user.password);\n  if (!isValid) {\n    throw new Error('Current password incorrect');\n  }\n  \n  // Hash new password\n  const hashedPassword = await bcrypt.hash(newPassword, 10);\n  \n  // Update\n  await db.user.update({\n    where: { id: userId },\n    data: { password: hashedPassword }\n  });\n}", "example": "Change"},
    {"id": "bcp09", "type": "rehash", "name": "Rehash Check", "description": "Upgrade hashes", "pattern": "async function loginAndRehash(email, password) {\n  const user = await db.user.findUnique({ where: { email } });\n  const isValid = await bcrypt.compare(password, user.password);\n  \n  if (!isValid) throw new Error('Invalid password');\n  \n  // Check if hash needs upgrade\n  const rounds = bcrypt.getRounds(user.password);\n  if (rounds < 12) {\n    const newHash = await bcrypt.hash(password, 12);\n    await db.user.update({\n      where: { id: user.id },\n      data: { password: newHash }\n    });\n  }\n  \n  return user;\n}", "example": "Rehash"},
    {"id": "bcp10", "type": "extract", "name": "Extract Info", "description": "Get hash details", "pattern": "const hash = '$2b$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy';\n\n// Get rounds from hash\nconst rounds = bcrypt.getRounds(hash);  // 10\n\n// Hash format: $2b$10$...\n// $2b$ = algorithm version\n// 10$ = cost factor\n// Next 22 chars = salt\n// Rest = hash", "example": "Extract"},
    {"id": "bcp11", "type": "timing", "name": "Timing Attack Prevention", "description": "Constant time", "pattern": "// bcrypt.compare is already timing-safe\n// DON'T do this:\nif (hash === storedHash) { }  // Vulnerable!\n\n// DO this:\nconst isMatch = await bcrypt.compare(password, storedHash);", "example": "Timing"},
    {"id": "bcp12", "type": "express", "name": "Express Middleware", "description": "Auth middleware", "pattern": "import bcrypt from 'bcrypt';\n\napp.post('/register', async (req, res) => {\n  const { email, password } = req.body;\n  const hash = await bcrypt.hash(password, 10);\n  await createUser(email, hash);\n  res.json({ success: true });\n});\n\napp.post('/login', async (req, res) => {\n  const { email, password } = req.body;\n  const user = await findUser(email);\n  if (!user || !await bcrypt.compare(password, user.password)) {\n    return res.status(401).json({ error: 'Invalid credentials' });\n  }\n  res.json({ user });\n});", "example": "Express"},
    {"id": "bcp13", "type": "prisma", "name": "Prisma Middleware", "description": "Auto-hash", "pattern": "// prisma/middleware/password.ts\nimport bcrypt from 'bcrypt';\n\nprisma.$use(async (params, next) => {\n  if (params.model === 'User') {\n    if (params.action === 'create' || params.action === 'update') {\n      if (params.args.data.password) {\n        params.args.data.password = await bcrypt.hash(\n          params.args.data.password,\n          10\n        );\n      }\n    }\n  }\n  return next(params);\n});", "example": "Prisma"},
    {"id": "bcp14", "type": "mongoose", "name": "Mongoose Pre-save", "description": "Schema hook", "pattern": "import bcrypt from 'bcrypt';\n\nconst userSchema = new mongoose.Schema({\n  email: String,\n  password: String\n});\n\nuserSchema.pre('save', async function(next) {\n  if (!this.isModified('password')) return next();\n  this.password = await bcrypt.hash(this.password, 10);\n  next();\n});\n\nuserSchema.methods.comparePassword = function(password) {\n  return bcrypt.compare(password, this.password);\n};", "example": "Mongoose"},
    {"id": "bcp15", "type": "error", "name": "Error Handling", "description": "Handle errors", "pattern": "try {\n  const hash = await bcrypt.hash(password, 10);\n} catch (error) {\n  if (error.message.includes('data and salt')) {\n    console.error('Invalid password or salt');\n  } else {\n    console.error('Hashing failed:', error);\n  }\n}\n\ntry {\n  await bcrypt.compare(password, hash);\n} catch (error) {\n  // Invalid hash format\n  console.error('Comparison failed:', error);\n}", "example": "Errors"},
    {"id": "bcp16", "type": "typescript", "name": "TypeScript", "description": "Type definitions", "pattern": "import bcrypt from 'bcrypt';\n\ninterface User {\n  id: number;\n  email: string;\n  password: string;\n}\n\nasync function hashPassword(password: string): Promise<string> {\n  return bcrypt.hash(password, 10);\n}\n\nasync function verifyPassword(password: string, hash: string): Promise<boolean> {\n  return bcrypt.compare(password, hash);\n}", "example": "TypeScript"},
    {"id": "bcp17", "type": "test", "name": "Testing", "description": "Test hashing", "pattern": "import bcrypt from 'bcrypt';\n\ndescribe('Password hashing', () => {\n  const password = 'test-password';\n  let hash: string;\n  \n  beforeAll(async () => {\n    hash = await bcrypt.hash(password, 10);\n  });\n  \n  it('hashes password', () => {\n    expect(hash).not.toBe(password);\n    expect(hash).toMatch(/^\\$2[aby]\\$/);\n  });\n  \n  it('verifies correct password', async () => {\n    expect(await bcrypt.compare(password, hash)).toBe(true);\n  });\n  \n  it('rejects wrong password', async () => {\n    expect(await bcrypt.compare('wrong', hash)).toBe(false);\n  });\n});", "example": "Testing"},
    {"id": "bcp18", "type": "bcryptjs", "name": "bcryptjs Alternative", "description": "Pure JS version", "pattern": "// No native dependencies - works everywhere\nimport bcrypt from 'bcryptjs';\n\n// Same API as bcrypt\nconst hash = await bcrypt.hash(password, 10);\nconst isMatch = await bcrypt.compare(password, hash);\n\n// Slightly slower than native bcrypt", "example": "bcryptjs"},
    {"id": "bcp19", "type": "argon2", "name": "Argon2 Alternative", "description": "Modern alternative", "pattern": "// Argon2 is newer and recommended for new projects\nimport argon2 from 'argon2';\n\nconst hash = await argon2.hash(password);\nconst isValid = await argon2.verify(hash, password);\n\n// More configurable than bcrypt\nconst hash = await argon2.hash(password, {\n  type: argon2.argon2id,\n  memoryCost: 65536,\n  timeCost: 3,\n  parallelism: 4\n});", "example": "Argon2"},
    {"id": "bcp20", "type": "security", "name": "Security Tips", "description": "Best practices", "pattern": "// 1. Use at least 10 rounds (12+ recommended)\n// 2. Never store plain passwords\n// 3. Use HTTPS for password transmission\n// 4. Implement rate limiting\n// 5. Don't reveal if email exists\n// 6. Use constant-time comparison\n// 7. Consider pepper (application secret)\n// 8. Upgrade hash rounds over time", "example": "Security"},
    {"id": "bcp21", "type": "pepper", "name": "Adding Pepper", "description": "Extra security", "pattern": "// Pepper = application-level secret\n// Adds extra layer beyond bcrypt\n\nconst PEPPER = process.env.PASSWORD_PEPPER;\n\nasync function hashWithPepper(password) {\n  const peppered = password + PEPPER;\n  return bcrypt.hash(peppered, 12);\n}\n\nasync function verifyWithPepper(password, hash) {\n  const peppered = password + PEPPER;\n  return bcrypt.compare(peppered, hash);\n}", "example": "Pepper"},
    {"id": "bcp22", "type": "rate", "name": "Rate Limiting", "description": "Prevent brute force", "pattern": "import rateLimit from 'express-rate-limit';\n\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,  // 15 minutes\n  max: 5,                     // 5 attempts\n  message: 'Too many login attempts',\n  skipSuccessfulRequests: true\n});\n\napp.post('/login', loginLimiter, async (req, res) => {\n  // Login logic\n});", "example": "Rate Limit"},
    {"id": "bcp23", "type": "lockout", "name": "Account Lockout", "description": "Failed attempts", "pattern": "async function handleLogin(email, password) {\n  const user = await db.user.findUnique({ where: { email } });\n  \n  if (user.failedAttempts >= 5 && user.lockUntil > new Date()) {\n    throw new Error('Account locked. Try again later.');\n  }\n  \n  const isValid = await bcrypt.compare(password, user.password);\n  \n  if (!isValid) {\n    await db.user.update({\n      where: { id: user.id },\n      data: {\n        failedAttempts: { increment: 1 },\n        lockUntil: new Date(Date.now() + 15 * 60 * 1000)\n      }\n    });\n    throw new Error('Invalid password');\n  }\n  \n  // Reset on success\n  await db.user.update({\n    where: { id: user.id },\n    data: { failedAttempts: 0, lockUntil: null }\n  });\n  \n  return user;\n}", "example": "Lockout"},
    {"id": "bcp24", "type": "validate", "name": "Password Validation", "description": "Strength check", "pattern": "function validatePassword(password) {\n  const errors = [];\n  \n  if (password.length < 8) errors.push('At least 8 characters');\n  if (!/[A-Z]/.test(password)) errors.push('At least one uppercase');\n  if (!/[a-z]/.test(password)) errors.push('At least one lowercase');\n  if (!/[0-9]/.test(password)) errors.push('At least one number');\n  if (!/[^A-Za-z0-9]/.test(password)) errors.push('At least one special char');\n  \n  return errors;\n}", "example": "Validate"},
    {"id": "bcp25", "type": "zxcvbn", "name": "zxcvbn Strength", "description": "Password strength", "pattern": "import zxcvbn from 'zxcvbn';\n\nfunction checkStrength(password) {\n  const result = zxcvbn(password);\n  \n  return {\n    score: result.score,        // 0-4\n    feedback: result.feedback,\n    crackTime: result.crack_times_display.offline_slow_hashing_1e4_per_second\n  };\n}\n\n// Require score >= 3 for registration\nif (checkStrength(password).score < 3) {\n  throw new Error('Password too weak');\n}", "example": "zxcvbn"},
    {"id": "bcp26", "type": "reset", "name": "Password Reset", "description": "Reset flow", "pattern": "import crypto from 'crypto';\n\nasync function requestReset(email) {\n  const token = crypto.randomBytes(32).toString('hex');\n  const expires = new Date(Date.now() + 3600000);  // 1 hour\n  \n  await db.user.update({\n    where: { email },\n    data: { resetToken: token, resetExpires: expires }\n  });\n  \n  await sendEmail(email, `Reset link: /reset?token=${token}`);\n}\n\nasync function resetPassword(token, newPassword) {\n  const user = await db.user.findFirst({\n    where: { resetToken: token, resetExpires: { gt: new Date() } }\n  });\n  \n  if (!user) throw new Error('Invalid or expired token');\n  \n  const hash = await bcrypt.hash(newPassword, 10);\n  await db.user.update({\n    where: { id: user.id },\n    data: { password: hash, resetToken: null, resetExpires: null }\n  });\n}", "example": "Reset"},
    {"id": "bcp27", "type": "migrate", "name": "Hash Migration", "description": "Upgrade algorithm", "pattern": "// Migrate from old hash to bcrypt\nasync function migratePassword(userId, password, oldHash) {\n  // Verify with old algorithm (e.g., MD5)\n  const oldValid = md5(password) === oldHash;\n  if (!oldValid) return false;\n  \n  // Upgrade to bcrypt\n  const newHash = await bcrypt.hash(password, 12);\n  await db.user.update({\n    where: { id: userId },\n    data: { \n      password: newHash,\n      hashVersion: 'bcrypt'  // Track algorithm\n    }\n  });\n  \n  return true;\n}", "example": "Migrate"},
    {"id": "bcp28", "type": "worker", "name": "Worker Thread", "description": "Non-blocking", "pattern": "// For high-traffic apps, use worker threads\nimport { Worker } from 'worker_threads';\n\nfunction hashInWorker(password) {\n  return new Promise((resolve, reject) => {\n    const worker = new Worker('./hash-worker.js', {\n      workerData: { password }\n    });\n    worker.on('message', resolve);\n    worker.on('error', reject);\n  });\n}\n\n// hash-worker.js\nimport { workerData, parentPort } from 'worker_threads';\nimport bcrypt from 'bcrypt';\n\nconst hash = bcrypt.hashSync(workerData.password, 12);\nparentPort.postMessage(hash);", "example": "Worker"},
    {"id": "bcp29", "type": "performance", "name": "Performance Tips", "description": "Optimization", "pattern": "// 1. Use async methods (don't block event loop)\n// 2. Choose rounds based on hardware\n// 3. Consider worker threads for high load\n// 4. Cache comparison results briefly\n// 5. Use bcryptjs in serverless (no native deps)\n\n// Benchmark your system\nconsole.time('hash');\nawait bcrypt.hash('test', 12);\nconsole.timeEnd('hash');  // Should be 100-300ms", "example": "Performance"},
    {"id": "bcp30", "type": "audit", "name": "Security Audit", "description": "Check hashes", "pattern": "// Audit existing hashes\nasync function auditHashes() {\n  const users = await db.user.findMany();\n  \n  for (const user of users) {\n    const rounds = bcrypt.getRounds(user.password);\n    const version = user.password.substring(0, 4);\n    \n    if (rounds < 10) {\n      console.log(`User ${user.id}: weak rounds (${rounds})`);\n    }\n    if (version === '$2a$') {\n      console.log(`User ${user.id}: old bcrypt version`);\n    }\n  }\n}", "example": "Audit"}
  ]
}
