{
  "category": "zod-validation-schema",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Zod validation schema patterns",
  "skills": [
    {"id": "zod01", "type": "setup", "name": "Install Zod", "description": "NPM install", "pattern": "npm install zod", "example": "Install"},
    {"id": "zod02", "type": "basic", "name": "Basic Types", "description": "Primitives", "pattern": "import { z } from 'zod';\n\nconst stringSchema = z.string();\nconst numberSchema = z.number();\nconst booleanSchema = z.boolean();\nconst dateSchema = z.date();\nconst bigintSchema = z.bigint();", "example": "Basic"},
    {"id": "zod03", "type": "object", "name": "Object Schema", "description": "Object validation", "pattern": "const userSchema = z.object({\n  name: z.string(),\n  email: z.string().email(),\n  age: z.number().min(0).max(150)\n});\n\ntype User = z.infer<typeof userSchema>;", "example": "Object"},
    {"id": "zod04", "type": "parse", "name": "Parse Data", "description": "Validate and parse", "pattern": "// Throws on invalid data\nconst user = userSchema.parse({ name: 'John', email: 'john@example.com', age: 30 });\n\n// Returns result object\nconst result = userSchema.safeParse(data);\nif (result.success) {\n  console.log(result.data);\n} else {\n  console.log(result.error);\n}", "example": "Parse"},
    {"id": "zod05", "type": "string", "name": "String Validations", "description": "String methods", "pattern": "z.string().min(5)\nz.string().max(100)\nz.string().length(10)\nz.string().email()\nz.string().url()\nz.string().uuid()\nz.string().regex(/^[a-z]+$/)\nz.string().trim()\nz.string().toLowerCase()\nz.string().startsWith('Hello')\nz.string().endsWith('!')", "example": "String"},
    {"id": "zod06", "type": "number", "name": "Number Validations", "description": "Number methods", "pattern": "z.number().gt(5)\nz.number().gte(5)\nz.number().lt(10)\nz.number().lte(10)\nz.number().int()\nz.number().positive()\nz.number().negative()\nz.number().nonpositive()\nz.number().nonnegative()\nz.number().multipleOf(5)\nz.number().finite()", "example": "Number"},
    {"id": "zod07", "type": "array", "name": "Array Schema", "description": "Array validation", "pattern": "const stringArraySchema = z.array(z.string());\nconst userArraySchema = z.array(userSchema);\n\nz.array(z.string()).min(1)\nz.array(z.string()).max(10)\nz.array(z.string()).length(5)\nz.array(z.string()).nonempty()", "example": "Array"},
    {"id": "zod08", "type": "optional", "name": "Optional Fields", "description": "Optional/nullable", "pattern": "const schema = z.object({\n  required: z.string(),\n  optional: z.string().optional(),      // string | undefined\n  nullable: z.string().nullable(),      // string | null\n  nullish: z.string().nullish()         // string | null | undefined\n});", "example": "Optional"},
    {"id": "zod09", "type": "default", "name": "Default Values", "description": "Set defaults", "pattern": "const schema = z.object({\n  name: z.string().default('Anonymous'),\n  role: z.enum(['user', 'admin']).default('user'),\n  createdAt: z.date().default(() => new Date())\n});", "example": "Default"},
    {"id": "zod10", "type": "enum", "name": "Enums", "description": "Enum types", "pattern": "const roleSchema = z.enum(['user', 'admin', 'moderator']);\ntype Role = z.infer<typeof roleSchema>;  // 'user' | 'admin' | 'moderator'\n\n// Native enum\nenum Status { Active, Inactive }\nconst statusSchema = z.nativeEnum(Status);", "example": "Enum"},
    {"id": "zod11", "type": "union", "name": "Union Types", "description": "Or types", "pattern": "const stringOrNumber = z.union([z.string(), z.number()]);\n\n// Discriminated union\nconst resultSchema = z.discriminatedUnion('status', [\n  z.object({ status: z.literal('success'), data: z.string() }),\n  z.object({ status: z.literal('error'), message: z.string() })\n]);", "example": "Union"},
    {"id": "zod12", "type": "literal", "name": "Literal Types", "description": "Exact values", "pattern": "const tuna = z.literal('tuna');\nconst twelve = z.literal(12);\nconst active = z.literal(true);", "example": "Literal"},
    {"id": "zod13", "type": "tuple", "name": "Tuple Schema", "description": "Fixed array", "pattern": "const coordinateSchema = z.tuple([z.number(), z.number()]);\ntype Coordinate = z.infer<typeof coordinateSchema>;  // [number, number]\n\n// With rest\nconst variadic = z.tuple([z.string()]).rest(z.number());\n// [string, ...number[]]", "example": "Tuple"},
    {"id": "zod14", "type": "record", "name": "Record Schema", "description": "Object with dynamic keys", "pattern": "const stringRecord = z.record(z.string());  // { [k: string]: string }\n\nconst userRecord = z.record(z.string(), userSchema);\n// { [userId: string]: User }", "example": "Record"},
    {"id": "zod15", "type": "map", "name": "Map/Set Schema", "description": "Collections", "pattern": "const stringMap = z.map(z.string(), z.number());\nconst stringSet = z.set(z.string());\n\nz.set(z.string()).min(1).max(10)", "example": "Map/Set"},
    {"id": "zod16", "type": "transform", "name": "Transform", "description": "Transform data", "pattern": "const schema = z.string().transform((val) => val.toUpperCase());\n\nconst dateSchema = z.string().transform((str) => new Date(str));\n\nconst schema = z.object({\n  firstName: z.string(),\n  lastName: z.string()\n}).transform((obj) => ({\n  ...obj,\n  fullName: `${obj.firstName} ${obj.lastName}`\n}));", "example": "Transform"},
    {"id": "zod17", "type": "refine", "name": "Custom Validation", "description": "Refine/superRefine", "pattern": "const passwordSchema = z.string()\n  .min(8)\n  .refine((val) => /[A-Z]/.test(val), 'Need uppercase')\n  .refine((val) => /[0-9]/.test(val), 'Need number');\n\nconst formSchema = z.object({\n  password: z.string(),\n  confirm: z.string()\n}).refine((data) => data.password === data.confirm, {\n  message: 'Passwords must match',\n  path: ['confirm']\n});", "example": "Refine"},
    {"id": "zod18", "type": "preprocess", "name": "Preprocess", "description": "Transform before validation", "pattern": "const numberSchema = z.preprocess(\n  (val) => Number(val),\n  z.number()\n);\n\nnumberSchema.parse('123');  // 123", "example": "Preprocess"},
    {"id": "zod19", "type": "coerce", "name": "Coercion", "description": "Auto-coerce types", "pattern": "z.coerce.string()    // Converts to string\nz.coerce.number()    // Converts to number\nz.coerce.boolean()   // Converts to boolean\nz.coerce.date()      // Converts to Date\n\nz.coerce.number().parse('123');  // 123", "example": "Coerce"},
    {"id": "zod20", "type": "extend", "name": "Extend/Merge", "description": "Combine schemas", "pattern": "const baseSchema = z.object({ id: z.number() });\n\n// Extend\nconst userSchema = baseSchema.extend({\n  name: z.string()\n});\n\n// Merge\nconst merged = schema1.merge(schema2);\n\n// Pick/Omit\nconst picked = userSchema.pick({ name: true });\nconst omitted = userSchema.omit({ id: true });", "example": "Extend"},
    {"id": "zod21", "type": "partial", "name": "Partial/Required", "description": "Modify optionality", "pattern": "const userSchema = z.object({\n  name: z.string(),\n  email: z.string()\n});\n\nconst partialUser = userSchema.partial();\n// All fields optional\n\nconst deepPartial = userSchema.deepPartial();\n// Deep partial\n\nconst requiredUser = partialUser.required();\n// All fields required again", "example": "Partial"},
    {"id": "zod22", "type": "passthrough", "name": "Unknown Keys", "description": "Handle extra keys", "pattern": "// Strip unknown keys (default)\nz.object({ name: z.string() }).parse({ name: 'John', extra: 'removed' });\n// { name: 'John' }\n\n// Keep unknown keys\nz.object({ name: z.string() }).passthrough().parse({ name: 'John', extra: 'kept' });\n// { name: 'John', extra: 'kept' }\n\n// Error on unknown keys\nz.object({ name: z.string() }).strict();", "example": "Passthrough"},
    {"id": "zod23", "type": "error", "name": "Custom Errors", "description": "Error messages", "pattern": "z.string({\n  required_error: 'Name is required',\n  invalid_type_error: 'Name must be a string'\n}).min(2, { message: 'Name too short' });\n\n// Error formatting\nconst result = schema.safeParse(data);\nif (!result.success) {\n  const formatted = result.error.format();\n  const flattened = result.error.flatten();\n  const issues = result.error.issues;\n}", "example": "Errors"},
    {"id": "zod24", "type": "async", "name": "Async Validation", "description": "Async refinement", "pattern": "const emailSchema = z.string().email().refine(\n  async (email) => {\n    const exists = await checkEmailExists(email);\n    return !exists;\n  },\n  { message: 'Email already taken' }\n);\n\nawait emailSchema.parseAsync('test@example.com');", "example": "Async"},
    {"id": "zod25", "type": "infer", "name": "Type Inference", "description": "Extract types", "pattern": "const userSchema = z.object({\n  name: z.string(),\n  age: z.number()\n});\n\ntype User = z.infer<typeof userSchema>;\n// { name: string; age: number }\n\ntype UserInput = z.input<typeof userSchema>;\ntype UserOutput = z.output<typeof userSchema>;", "example": "Infer"},
    {"id": "zod26", "type": "brand", "name": "Branded Types", "description": "Type branding", "pattern": "const UserId = z.string().brand<'UserId'>();\ntype UserId = z.infer<typeof UserId>;\n\nfunction getUser(id: UserId) { }\n\ngetUser('123');  // Error: string not UserId\ngetUser(UserId.parse('123'));  // OK", "example": "Brand"},
    {"id": "zod27", "type": "api", "name": "API Validation", "description": "Request validation", "pattern": "const createUserSchema = z.object({\n  body: z.object({\n    name: z.string(),\n    email: z.string().email()\n  }),\n  query: z.object({\n    redirect: z.string().optional()\n  })\n});\n\napp.post('/users', (req, res) => {\n  const result = createUserSchema.safeParse(req);\n  if (!result.success) {\n    return res.status(400).json(result.error.flatten());\n  }\n  // Use result.data\n});", "example": "API"},
    {"id": "zod28", "type": "form", "name": "Form Validation", "description": "React Hook Form", "pattern": "import { zodResolver } from '@hookform/resolvers/zod';\n\nconst schema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8)\n});\n\nconst { register, handleSubmit, formState: { errors } } = useForm({\n  resolver: zodResolver(schema)\n});", "example": "Form"},
    {"id": "zod29", "type": "trpc", "name": "tRPC Integration", "description": "Type-safe API", "pattern": "import { initTRPC } from '@trpc/server';\n\nconst t = initTRPC.create();\n\nexport const appRouter = t.router({\n  createUser: t.procedure\n    .input(z.object({\n      name: z.string(),\n      email: z.string().email()\n    }))\n    .mutation(({ input }) => {\n      // input is typed!\n    })\n});", "example": "tRPC"},
    {"id": "zod30", "type": "pattern", "name": "Best Practices", "description": "Patterns", "pattern": "// 1. Define schemas close to usage\n// 2. Use z.infer for type extraction\n// 3. Compose with extend/merge\n// 4. Use safeParse for error handling\n// 5. Custom error messages for UX", "example": "Patterns"}
  ]
}
