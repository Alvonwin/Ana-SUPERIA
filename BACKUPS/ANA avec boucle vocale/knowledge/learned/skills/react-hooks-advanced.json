{
  "category": "react-hooks-advanced",
  "version": "1.0.0",
  "generatedBy": "Claude (Opus 4.5)",
  "description": "Advanced React hooks patterns",
  "skills": [
    {"id": "rhk01", "type": "state", "name": "useState with Function", "description": "Lazy initial state", "pattern": "useState(() => expensiveComputation())", "example": "Only runs once"},
    {"id": "rhk02", "type": "state", "name": "Functional Updates", "description": "Update based on previous", "pattern": "setState(prev => prev + 1)", "example": "Avoid stale closures"},
    {"id": "rhk03", "type": "effect", "name": "useEffect Dependencies", "description": "Control when effect runs", "pattern": "useEffect(fn, [dep1, dep2])", "example": "Empty array = mount only"},
    {"id": "rhk04", "type": "effect", "name": "useEffect Cleanup", "description": "Clean up resources", "pattern": "useEffect(() => { return () => cleanup() }, [])", "example": "Unsubscribe, cancel"},
    {"id": "rhk05", "type": "effect", "name": "useLayoutEffect", "description": "Sync DOM mutations", "pattern": "useLayoutEffect(() => { measure() }, [])", "example": "Before paint"},
    {"id": "rhk06", "type": "ref", "name": "useRef for Values", "description": "Mutable value holder", "pattern": "const countRef = useRef(0); countRef.current++", "example": "No re-render"},
    {"id": "rhk07", "type": "ref", "name": "useRef for DOM", "description": "DOM element reference", "pattern": "<input ref={inputRef} /> inputRef.current.focus()", "example": "Direct DOM access"},
    {"id": "rhk08", "type": "callback", "name": "useCallback", "description": "Memoize functions", "pattern": "useCallback(() => fn(a, b), [a, b])", "example": "Stable reference"},
    {"id": "rhk09", "type": "memo", "name": "useMemo", "description": "Memoize values", "pattern": "useMemo(() => expensive(a, b), [a, b])", "example": "Avoid recalculation"},
    {"id": "rhk10", "type": "context", "name": "useContext", "description": "Consume context", "pattern": "const value = useContext(MyContext)", "example": "No Consumer needed"},
    {"id": "rhk11", "type": "reducer", "name": "useReducer", "description": "Complex state logic", "pattern": "const [state, dispatch] = useReducer(reducer, init)", "example": "Redux-like pattern"},
    {"id": "rhk12", "type": "reducer", "name": "Reducer with Init", "description": "Lazy initialization", "pattern": "useReducer(reducer, arg, init)", "example": "init(arg) called"},
    {"id": "rhk13", "type": "imperative", "name": "useImperativeHandle", "description": "Customize ref", "pattern": "useImperativeHandle(ref, () => ({ focus: () => {} }))", "example": "Expose methods"},
    {"id": "rhk14", "type": "debug", "name": "useDebugValue", "description": "DevTools label", "pattern": "useDebugValue(isOnline ? 'Online' : 'Offline')", "example": "Custom hook debugging"},
    {"id": "rhk15", "type": "id", "name": "useId", "description": "Generate unique ID", "pattern": "const id = useId()", "example": "SSR-safe unique IDs"},
    {"id": "rhk16", "type": "transition", "name": "useTransition", "description": "Non-blocking updates", "pattern": "const [isPending, startTransition] = useTransition()", "example": "Keep UI responsive"},
    {"id": "rhk17", "type": "deferred", "name": "useDeferredValue", "description": "Defer expensive value", "pattern": "const deferredQuery = useDeferredValue(query)", "example": "Show stale while loading"},
    {"id": "rhk18", "type": "sync", "name": "useSyncExternalStore", "description": "Subscribe to external", "pattern": "useSyncExternalStore(subscribe, getSnapshot)", "example": "Third-party state"},
    {"id": "rhk19", "type": "custom", "name": "Custom Hook Pattern", "description": "Create reusable hooks", "pattern": "function useCounter() { const [count, setCount] = useState(0); return {count, inc} }", "example": "use prefix required"},
    {"id": "rhk20", "type": "custom", "name": "useLocalStorage", "description": "Persist to localStorage", "pattern": "const [value, setValue] = useLocalStorage('key', defaultValue)", "example": "Sync with storage"},
    {"id": "rhk21", "type": "custom", "name": "useFetch", "description": "Data fetching hook", "pattern": "const { data, loading, error } = useFetch(url)", "example": "Encapsulate fetch"},
    {"id": "rhk22", "type": "custom", "name": "useDebounce", "description": "Debounce value", "pattern": "const debouncedValue = useDebounce(value, 500)", "example": "Delay updates"},
    {"id": "rhk23", "type": "custom", "name": "useToggle", "description": "Boolean toggle", "pattern": "const [isOn, toggle] = useToggle(false)", "example": "Simple on/off"},
    {"id": "rhk24", "type": "custom", "name": "usePrevious", "description": "Previous value", "pattern": "const prevCount = usePrevious(count)", "example": "Compare changes"},
    {"id": "rhk25", "type": "custom", "name": "useOnClickOutside", "description": "Click outside detection", "pattern": "useOnClickOutside(ref, () => close())", "example": "Close dropdowns"},
    {"id": "rhk26", "type": "custom", "name": "useInterval", "description": "Safe setInterval", "pattern": "useInterval(() => tick(), 1000)", "example": "Handles cleanup"},
    {"id": "rhk27", "type": "custom", "name": "useMediaQuery", "description": "Responsive hook", "pattern": "const isMobile = useMediaQuery('(max-width: 768px)')", "example": "CSS media queries"},
    {"id": "rhk28", "type": "rules", "name": "Rules of Hooks", "description": "Hook constraints", "pattern": "Top level only, React functions only", "example": "No conditionals"},
    {"id": "rhk29", "type": "pattern", "name": "Compound Hooks", "description": "Combine multiple hooks", "pattern": "Custom hook using useState + useEffect + useCallback", "example": "Complex logic"},
    {"id": "rhk30", "type": "testing", "name": "Testing Hooks", "description": "Test custom hooks", "pattern": "@testing-library/react-hooks renderHook()", "example": "Isolate hook testing"}
  ]
}
