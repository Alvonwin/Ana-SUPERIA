{
  "category": "clean-architecture-solid",
  "version": "1.0.0",
  "generatedBy": "Claude Opus 4.5 - Module de référence pour Ana SUPERIA",
  "skills": [
    {"id": "ca01", "type": "solid", "name": "Single Responsibility Principle", "description": "A class should have one reason to change", "pattern": "// BAD: Multiple responsibilities\nclass UserService {\n  createUser(data) { /* ... */ }\n  sendEmail(user) { /* ... */ }\n  generateReport(users) { /* ... */ }\n}\n\n// GOOD: Single responsibility each\nclass UserService {\n  createUser(data) { /* ... */ }\n}\n\nclass EmailService {\n  sendEmail(to, subject, body) { /* ... */ }\n}\n\nclass ReportService {\n  generateUserReport(users) { /* ... */ }\n}", "example": "Split large classes by responsibility"},
    {"id": "ca02", "type": "solid", "name": "Open/Closed Principle", "description": "Open for extension, closed for modification", "pattern": "// BAD: Modify class for new shapes\nclass AreaCalculator {\n  calculate(shape) {\n    if (shape.type === 'circle') return Math.PI * shape.radius ** 2;\n    if (shape.type === 'square') return shape.side ** 2;\n    // Must modify for new shapes\n  }\n}\n\n// GOOD: Extend without modification\nclass Shape {\n  area() { throw new Error('Abstract'); }\n}\n\nclass Circle extends Shape {\n  constructor(radius) { super(); this.radius = radius; }\n  area() { return Math.PI * this.radius ** 2; }\n}\n\nclass Square extends Shape {\n  constructor(side) { super(); this.side = side; }\n  area() { return this.side ** 2; }\n}", "example": "Use polymorphism instead of conditionals"},
    {"id": "ca03", "type": "solid", "name": "Liskov Substitution Principle", "description": "Subtypes must be substitutable for base types", "pattern": "// BAD: Square breaks Rectangle contract\nclass Rectangle {\n  setWidth(w) { this.width = w; }\n  setHeight(h) { this.height = h; }\n  area() { return this.width * this.height; }\n}\n\nclass Square extends Rectangle {\n  setWidth(w) { this.width = this.height = w; } // Breaks expectation!\n}\n\n// GOOD: Separate abstractions\nclass Shape {\n  area() { throw new Error('Abstract'); }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) { super(); this.width = width; this.height = height; }\n  area() { return this.width * this.height; }\n}\n\nclass Square extends Shape {\n  constructor(side) { super(); this.side = side; }\n  area() { return this.side ** 2; }\n}", "example": "Subclasses must honor base class contracts"},
    {"id": "ca04", "type": "solid", "name": "Interface Segregation Principle", "description": "Many specific interfaces over one general interface", "pattern": "// BAD: Fat interface\ninterface Worker {\n  work(): void;\n  eat(): void;\n  sleep(): void;\n}\n\nclass Robot implements Worker {\n  work() { /* ... */ }\n  eat() { throw new Error('Robots dont eat'); } // Forced to implement\n  sleep() { throw new Error('Robots dont sleep'); }\n}\n\n// GOOD: Segregated interfaces\ninterface Workable {\n  work(): void;\n}\n\ninterface Feedable {\n  eat(): void;\n}\n\nclass Robot implements Workable {\n  work() { /* ... */ }\n}\n\nclass Human implements Workable, Feedable {\n  work() { /* ... */ }\n  eat() { /* ... */ }\n}", "example": "Clients shouldnt depend on unused methods"},
    {"id": "ca05", "type": "solid", "name": "Dependency Inversion Principle", "description": "Depend on abstractions, not concretions", "pattern": "// BAD: High-level depends on low-level\nclass UserService {\n  constructor() {\n    this.database = new MySQLDatabase(); // Concrete dependency\n  }\n}\n\n// GOOD: Depend on abstraction\ninterface Database {\n  save(data: any): Promise<void>;\n  find(id: string): Promise<any>;\n}\n\nclass UserService {\n  constructor(private database: Database) {} // Abstraction injected\n}\n\n// Usage\nconst userService = new UserService(new MySQLDatabase());\n// Or: new UserService(new PostgresDatabase());\n// Or: new UserService(new MockDatabase());", "example": "Inject dependencies, dont create them"},
    {"id": "ca06", "type": "architecture", "name": "Clean Architecture Layers", "description": "Concentric layers with dependency rule", "pattern": "// Layer structure (outside to inside):\n// 1. Frameworks & Drivers (Web, DB, UI)\n// 2. Interface Adapters (Controllers, Presenters, Gateways)\n// 3. Application Business Rules (Use Cases)\n// 4. Enterprise Business Rules (Entities)\n\n// Dependency rule: Only point inward\nsrc/\n  domain/           # Entities (innermost)\n    entities/\n    value-objects/\n  application/      # Use Cases\n    use-cases/\n    interfaces/     # Ports (abstractions)\n  infrastructure/   # Adapters (outermost)\n    database/\n    http/\n    external-services/\n  presentation/     # Controllers, Views\n    controllers/\n    views/", "example": "Dependencies point toward center"},
    {"id": "ca07", "type": "architecture", "name": "Entity Layer", "description": "Enterprise business rules", "pattern": "// Pure domain logic, no dependencies\nclass Order {\n  constructor(id, items, customerId) {\n    this.id = id;\n    this.items = items;\n    this.customerId = customerId;\n    this.status = 'pending';\n  }\n  \n  get total() {\n    return this.items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  }\n  \n  canBeCancelled() {\n    return ['pending', 'confirmed'].includes(this.status);\n  }\n  \n  cancel() {\n    if (!this.canBeCancelled()) throw new Error('Cannot cancel');\n    this.status = 'cancelled';\n  }\n}", "example": "Business rules in domain entities"},
    {"id": "ca08", "type": "architecture", "name": "Use Case Layer", "description": "Application-specific business rules", "pattern": "class CreateOrderUseCase {\n  constructor(orderRepository, paymentGateway, emailService) {\n    this.orderRepository = orderRepository;\n    this.paymentGateway = paymentGateway;\n    this.emailService = emailService;\n  }\n  \n  async execute(input) {\n    // 1. Create order entity\n    const order = new Order(input.items, input.customerId);\n    \n    // 2. Validate business rules\n    if (order.total < 10) throw new MinimumOrderError();\n    \n    // 3. Process payment\n    await this.paymentGateway.charge(order.total, input.paymentMethod);\n    \n    // 4. Save order\n    await this.orderRepository.save(order);\n    \n    // 5. Send confirmation\n    await this.emailService.sendOrderConfirmation(order);\n    \n    return { orderId: order.id };\n  }\n}", "example": "Orchestrate entities and ports"},
    {"id": "ca09", "type": "architecture", "name": "Port (Interface)", "description": "Define contracts for external dependencies", "pattern": "// Ports are interfaces in the application layer\ninterface OrderRepository {\n  save(order: Order): Promise<void>;\n  findById(id: string): Promise<Order | null>;\n  findByCustomer(customerId: string): Promise<Order[]>;\n}\n\ninterface PaymentGateway {\n  charge(amount: number, method: PaymentMethod): Promise<PaymentResult>;\n  refund(paymentId: string): Promise<void>;\n}\n\ninterface EmailService {\n  sendOrderConfirmation(order: Order): Promise<void>;\n  sendShippingNotification(order: Order, tracking: string): Promise<void>;\n}", "example": "Abstractions for infrastructure"},
    {"id": "ca10", "type": "architecture", "name": "Adapter (Implementation)", "description": "Implement ports for specific technology", "pattern": "// PostgresOrderRepository implements OrderRepository port\nclass PostgresOrderRepository implements OrderRepository {\n  constructor(private db: PostgresClient) {}\n  \n  async save(order: Order): Promise<void> {\n    await this.db.query(\n      'INSERT INTO orders (id, customer_id, items, status) VALUES ($1, $2, $3, $4)',\n      [order.id, order.customerId, JSON.stringify(order.items), order.status]\n    );\n  }\n  \n  async findById(id: string): Promise<Order | null> {\n    const result = await this.db.query('SELECT * FROM orders WHERE id = $1', [id]);\n    if (!result.rows[0]) return null;\n    return this.mapToEntity(result.rows[0]);\n  }\n  \n  private mapToEntity(row: any): Order {\n    return new Order(row.id, JSON.parse(row.items), row.customer_id);\n  }\n}", "example": "Concrete implementation of port"},
    {"id": "ca11", "type": "architecture", "name": "Controller/Presenter", "description": "Interface adapters for UI/API", "pattern": "class OrderController {\n  constructor(private createOrderUseCase: CreateOrderUseCase) {}\n  \n  async create(req: Request, res: Response) {\n    try {\n      // 1. Parse request\n      const input = {\n        items: req.body.items,\n        customerId: req.user.id,\n        paymentMethod: req.body.paymentMethod\n      };\n      \n      // 2. Execute use case\n      const result = await this.createOrderUseCase.execute(input);\n      \n      // 3. Format response\n      res.status(201).json({\n        success: true,\n        data: { orderId: result.orderId }\n      });\n    } catch (error) {\n      // 4. Handle errors\n      if (error instanceof MinimumOrderError) {\n        res.status(400).json({ error: error.message });\n      } else {\n        res.status(500).json({ error: 'Internal error' });\n      }\n    }\n  }\n}", "example": "Adapt between use cases and external"},
    {"id": "ca12", "type": "hexagonal", "name": "Hexagonal Architecture", "description": "Ports and adapters pattern", "pattern": "// Core (inside hexagon)\nsrc/\n  core/\n    domain/        # Entities, Value Objects\n    application/   # Use Cases\n    ports/\n      inbound/     # Driving ports (called by outside)\n        CreateOrderPort.ts\n      outbound/    # Driven ports (called by core)\n        OrderRepositoryPort.ts\n\n// Adapters (outside hexagon)\n  adapters/\n    inbound/       # Driving adapters\n      http/        # REST controllers\n      grpc/        # gRPC handlers\n      cli/         # CLI commands\n    outbound/      # Driven adapters\n      persistence/ # Database implementations\n      messaging/   # Queue implementations\n      external/    # External service clients", "example": "Symmetric input/output ports"},
    {"id": "ca13", "type": "ddd", "name": "Value Object", "description": "Immutable objects defined by attributes", "pattern": "class Money {\n  constructor(amount, currency) {\n    if (amount < 0) throw new Error('Amount cannot be negative');\n    this.amount = amount;\n    this.currency = currency;\n    Object.freeze(this);\n  }\n  \n  add(other) {\n    if (this.currency !== other.currency) throw new Error('Currency mismatch');\n    return new Money(this.amount + other.amount, this.currency);\n  }\n  \n  equals(other) {\n    return this.amount === other.amount && this.currency === other.currency;\n  }\n  \n  toString() {\n    return `${this.currency} ${this.amount.toFixed(2)}`;\n  }\n}\n\nconst price = new Money(99.99, 'USD');\nconst tax = new Money(7.50, 'USD');\nconst total = price.add(tax);", "example": "Money, Email, Address, DateRange"},
    {"id": "ca14", "type": "ddd", "name": "Aggregate Root", "description": "Consistency boundary for entities", "pattern": "class Order {\n  constructor(id, customerId) {\n    this.id = id;\n    this.customerId = customerId;\n    this.items = []; // Only accessible through Order\n    this.status = 'draft';\n  }\n  \n  // All modifications go through aggregate root\n  addItem(productId, quantity, price) {\n    if (this.status !== 'draft') throw new Error('Cannot modify confirmed order');\n    \n    const existing = this.items.find(i => i.productId === productId);\n    if (existing) {\n      existing.quantity += quantity;\n    } else {\n      this.items.push(new OrderItem(productId, quantity, price));\n    }\n  }\n  \n  removeItem(productId) {\n    if (this.status !== 'draft') throw new Error('Cannot modify confirmed order');\n    this.items = this.items.filter(i => i.productId !== productId);\n  }\n  \n  confirm() {\n    if (this.items.length === 0) throw new Error('Cannot confirm empty order');\n    this.status = 'confirmed';\n  }\n}", "example": "Protect invariants, control access"},
    {"id": "ca15", "type": "ddd", "name": "Domain Event", "description": "Capture something that happened in domain", "pattern": "class DomainEvent {\n  constructor() {\n    this.occurredAt = new Date();\n    this.eventId = crypto.randomUUID();\n  }\n}\n\nclass OrderConfirmed extends DomainEvent {\n  constructor(orderId, customerId, total) {\n    super();\n    this.orderId = orderId;\n    this.customerId = customerId;\n    this.total = total;\n  }\n}\n\nclass Order {\n  constructor() {\n    this.domainEvents = [];\n  }\n  \n  confirm() {\n    this.status = 'confirmed';\n    this.domainEvents.push(new OrderConfirmed(this.id, this.customerId, this.total));\n  }\n  \n  pullDomainEvents() {\n    const events = [...this.domainEvents];\n    this.domainEvents = [];\n    return events;\n  }\n}", "example": "Decouple with domain events"},
    {"id": "ca16", "type": "ddd", "name": "Domain Service", "description": "Stateless domain logic across entities", "pattern": "class PricingService {\n  calculateDiscount(order, customer) {\n    let discount = 0;\n    \n    // Loyalty discount\n    if (customer.loyaltyTier === 'gold') discount += 0.1;\n    if (customer.loyaltyTier === 'platinum') discount += 0.15;\n    \n    // Volume discount\n    if (order.total > 500) discount += 0.05;\n    if (order.total > 1000) discount += 0.1;\n    \n    // Cap discount at 25%\n    return Math.min(discount, 0.25);\n  }\n}\n\nclass OrderService {\n  constructor(pricingService, orderRepository) {\n    this.pricingService = pricingService;\n    this.orderRepository = orderRepository;\n  }\n  \n  async applyDiscount(orderId, customer) {\n    const order = await this.orderRepository.findById(orderId);\n    const discount = this.pricingService.calculateDiscount(order, customer);\n    order.applyDiscount(discount);\n    await this.orderRepository.save(order);\n  }\n}", "example": "Logic that doesnt fit in one entity"},
    {"id": "ca17", "type": "ddd", "name": "Bounded Context", "description": "Explicit boundary for domain model", "pattern": "// Different contexts have different models for 'User'\n\n// Identity Context\nclass User {\n  id: string;\n  email: string;\n  passwordHash: string;\n  roles: Role[];\n  \n  authenticate(password): boolean;\n  changePassword(old, new): void;\n}\n\n// Billing Context\nclass Customer {\n  id: string; // Same as User.id\n  billingAddress: Address;\n  paymentMethods: PaymentMethod[];\n  creditLimit: Money;\n  \n  canPurchase(amount: Money): boolean;\n}\n\n// Sales Context\nclass Buyer {\n  id: string;\n  loyaltyTier: LoyaltyTier;\n  purchaseHistory: Purchase[];\n  \n  calculateLoyaltyDiscount(): Percentage;\n}", "example": "Same concept, different models per context"},
    {"id": "ca18", "type": "ddd", "name": "Anti-Corruption Layer", "description": "Translate between bounded contexts", "pattern": "// Protect Sales context from Identity context\nclass UserACL {\n  constructor(private identityService: IdentityServiceClient) {}\n  \n  async getBuyer(userId: string): Promise<Buyer> {\n    // Call external Identity service\n    const identityUser = await this.identityService.getUser(userId);\n    \n    // Translate to Sales context model\n    return new Buyer({\n      id: identityUser.id,\n      loyaltyTier: this.mapLoyaltyTier(identityUser.accountType),\n      purchaseHistory: [] // Loaded separately\n    });\n  }\n  \n  private mapLoyaltyTier(accountType: string): LoyaltyTier {\n    switch (accountType) {\n      case 'PREMIUM': return LoyaltyTier.GOLD;\n      case 'VIP': return LoyaltyTier.PLATINUM;\n      default: return LoyaltyTier.STANDARD;\n    }\n  }\n}", "example": "Isolate from external models"},
    {"id": "ca19", "type": "cqrs", "name": "CQRS Pattern", "description": "Separate read and write models", "pattern": "// Command (Write) side\nclass CreateOrderCommandHandler {\n  async handle(command: CreateOrderCommand): Promise<string> {\n    const order = new Order(command.customerId, command.items);\n    await this.orderRepository.save(order);\n    await this.eventBus.publish(order.pullDomainEvents());\n    return order.id;\n  }\n}\n\n// Query (Read) side\nclass OrderQueryService {\n  constructor(private readDb: ReadDatabase) {}\n  \n  async getOrderSummary(orderId: string): Promise<OrderSummaryDTO> {\n    // Optimized read from denormalized view\n    return this.readDb.query(`\n      SELECT o.id, o.status, o.total,\n             c.name as customer_name,\n             COUNT(i.id) as item_count\n      FROM order_summaries o\n      JOIN customers c ON o.customer_id = c.id\n      LEFT JOIN order_items i ON o.id = i.order_id\n      WHERE o.id = ?\n      GROUP BY o.id\n    `, [orderId]);\n  }\n}", "example": "Optimize reads and writes separately"},
    {"id": "ca20", "type": "pattern", "name": "Repository Pattern", "description": "Collection-like interface for aggregates", "pattern": "interface OrderRepository {\n  // Collection semantics\n  save(order: Order): Promise<void>;\n  findById(id: OrderId): Promise<Order | null>;\n  findByCustomer(customerId: CustomerId): Promise<Order[]>;\n  remove(order: Order): Promise<void>;\n  \n  // Specification support\n  findMatching(spec: Specification<Order>): Promise<Order[]>;\n}\n\nclass PostgresOrderRepository implements OrderRepository {\n  async save(order: Order): Promise<void> {\n    // Persist entire aggregate\n    await this.db.transaction(async (tx) => {\n      await tx.upsert('orders', this.mapToRow(order));\n      await tx.delete('order_items', { order_id: order.id });\n      for (const item of order.items) {\n        await tx.insert('order_items', this.mapItemToRow(item));\n      }\n    });\n  }\n}", "example": "Abstract persistence of aggregates"},
    {"id": "ca21", "type": "pattern", "name": "Factory Pattern for Entities", "description": "Complex entity creation logic", "pattern": "class OrderFactory {\n  constructor(\n    private idGenerator: IdGenerator,\n    private pricingService: PricingService,\n    private inventoryService: InventoryService\n  ) {}\n  \n  async createFromCart(cart: Cart, customer: Customer): Promise<Order> {\n    // Validate inventory\n    for (const item of cart.items) {\n      const available = await this.inventoryService.checkAvailability(item.productId);\n      if (available < item.quantity) {\n        throw new InsufficientInventoryError(item.productId);\n      }\n    }\n    \n    // Create order with generated ID\n    const order = new Order(\n      this.idGenerator.generate(),\n      customer.id\n    );\n    \n    // Add items with pricing\n    for (const item of cart.items) {\n      const price = await this.pricingService.getPrice(item.productId, customer);\n      order.addItem(item.productId, item.quantity, price);\n    }\n    \n    return order;\n  }\n}", "example": "Encapsulate complex creation"},
    {"id": "ca22", "type": "testing", "name": "Unit Testing Use Cases", "description": "Test business logic in isolation", "pattern": "describe('CreateOrderUseCase', () => {\n  let useCase: CreateOrderUseCase;\n  let orderRepository: MockOrderRepository;\n  let paymentGateway: MockPaymentGateway;\n  \n  beforeEach(() => {\n    orderRepository = new MockOrderRepository();\n    paymentGateway = new MockPaymentGateway();\n    useCase = new CreateOrderUseCase(orderRepository, paymentGateway);\n  });\n  \n  it('creates order and processes payment', async () => {\n    paymentGateway.charge.mockResolvedValue({ success: true });\n    \n    const result = await useCase.execute({\n      customerId: 'cust-123',\n      items: [{ productId: 'prod-1', quantity: 2, price: 50 }],\n      paymentMethod: { type: 'card', token: 'tok_xxx' }\n    });\n    \n    expect(result.orderId).toBeDefined();\n    expect(orderRepository.save).toHaveBeenCalledWith(\n      expect.objectContaining({ customerId: 'cust-123' })\n    );\n    expect(paymentGateway.charge).toHaveBeenCalledWith(100, expect.any(Object));\n  });\n  \n  it('rejects orders below minimum', async () => {\n    await expect(useCase.execute({\n      customerId: 'cust-123',\n      items: [{ productId: 'prod-1', quantity: 1, price: 5 }],\n      paymentMethod: { type: 'card', token: 'tok_xxx' }\n    })).rejects.toThrow(MinimumOrderError);\n  });\n});", "example": "Mock adapters, test use case logic"},
    {"id": "ca23", "type": "pattern", "name": "DTO and Mapping", "description": "Data Transfer Objects between layers", "pattern": "// DTO for API responses\nclass OrderDTO {\n  id: string;\n  status: string;\n  total: number;\n  items: OrderItemDTO[];\n  createdAt: string;\n}\n\nclass OrderItemDTO {\n  productId: string;\n  productName: string;\n  quantity: number;\n  unitPrice: number;\n  subtotal: number;\n}\n\n// Mapper\nclass OrderMapper {\n  static toDTO(order: Order, products: Map<string, Product>): OrderDTO {\n    return {\n      id: order.id,\n      status: order.status,\n      total: order.total,\n      items: order.items.map(item => ({\n        productId: item.productId,\n        productName: products.get(item.productId)?.name ?? 'Unknown',\n        quantity: item.quantity,\n        unitPrice: item.price,\n        subtotal: item.price * item.quantity\n      })),\n      createdAt: order.createdAt.toISOString()\n    };\n  }\n}", "example": "Transform between layers"},
    {"id": "ca24", "type": "error", "name": "Domain Exceptions", "description": "Business rule violation errors", "pattern": "// Base domain exception\nclass DomainException extends Error {\n  constructor(message: string, public code: string) {\n    super(message);\n    this.name = 'DomainException';\n  }\n}\n\n// Specific domain exceptions\nclass InsufficientFundsException extends DomainException {\n  constructor(public required: Money, public available: Money) {\n    super(`Insufficient funds: need ${required}, have ${available}`, 'INSUFFICIENT_FUNDS');\n  }\n}\n\nclass OrderAlreadyConfirmedException extends DomainException {\n  constructor(orderId: string) {\n    super(`Order ${orderId} is already confirmed`, 'ORDER_ALREADY_CONFIRMED');\n  }\n}\n\nclass ProductOutOfStockException extends DomainException {\n  constructor(productId: string) {\n    super(`Product ${productId} is out of stock`, 'OUT_OF_STOCK');\n  }\n}", "example": "Meaningful business errors"},
    {"id": "ca25", "type": "pattern", "name": "Result Pattern", "description": "Return success or failure explicitly", "pattern": "class Result<T, E = Error> {\n  private constructor(\n    private readonly value: T | null,\n    private readonly error: E | null\n  ) {}\n  \n  static ok<T>(value: T): Result<T, never> {\n    return new Result(value, null);\n  }\n  \n  static fail<E>(error: E): Result<never, E> {\n    return new Result(null, error);\n  }\n  \n  isOk(): boolean { return this.error === null; }\n  isErr(): boolean { return this.error !== null; }\n  \n  unwrap(): T {\n    if (this.error) throw this.error;\n    return this.value as T;\n  }\n  \n  map<U>(fn: (value: T) => U): Result<U, E> {\n    if (this.error) return Result.fail(this.error);\n    return Result.ok(fn(this.value as T));\n  }\n}\n\n// Usage\nasync function createOrder(data): Promise<Result<Order, OrderError>> {\n  if (data.items.length === 0) {\n    return Result.fail(new EmptyOrderError());\n  }\n  const order = new Order(data);\n  return Result.ok(order);\n}", "example": "Explicit error handling without exceptions"},
    {"id": "ca26", "type": "modular", "name": "Module Structure", "description": "Organize code by feature/domain", "pattern": "// Feature-based structure\nsrc/\n  modules/\n    orders/\n      domain/\n        Order.ts\n        OrderItem.ts\n        OrderStatus.ts\n      application/\n        CreateOrderUseCase.ts\n        CancelOrderUseCase.ts\n        OrderRepository.ts\n      infrastructure/\n        PostgresOrderRepository.ts\n        OrderEventPublisher.ts\n      presentation/\n        OrderController.ts\n        OrderDTO.ts\n      index.ts  # Public API of module\n    \n    customers/\n      domain/\n      application/\n      infrastructure/\n      presentation/\n      index.ts", "example": "Vertical slices by domain"},
    {"id": "ca27", "type": "pattern", "name": "Specification Pattern", "description": "Composable business rules", "pattern": "interface Specification<T> {\n  isSatisfiedBy(candidate: T): boolean;\n  and(other: Specification<T>): Specification<T>;\n  or(other: Specification<T>): Specification<T>;\n  not(): Specification<T>;\n}\n\nclass HighValueOrderSpec implements Specification<Order> {\n  constructor(private threshold: number = 1000) {}\n  isSatisfiedBy(order: Order): boolean {\n    return order.total >= this.threshold;\n  }\n}\n\nclass PendingOrderSpec implements Specification<Order> {\n  isSatisfiedBy(order: Order): boolean {\n    return order.status === 'pending';\n  }\n}\n\n// Compose specifications\nconst urgentOrders = new PendingOrderSpec()\n  .and(new HighValueOrderSpec(5000));\n\nconst ordersToProcess = orders.filter(o => urgentOrders.isSatisfiedBy(o));", "example": "Reusable, composable business rules"},
    {"id": "ca28", "type": "pattern", "name": "Event-Driven Domain", "description": "React to domain events", "pattern": "class DomainEventDispatcher {\n  private handlers = new Map<string, Function[]>();\n  \n  register<T extends DomainEvent>(eventType: string, handler: (event: T) => Promise<void>) {\n    const handlers = this.handlers.get(eventType) || [];\n    handlers.push(handler);\n    this.handlers.set(eventType, handlers);\n  }\n  \n  async dispatch(events: DomainEvent[]): Promise<void> {\n    for (const event of events) {\n      const handlers = this.handlers.get(event.constructor.name) || [];\n      await Promise.all(handlers.map(h => h(event)));\n    }\n  }\n}\n\n// Register handlers\ndispatcher.register('OrderConfirmed', async (event: OrderConfirmed) => {\n  await emailService.sendConfirmation(event.orderId);\n});\n\ndispatcher.register('OrderConfirmed', async (event: OrderConfirmed) => {\n  await inventoryService.reserve(event.orderId);\n});", "example": "Decouple with domain events"},
    {"id": "ca29", "type": "pattern", "name": "Guard Clauses", "description": "Validate preconditions early", "pattern": "class Order {\n  addItem(productId: string, quantity: number, price: Money): void {\n    // Guard clauses - fail fast\n    if (!productId) throw new InvalidArgumentException('Product ID required');\n    if (quantity <= 0) throw new InvalidArgumentException('Quantity must be positive');\n    if (price.amount < 0) throw new InvalidArgumentException('Price cannot be negative');\n    if (this.status !== 'draft') throw new OrderAlreadyConfirmedException(this.id);\n    \n    // Main logic after all guards pass\n    const existingItem = this.items.find(i => i.productId === productId);\n    if (existingItem) {\n      existingItem.increaseQuantity(quantity);\n    } else {\n      this.items.push(new OrderItem(productId, quantity, price));\n    }\n  }\n}", "example": "Validate early, reduce nesting"},
    {"id": "ca30", "type": "principle", "name": "Tell Dont Ask", "description": "Tell objects what to do, dont query state", "pattern": "// BAD: Ask then act\nif (order.getStatus() === 'pending' && order.getTotal() > 100) {\n  order.setStatus('approved');\n  sendApprovalEmail(order.getCustomerEmail());\n}\n\n// GOOD: Tell the object\nclass Order {\n  approve(emailService: EmailService): void {\n    if (this.status !== 'pending') {\n      throw new InvalidStateException('Can only approve pending orders');\n    }\n    if (this.total <= 100) {\n      throw new BusinessRuleException('Order below approval threshold');\n    }\n    \n    this.status = 'approved';\n    this.approvedAt = new Date();\n    emailService.sendApproval(this.customerEmail);\n  }\n}\n\n// Usage\norder.approve(emailService);", "example": "Encapsulate behavior in objects"}
  ]
}
