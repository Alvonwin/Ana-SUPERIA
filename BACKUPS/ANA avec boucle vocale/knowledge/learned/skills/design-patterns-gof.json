{
  "category": "design-patterns-gof",
  "version": "1.0.0",
  "generatedBy": "Claude Opus 4.5 - Module de référence pour Ana SUPERIA",
  "skills": [
    {"id": "gof01", "type": "creational", "name": "Singleton Pattern", "description": "Ensure single instance of a class", "pattern": "class Database {\n  static #instance = null;\n  \n  static getInstance() {\n    if (!Database.#instance) {\n      Database.#instance = new Database();\n    }\n    return Database.#instance;\n  }\n  \n  constructor() {\n    if (Database.#instance) throw new Error('Use getInstance()');\n    this.connection = this.connect();\n  }\n}\n\nconst db = Database.getInstance();", "example": "Database connection, config manager"},
    {"id": "gof02", "type": "creational", "name": "Factory Method", "description": "Create objects without specifying class", "pattern": "class NotificationFactory {\n  static create(type, message) {\n    switch (type) {\n      case 'email': return new EmailNotification(message);\n      case 'sms': return new SmsNotification(message);\n      case 'push': return new PushNotification(message);\n      default: throw new Error(`Unknown type: ${type}`);\n    }\n  }\n}\n\nconst notification = NotificationFactory.create('email', 'Hello!');", "example": "Decouple object creation from usage"},
    {"id": "gof03", "type": "creational", "name": "Abstract Factory", "description": "Create families of related objects", "pattern": "class UIFactory {\n  createButton() { throw new Error('Abstract'); }\n  createInput() { throw new Error('Abstract'); }\n}\n\nclass MaterialUIFactory extends UIFactory {\n  createButton() { return new MaterialButton(); }\n  createInput() { return new MaterialInput(); }\n}\n\nclass BootstrapFactory extends UIFactory {\n  createButton() { return new BootstrapButton(); }\n  createInput() { return new BootstrapInput(); }\n}\n\nfunction renderForm(factory) {\n  const button = factory.createButton();\n  const input = factory.createInput();\n}", "example": "Theme/platform-specific UI components"},
    {"id": "gof04", "type": "creational", "name": "Builder Pattern", "description": "Construct complex objects step by step", "pattern": "class QueryBuilder {\n  constructor() {\n    this.query = { select: '*', from: '', where: [], orderBy: null };\n  }\n  \n  select(fields) { this.query.select = fields; return this; }\n  from(table) { this.query.from = table; return this; }\n  where(condition) { this.query.where.push(condition); return this; }\n  orderBy(field, dir = 'ASC') { this.query.orderBy = { field, dir }; return this; }\n  \n  build() {\n    let sql = `SELECT ${this.query.select} FROM ${this.query.from}`;\n    if (this.query.where.length) sql += ` WHERE ${this.query.where.join(' AND ')}`;\n    if (this.query.orderBy) sql += ` ORDER BY ${this.query.orderBy.field} ${this.query.orderBy.dir}`;\n    return sql;\n  }\n}\n\nconst sql = new QueryBuilder().select('name, email').from('users').where('active = true').orderBy('name').build();", "example": "SQL queries, HTTP requests, configs"},
    {"id": "gof05", "type": "creational", "name": "Prototype Pattern", "description": "Clone existing objects", "pattern": "class Document {\n  constructor(title, content, metadata) {\n    this.title = title;\n    this.content = content;\n    this.metadata = metadata;\n  }\n  \n  clone() {\n    return new Document(\n      this.title + ' (copy)',\n      this.content,\n      { ...this.metadata, clonedAt: new Date() }\n    );\n  }\n}\n\nconst template = new Document('Template', '...', { author: 'admin' });\nconst newDoc = template.clone();", "example": "Document templates, game objects"},
    {"id": "gof06", "type": "structural", "name": "Adapter Pattern", "description": "Convert interface to another", "pattern": "// Old payment API\nclass LegacyPaymentGateway {\n  processPayment(amount, cardNumber) { /* ... */ }\n}\n\n// New interface expected\ninterface PaymentProcessor {\n  pay(paymentData: { amount: number; method: PaymentMethod }): Promise<Result>;\n}\n\n// Adapter\nclass LegacyPaymentAdapter implements PaymentProcessor {\n  constructor(private legacy: LegacyPaymentGateway) {}\n  \n  async pay(data) {\n    return this.legacy.processPayment(data.amount, data.method.cardNumber);\n  }\n}", "example": "Integrate legacy systems"},
    {"id": "gof07", "type": "structural", "name": "Decorator Pattern", "description": "Add behavior dynamically", "pattern": "class Coffee {\n  cost() { return 5; }\n  description() { return 'Coffee'; }\n}\n\nclass MilkDecorator {\n  constructor(coffee) { this.coffee = coffee; }\n  cost() { return this.coffee.cost() + 2; }\n  description() { return this.coffee.description() + ' + milk'; }\n}\n\nclass SugarDecorator {\n  constructor(coffee) { this.coffee = coffee; }\n  cost() { return this.coffee.cost() + 1; }\n  description() { return this.coffee.description() + ' + sugar'; }\n}\n\nlet order = new Coffee();\norder = new MilkDecorator(order);\norder = new SugarDecorator(order);\nconsole.log(order.description(), order.cost()); // Coffee + milk + sugar, 8", "example": "Middleware, stream wrappers"},
    {"id": "gof08", "type": "structural", "name": "Facade Pattern", "description": "Simplify complex subsystem", "pattern": "class OrderFacade {\n  constructor() {\n    this.inventory = new InventoryService();\n    this.payment = new PaymentService();\n    this.shipping = new ShippingService();\n    this.notification = new NotificationService();\n  }\n  \n  async placeOrder(order) {\n    await this.inventory.reserve(order.items);\n    await this.payment.charge(order.total);\n    const tracking = await this.shipping.createShipment(order);\n    await this.notification.sendConfirmation(order, tracking);\n    return { success: true, tracking };\n  }\n}\n\n// Simple usage\nconst orderFacade = new OrderFacade();\nawait orderFacade.placeOrder(order);", "example": "Hide complexity behind simple API"},
    {"id": "gof09", "type": "structural", "name": "Proxy Pattern", "description": "Control access to an object", "pattern": "class ImageProxy {\n  constructor(url) {\n    this.url = url;\n    this.realImage = null;\n  }\n  \n  display() {\n    if (!this.realImage) {\n      console.log('Loading image...');\n      this.realImage = new RealImage(this.url);\n    }\n    return this.realImage.display();\n  }\n}\n\n// Cache proxy\nclass CacheProxy {\n  constructor(service) {\n    this.service = service;\n    this.cache = new Map();\n  }\n  \n  async getData(key) {\n    if (this.cache.has(key)) return this.cache.get(key);\n    const data = await this.service.getData(key);\n    this.cache.set(key, data);\n    return data;\n  }\n}", "example": "Lazy loading, caching, access control"},
    {"id": "gof10", "type": "structural", "name": "Composite Pattern", "description": "Tree structures with uniform interface", "pattern": "class FileSystemItem {\n  getSize() { throw new Error('Abstract'); }\n}\n\nclass File extends FileSystemItem {\n  constructor(name, size) {\n    super();\n    this.name = name;\n    this.size = size;\n  }\n  getSize() { return this.size; }\n}\n\nclass Directory extends FileSystemItem {\n  constructor(name) {\n    super();\n    this.name = name;\n    this.children = [];\n  }\n  add(item) { this.children.push(item); }\n  getSize() { return this.children.reduce((sum, child) => sum + child.getSize(), 0); }\n}\n\nconst root = new Directory('root');\nroot.add(new File('a.txt', 100));\nroot.add(new File('b.txt', 200));\nconsole.log(root.getSize()); // 300", "example": "File systems, UI components, menus"},
    {"id": "gof11", "type": "structural", "name": "Bridge Pattern", "description": "Separate abstraction from implementation", "pattern": "// Implementation\nclass Renderer {\n  render(shape) { throw new Error('Abstract'); }\n}\n\nclass SVGRenderer extends Renderer {\n  render(shape) { return `<svg>${shape.toSVG()}</svg>`; }\n}\n\nclass CanvasRenderer extends Renderer {\n  render(shape) { shape.drawOnCanvas(this.ctx); }\n}\n\n// Abstraction\nclass Shape {\n  constructor(renderer) { this.renderer = renderer; }\n  draw() { return this.renderer.render(this); }\n}\n\nclass Circle extends Shape {\n  toSVG() { return `<circle r=\"${this.radius}\"/>`; }\n}\n\nconst circle = new Circle(new SVGRenderer());\ncircle.draw();", "example": "Cross-platform rendering, drivers"},
    {"id": "gof12", "type": "structural", "name": "Flyweight Pattern", "description": "Share common state between objects", "pattern": "class CharacterFlyweight {\n  constructor(font, size, color) {\n    this.font = font;\n    this.size = size;\n    this.color = color;\n  }\n}\n\nclass FlyweightFactory {\n  static cache = new Map();\n  \n  static get(font, size, color) {\n    const key = `${font}-${size}-${color}`;\n    if (!this.cache.has(key)) {\n      this.cache.set(key, new CharacterFlyweight(font, size, color));\n    }\n    return this.cache.get(key);\n  }\n}\n\nclass Character {\n  constructor(char, x, y, style) {\n    this.char = char;\n    this.x = x;\n    this.y = y;\n    this.style = FlyweightFactory.get(style.font, style.size, style.color);\n  }\n}", "example": "Text editors, game particles"},
    {"id": "gof13", "type": "behavioral", "name": "Observer Pattern", "description": "Notify dependents of state changes", "pattern": "class EventEmitter {\n  constructor() {\n    this.listeners = new Map();\n  }\n  \n  on(event, callback) {\n    if (!this.listeners.has(event)) this.listeners.set(event, []);\n    this.listeners.get(event).push(callback);\n    return () => this.off(event, callback);\n  }\n  \n  off(event, callback) {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index > -1) callbacks.splice(index, 1);\n    }\n  }\n  \n  emit(event, data) {\n    const callbacks = this.listeners.get(event) || [];\n    callbacks.forEach(cb => cb(data));\n  }\n}\n\nconst store = new EventEmitter();\nstore.on('userLoggedIn', user => console.log(`Welcome ${user.name}`));", "example": "Event systems, reactive state"},
    {"id": "gof14", "type": "behavioral", "name": "Strategy Pattern", "description": "Swap algorithms at runtime", "pattern": "class PaymentContext {\n  constructor(strategy) {\n    this.strategy = strategy;\n  }\n  \n  setStrategy(strategy) {\n    this.strategy = strategy;\n  }\n  \n  async pay(amount) {\n    return this.strategy.pay(amount);\n  }\n}\n\nclass CreditCardStrategy {\n  async pay(amount) { /* process credit card */ }\n}\n\nclass PayPalStrategy {\n  async pay(amount) { /* process PayPal */ }\n}\n\nclass CryptoStrategy {\n  async pay(amount) { /* process crypto */ }\n}\n\nconst payment = new PaymentContext(new CreditCardStrategy());\npayment.setStrategy(new PayPalStrategy()); // Switch at runtime", "example": "Payment methods, sorting algorithms"},
    {"id": "gof15", "type": "behavioral", "name": "Command Pattern", "description": "Encapsulate requests as objects", "pattern": "class Command {\n  execute() { throw new Error('Abstract'); }\n  undo() { throw new Error('Abstract'); }\n}\n\nclass AddTextCommand extends Command {\n  constructor(editor, text, position) {\n    super();\n    this.editor = editor;\n    this.text = text;\n    this.position = position;\n  }\n  execute() { this.editor.insertAt(this.position, this.text); }\n  undo() { this.editor.deleteAt(this.position, this.text.length); }\n}\n\nclass CommandManager {\n  constructor() { this.history = []; this.redoStack = []; }\n  execute(command) {\n    command.execute();\n    this.history.push(command);\n    this.redoStack = [];\n  }\n  undo() {\n    const cmd = this.history.pop();\n    if (cmd) { cmd.undo(); this.redoStack.push(cmd); }\n  }\n  redo() {\n    const cmd = this.redoStack.pop();\n    if (cmd) { cmd.execute(); this.history.push(cmd); }\n  }\n}", "example": "Undo/redo, task queues"},
    {"id": "gof16", "type": "behavioral", "name": "State Pattern", "description": "Change behavior based on state", "pattern": "class Order {\n  constructor() { this.state = new PendingState(this); }\n  setState(state) { this.state = state; }\n  pay() { this.state.pay(); }\n  ship() { this.state.ship(); }\n  deliver() { this.state.deliver(); }\n}\n\nclass PendingState {\n  constructor(order) { this.order = order; }\n  pay() { console.log('Payment processed'); this.order.setState(new PaidState(this.order)); }\n  ship() { throw new Error('Cannot ship unpaid order'); }\n  deliver() { throw new Error('Cannot deliver unpaid order'); }\n}\n\nclass PaidState {\n  constructor(order) { this.order = order; }\n  pay() { throw new Error('Already paid'); }\n  ship() { console.log('Order shipped'); this.order.setState(new ShippedState(this.order)); }\n  deliver() { throw new Error('Must ship first'); }\n}", "example": "Order workflow, UI state machines"},
    {"id": "gof17", "type": "behavioral", "name": "Template Method", "description": "Define algorithm skeleton, defer steps", "pattern": "class DataProcessor {\n  process(data) {\n    const validated = this.validate(data);\n    const transformed = this.transform(validated);\n    const result = this.save(transformed);\n    this.notify(result);\n    return result;\n  }\n  \n  validate(data) { return data; } // Override\n  transform(data) { throw new Error('Must implement'); }\n  save(data) { throw new Error('Must implement'); }\n  notify(result) { console.log('Done'); } // Optional override\n}\n\nclass UserProcessor extends DataProcessor {\n  validate(data) { if (!data.email) throw new Error('Email required'); return data; }\n  transform(data) { return { ...data, createdAt: new Date() }; }\n  save(data) { return db.users.insert(data); }\n}", "example": "ETL pipelines, test frameworks"},
    {"id": "gof18", "type": "behavioral", "name": "Chain of Responsibility", "description": "Pass request along handler chain", "pattern": "class Handler {\n  setNext(handler) { this.next = handler; return handler; }\n  handle(request) {\n    if (this.next) return this.next.handle(request);\n    return null;\n  }\n}\n\nclass AuthHandler extends Handler {\n  handle(request) {\n    if (!request.token) return { error: 'Unauthorized' };\n    request.user = verifyToken(request.token);\n    return super.handle(request);\n  }\n}\n\nclass ValidationHandler extends Handler {\n  handle(request) {\n    if (!request.body.email) return { error: 'Email required' };\n    return super.handle(request);\n  }\n}\n\nconst chain = new AuthHandler();\nchain.setNext(new ValidationHandler()).setNext(new ProcessHandler());\nchain.handle(request);", "example": "Middleware, request processing"},
    {"id": "gof19", "type": "behavioral", "name": "Mediator Pattern", "description": "Centralize complex communications", "pattern": "class ChatRoom {\n  constructor() { this.users = new Map(); }\n  \n  register(user) {\n    this.users.set(user.name, user);\n    user.chatRoom = this;\n  }\n  \n  send(message, from, to) {\n    if (to) {\n      // Private message\n      this.users.get(to)?.receive(message, from);\n    } else {\n      // Broadcast\n      this.users.forEach((user, name) => {\n        if (name !== from) user.receive(message, from);\n      });\n    }\n  }\n}\n\nclass User {\n  constructor(name) { this.name = name; }\n  send(message, to) { this.chatRoom.send(message, this.name, to); }\n  receive(message, from) { console.log(`${from} -> ${this.name}: ${message}`); }\n}", "example": "Chat rooms, air traffic control"},
    {"id": "gof20", "type": "behavioral", "name": "Iterator Pattern", "description": "Sequential access without exposing structure", "pattern": "class TreeIterator {\n  constructor(root) {\n    this.stack = root ? [root] : [];\n  }\n  \n  hasNext() { return this.stack.length > 0; }\n  \n  next() {\n    const node = this.stack.pop();\n    if (node.right) this.stack.push(node.right);\n    if (node.left) this.stack.push(node.left);\n    return node.value;\n  }\n  \n  [Symbol.iterator]() {\n    return {\n      next: () => this.hasNext() \n        ? { value: this.next(), done: false }\n        : { done: true }\n    };\n  }\n}\n\nfor (const value of new TreeIterator(tree)) {\n  console.log(value);\n}", "example": "Tree traversal, pagination"},
    {"id": "gof21", "type": "behavioral", "name": "Visitor Pattern", "description": "Add operations without modifying classes", "pattern": "class Element {\n  accept(visitor) { throw new Error('Abstract'); }\n}\n\nclass TextElement extends Element {\n  constructor(text) { super(); this.text = text; }\n  accept(visitor) { return visitor.visitText(this); }\n}\n\nclass ImageElement extends Element {\n  constructor(src) { super(); this.src = src; }\n  accept(visitor) { return visitor.visitImage(this); }\n}\n\nclass HTMLExportVisitor {\n  visitText(el) { return `<p>${el.text}</p>`; }\n  visitImage(el) { return `<img src=\"${el.src}\"/>`; }\n}\n\nclass MarkdownExportVisitor {\n  visitText(el) { return el.text; }\n  visitImage(el) { return `![](${el.src})`; }\n}\n\nconst doc = [new TextElement('Hello'), new ImageElement('pic.jpg')];\nconst html = doc.map(el => el.accept(new HTMLExportVisitor())).join('');", "example": "Export formats, code analysis"},
    {"id": "gof22", "type": "behavioral", "name": "Memento Pattern", "description": "Save and restore object state", "pattern": "class EditorMemento {\n  constructor(content) { this.content = content; this.timestamp = new Date(); }\n}\n\nclass Editor {\n  constructor() { this.content = ''; }\n  \n  type(text) { this.content += text; }\n  \n  save() { return new EditorMemento(this.content); }\n  \n  restore(memento) { this.content = memento.content; }\n}\n\nclass History {\n  constructor() { this.snapshots = []; }\n  push(memento) { this.snapshots.push(memento); }\n  pop() { return this.snapshots.pop(); }\n}\n\nconst editor = new Editor();\nconst history = new History();\n\neditor.type('Hello');\nhistory.push(editor.save());\neditor.type(' World');\neditor.restore(history.pop()); // Back to 'Hello'", "example": "Undo systems, game saves"},
    {"id": "gof23", "type": "behavioral", "name": "Interpreter Pattern", "description": "Define grammar and interpret expressions", "pattern": "class Expression {\n  interpret(context) { throw new Error('Abstract'); }\n}\n\nclass NumberExpression extends Expression {\n  constructor(value) { super(); this.value = value; }\n  interpret() { return this.value; }\n}\n\nclass AddExpression extends Expression {\n  constructor(left, right) { super(); this.left = left; this.right = right; }\n  interpret(ctx) { return this.left.interpret(ctx) + this.right.interpret(ctx); }\n}\n\nclass VariableExpression extends Expression {\n  constructor(name) { super(); this.name = name; }\n  interpret(ctx) { return ctx[this.name]; }\n}\n\n// 5 + x\nconst expr = new AddExpression(\n  new NumberExpression(5),\n  new VariableExpression('x')\n);\nconsole.log(expr.interpret({ x: 10 })); // 15", "example": "DSLs, rule engines, calculators"},
    {"id": "gof24", "type": "modern", "name": "Dependency Injection", "description": "Inject dependencies externally", "pattern": "class UserService {\n  constructor(userRepository, emailService, logger) {\n    this.userRepository = userRepository;\n    this.emailService = emailService;\n    this.logger = logger;\n  }\n  \n  async createUser(data) {\n    const user = await this.userRepository.create(data);\n    await this.emailService.sendWelcome(user);\n    this.logger.info('User created', { userId: user.id });\n    return user;\n  }\n}\n\n// DI Container\nconst container = new Container();\ncontainer.register('logger', () => new Logger());\ncontainer.register('userRepository', () => new UserRepository());\ncontainer.register('emailService', () => new EmailService());\ncontainer.register('userService', (c) => new UserService(\n  c.resolve('userRepository'),\n  c.resolve('emailService'),\n  c.resolve('logger')\n));", "example": "Testable, loosely coupled code"},
    {"id": "gof25", "type": "modern", "name": "Repository Pattern", "description": "Abstract data access layer", "pattern": "class UserRepository {\n  constructor(db) { this.db = db; }\n  \n  async findById(id) {\n    return this.db.query('SELECT * FROM users WHERE id = ?', [id]);\n  }\n  \n  async findByEmail(email) {\n    return this.db.query('SELECT * FROM users WHERE email = ?', [email]);\n  }\n  \n  async create(data) {\n    const result = await this.db.query('INSERT INTO users SET ?', data);\n    return this.findById(result.insertId);\n  }\n  \n  async update(id, data) {\n    await this.db.query('UPDATE users SET ? WHERE id = ?', [data, id]);\n    return this.findById(id);\n  }\n  \n  async delete(id) {\n    return this.db.query('DELETE FROM users WHERE id = ?', [id]);\n  }\n}", "example": "Data access abstraction"},
    {"id": "gof26", "type": "modern", "name": "Unit of Work", "description": "Track changes and commit atomically", "pattern": "class UnitOfWork {\n  constructor(db) {\n    this.db = db;\n    this.newEntities = [];\n    this.dirtyEntities = [];\n    this.removedEntities = [];\n  }\n  \n  registerNew(entity) { this.newEntities.push(entity); }\n  registerDirty(entity) { this.dirtyEntities.push(entity); }\n  registerRemoved(entity) { this.removedEntities.push(entity); }\n  \n  async commit() {\n    await this.db.transaction(async (tx) => {\n      for (const e of this.newEntities) await tx.insert(e);\n      for (const e of this.dirtyEntities) await tx.update(e);\n      for (const e of this.removedEntities) await tx.delete(e);\n    });\n    this.clear();\n  }\n  \n  clear() {\n    this.newEntities = [];\n    this.dirtyEntities = [];\n    this.removedEntities = [];\n  }\n}", "example": "ORM change tracking"},
    {"id": "gof27", "type": "modern", "name": "Specification Pattern", "description": "Encapsulate business rules as objects", "pattern": "class Specification {\n  isSatisfiedBy(candidate) { throw new Error('Abstract'); }\n  and(other) { return new AndSpecification(this, other); }\n  or(other) { return new OrSpecification(this, other); }\n  not() { return new NotSpecification(this); }\n}\n\nclass PremiumUserSpec extends Specification {\n  isSatisfiedBy(user) { return user.subscription === 'premium'; }\n}\n\nclass ActiveUserSpec extends Specification {\n  isSatisfiedBy(user) { return user.status === 'active'; }\n}\n\nclass AndSpecification extends Specification {\n  constructor(left, right) { super(); this.left = left; this.right = right; }\n  isSatisfiedBy(candidate) {\n    return this.left.isSatisfiedBy(candidate) && this.right.isSatisfiedBy(candidate);\n  }\n}\n\nconst eligibleForDiscount = new PremiumUserSpec().and(new ActiveUserSpec());\nusers.filter(u => eligibleForDiscount.isSatisfiedBy(u));", "example": "Complex business rules"},
    {"id": "gof28", "type": "modern", "name": "Null Object Pattern", "description": "Provide default behavior for null", "pattern": "class Logger {\n  log(message) { console.log(message); }\n  error(message) { console.error(message); }\n}\n\nclass NullLogger {\n  log(message) {} // Do nothing\n  error(message) {}\n}\n\nclass UserService {\n  constructor(logger = new NullLogger()) {\n    this.logger = logger;\n  }\n  \n  async createUser(data) {\n    this.logger.log('Creating user...');\n    const user = await this.repo.create(data);\n    this.logger.log(`User created: ${user.id}`);\n    return user;\n  }\n}\n\n// No null checks needed\nconst service = new UserService(); // Uses NullLogger", "example": "Avoid null checks, default behavior"},
    {"id": "gof29", "type": "modern", "name": "Object Pool", "description": "Reuse expensive objects", "pattern": "class ConnectionPool {\n  constructor(maxSize = 10) {\n    this.maxSize = maxSize;\n    this.available = [];\n    this.inUse = new Set();\n  }\n  \n  async acquire() {\n    let conn = this.available.pop();\n    if (!conn && this.inUse.size < this.maxSize) {\n      conn = await this.createConnection();\n    }\n    if (!conn) {\n      // Wait for available connection\n      conn = await this.waitForConnection();\n    }\n    this.inUse.add(conn);\n    return conn;\n  }\n  \n  release(conn) {\n    this.inUse.delete(conn);\n    this.available.push(conn);\n  }\n  \n  async createConnection() {\n    return new DatabaseConnection();\n  }\n}", "example": "Database connections, thread pools"},
    {"id": "gof30", "type": "modern", "name": "Service Locator", "description": "Central registry for services", "pattern": "class ServiceLocator {\n  static services = new Map();\n  \n  static register(name, service) {\n    this.services.set(name, service);\n  }\n  \n  static get(name) {\n    const service = this.services.get(name);\n    if (!service) throw new Error(`Service not found: ${name}`);\n    return service;\n  }\n}\n\n// Registration\nServiceLocator.register('logger', new Logger());\nServiceLocator.register('db', new Database());\n\n// Usage\nconst logger = ServiceLocator.get('logger');\nconst db = ServiceLocator.get('db');", "example": "Simple DI alternative (use sparingly)"}
  ]
}
