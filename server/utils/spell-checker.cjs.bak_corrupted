/**
 * French Spell Checker Module for Ana
 * Uses nspell with French Hunspell dictionary
 *
 * @module spell-checker
 * @description Corrects spelling errors in Ana's responses
 */

const nspell = require('nspell');

let spellChecker = null;
let isInitialized = false;

/**
 * Initialize the French spell checker
 * @returns {Promise<void>}
 */
async function initialize() {
  if (isInitialized) return;

  try {
    // Dynamic import for ESM module dictionary-fr
    const dictionary = await import('dictionary-fr');
    const dict = dictionary.default;

    // dictionary-fr exports { aff, dic } directly as Buffers
    spellChecker = nspell(dict);
    isInitialized = true;
    console.log('Correcteur orthographique francais initialise');
  } catch (error) {
    console.error('Erreur import dictionary-fr:', error.message);
    throw error;
  }
}

/**
 * Check if a word is spelled correctly
 * @param {string} word - Word to check
 * @returns {boolean} True if correct
 */
function isCorrect(word) {
  if (!spellChecker) return true;
  return spellChecker.correct(word);
}

/**
 * Get spelling suggestions for a word
 * @param {string} word - Misspelled word
 * @returns {string[]} Array of suggestions
 */
function suggest(word) {
  if (!spellChecker) return [];
  return spellChecker.suggest(word);
}

/**
 * Correct spelling in a text
 * @param {string} text - Text to correct
 * @returns {string} Corrected text
 */
function correctText(text) {
  if (!text) return text;

  // === PROTECTION DES CHEMINS DE FICHIERS (FIX 2025-12-16) ===
  // Les chemins comme C:/Users/niwno/Desktop ne doivent PAS etre corriges
  const pathPlaceholders = [];
  const pathPattern = /([A-Za-z]:[\x2F\x5C][^\s\"'<>|*?]+)/g;
  text = text.replace(pathPattern, (match) => {
    const placeholder = '__PATH_' + pathPlaceholders.length + '__';
    pathPlaceholders.push(match);
    return placeholder;
  });

  // === PROTECTION DES EXTENSIONS DE FICHIERS (FIX 2025-12-16) ===
  // Les extensions comme .txt, .cjs, .json ne doivent PAS etre corrigees
  const extPlaceholders = [];
  const extPattern = /\.(txt|cjs|js|json|md|html|css|py|sh|bat|xml|yaml|yml|csv|log|ini|cfg|conf|exe|dll|zip|tar|gz|jpg|jpeg|png|gif|svg|pdf|doc|docx|xls|xlsx)\b/gi;
  text = text.replace(extPattern, (match) => {
    const placeholder = '__EXT_' + extPlaceholders.length + '__';
    extPlaceholders.push(match);
    return placeholder;
  });

  // === CORRECTIONS CONTEXTUELLES (erreurs LLM connues) ===
  text = text.replace(/puisage/gi, 'puis-je');
  text = text.replace(/ajoure['']?fui/gi, "aujourd'hui");
  text = text.replace(/connecte/g, 'connectee');
  text = text.replace(/Anna/g, 'Ana');
  text = text.replace(/astuce/gi, 'est-ce');

  // Si pas de dictionnaire, restaurer les chemins et retourner
  if (!spellChecker) {
    pathPlaceholders.forEach((path, i) => {
      text = text.replace('__PATH_' + i + '__', path);
    });
    return text;
  }

  // Split text into words while preserving punctuation and whitespace
  const wordPattern = /([a-zA-ZÀ-ÿ'-]+)|([^a-zA-ZÀ-ÿ'-]+)/g;
  const tokens = text.match(wordPattern) || [];

  const correctedTokens = tokens.map(token => {
    if (!/^[a-zA-ZÀ-ÿ'-]+$/.test(token)) {
      return token;
    }
    if (token.length <= 2) {
      return token;
    }
    if (/^[A-ZÀ-Ý]/.test(token) && token.length > 1) {
      return token;
    }
    if (spellChecker.correct(token)) {
      return token;
    }
    const suggestions = spellChecker.suggest(token);
    if (suggestions.length > 0) {
      const suggestion = suggestions[0];
      if (isSimilarEnough(token, suggestion)) {
        return suggestion;
      }
    }
    return token;
  });

  // Restaurer les chemins de fichiers
  let result = correctedTokens.join('');
  pathPlaceholders.forEach((path, i) => {
    result = result.replace('__PATH_' + i + '__', path);
  });
  
  // Restaurer les extensions de fichiers
  extPlaceholders.forEach((ext, i) => {
    result = result.replace('__EXT_' + i + '__', ext);
  });

  return result;
}

function isSimilarEnough(original, suggestion) {
  const distance = levenshteinDistance(original.toLowerCase(), suggestion.toLowerCase());
  const maxLength = Math.max(original.length, suggestion.length);
  const similarity = 1 - (distance / maxLength);
  return similarity >= 0.6;
}

function levenshteinDistance(a, b) {
  const matrix = [];
  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1,
          matrix[i][j - 1] + 1,
          matrix[i - 1][j] + 1
        );
      }
    }
  }
  return matrix[b.length][a.length];
}

function getStatus() {
  return {
    initialized: isInitialized,
    language: 'fr',
    ready: spellChecker !== null
  };
}

module.exports = {
  initialize,
  isCorrect,
  suggest,
  correctText,
  getStatus
};
