/**
 * Tool Agent - Agent avec Tool Calling pour Ana
 * FIX 2025-12-05:
 *   1. DIR fiable (fs.readdir au lieu de spawn cmd.exe)
 *   2. System prompt avec liste d'outils explicite
 *
 * CrÃ©Ã©: 2 DÃ©cembre 2025
 * Source: Perplexity recommendation
 */

const axios = require('axios');
const WebTools = require('../tools/web-tools.cjs');
const FileTools = require('../tools/file-tools.cjs');
const BashTools = require('../tools/bash-tools.cjs');

// V2 Core Modules - Added 2025-12-07
const {
  createLoopController,
  selfCorrection,
  createContextManager,
  LOOP_CONFIG
} = require('../core/index.cjs');

const OLLAMA_URL = 'http://localhost:11434';
const DEFAULT_MODEL = 'qwen2.5-coder:7b';

/**
 * FIX 2025-12-08: Parse tool calls - supports multiple LLM formats
 * - Standard JSON: {"name": "tool", "arguments": {...}}
 * - GLM-4 format: "tool_name\n{}" or "tool_name\n{args}"
 * - Tool name alone: "get_time" (for no-arg tools)
 */
function findToolCallJSON(content) {
  const results = [];

  // Liste des outils valides
  const validToolNames = [
    'web_search', 'get_weather', 'get_time', 'read_file', 'write_file',
    'list_files', 'run_shell', 'edit_file', 'grep', 'save_memory',
    'search_memory', 'ask_groq', 'ask_cerebras', 'execute_code',
    'http_request', 'json_parse', 'generate_image', 'describe_image',
    'research_topic', 'youtube_search', 'get_yt_transcript',
    'get_news', 'wikipedia_search', 'convert_units'
  ];

  // FORMAT 1: GLM-4 style "tool_name\n{args}"
  for (const toolName of validToolNames) {
    // Pattern: tool_name suivi de newline et JSON object
    const glm4Regex = new RegExp(toolName + '\\s*\\n\\s*(\\{[\\s\\S]*?\\})', 'g');
    let match;
    while ((match = glm4Regex.exec(content)) !== null) {
      try {
        const args = JSON.parse(match[1]);
        const toolCall = JSON.stringify({ name: toolName, arguments: args });
        if (!results.includes(toolCall)) {
          results.push(toolCall);
          console.log(`[Parser] GLM-4 format: ${toolName}`);
        }
      } catch (e) {
        const toolCall = JSON.stringify({ name: toolName, arguments: {} });
        if (!results.includes(toolCall)) {
          results.push(toolCall);
          console.log(`[Parser] GLM-4 format (empty): ${toolName}`);
        }
      }
    }

    // Pattern: tool_name seul (pas suivi de JSON)
    const soloRegex = new RegExp('(?:^|\\n)\\s*' + toolName + '\\s*(?:\\n|$)', 'g');
    while ((match = soloRegex.exec(content)) !== null) {
      const toolCall = JSON.stringify({ name: toolName, arguments: {} });
      if (!results.includes(toolCall)) {
        results.push(toolCall);
        console.log(`[Parser] Solo tool: ${toolName}`);
      }
    }
  }

  // FORMAT 2: Standard JSON {"name": "...", "arguments": {...}}
  let startIdx = 0;
  while ((startIdx = content.indexOf('{', startIdx)) !== -1) {
    let depth = 0;
    let endIdx = startIdx;

    for (let i = startIdx; i < content.length; i++) {
      if (content[i] === '{') depth++;
      if (content[i] === '}') {
        depth--;
        if (depth === 0) {
          endIdx = i;
          break;
        }
      }
    }

    if (depth === 0 && endIdx > startIdx) {
      const candidate = content.substring(startIdx, endIdx + 1);
      try {
        const parsed = JSON.parse(candidate);
        if (parsed.name && typeof parsed.arguments !== 'undefined') {
          if (!results.includes(candidate)) {
            results.push(candidate);
          }
        }
      } catch (e) {
        // Pas du JSON valide
      }
    }
    startIdx++;
  }

  return results;
}

// 1) DÃ©finition des outils cÃ´tÃ© LLM (schÃ©mas JSON)
const TOOL_DEFINITIONS = [
  {
    type: 'function',
    function: {
      name: 'web_search',
      description: 'Recherche d\'information gÃ©nÃ©rale sur le web (DuckDuckGo).',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'RequÃªte de recherche en texte libre.' },
          limit: { type: 'integer', description: 'Nombre max de rÃ©sultats', default: 5 }
        },
        required: ['query']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_weather',
      description: 'Obtenir la mÃ©tÃ©o actuelle pour une ville donnÃ©e.',
      parameters: {
        type: 'object',
        properties: {
          location: { type: 'string', description: 'Ville ou lieu, ex: "Longueuil".' },
          lang: { type: 'string', description: 'Langue de la rÃ©ponse mÃ©tÃ©o', default: 'fr' }
        },
        required: ['location']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_time',
      description: 'Obtenir l\'heure et la date actuelles du systÃ¨me.',
      parameters: {
        type: 'object',
        properties: {
          timezone: { type: 'string', description: 'Fuseau horaire (ex: "America/Montreal")', default: 'America/Montreal' }
        },
        required: []
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'read_file',
      description: 'Lire un fichier texte sur le disque.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' },
          limit: { type: 'integer', description: 'Longueur max du contenu retournÃ©', default: 4000 }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'search_in_file',
      description: 'Rechercher un pattern (regex) dans un fichier et retourner les lignes correspondantes avec contexte. UTILISE CET OUTIL pour analyser de gros fichiers au lieu de read_file. Parfait pour trouver des fonctions, routes API, dÃ©finitions, etc.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier Ã  analyser.' },
          pattern: { type: 'string', description: 'Pattern regex Ã  rechercher (ex: "app\\.get|app\\.post" pour routes Express).' },
          context_lines: { type: 'integer', description: 'Nombre de lignes de contexte avant/aprÃ¨s chaque match.', default: 1 }
        },
        required: ['path', 'pattern']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'read_file_chunk',
      description: 'Lire une portion spÃ©cifique d\'un fichier (lignes X Ã  Y). Utile pour les gros fichiers quand tu connais la zone Ã  examiner.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' },
          start_line: { type: 'integer', description: 'NumÃ©ro de ligne de dÃ©but (1-based).', default: 1 },
          end_line: { type: 'integer', description: 'NumÃ©ro de ligne de fin (1-based).', default: 100 }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'file_info',
      description: 'Obtenir des informations sur un fichier (taille, nombre de lignes, type). UTILISE AVANT read_file pour savoir si le fichier est trop gros.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'write_file',
      description: 'Ã‰crire du contenu dans un fichier.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' },
          content: { type: 'string', description: 'Contenu Ã  Ã©crire.' }
        },
        required: ['path', 'content']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'list_files',
      description: 'Lister les fichiers d\'un rÃ©pertoire.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin du rÃ©pertoire.' },
          recursive: { type: 'boolean', description: 'Inclure sous-dossiers', default: false }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'run_shell',
      description: 'ExÃ©cuter une commande shell.',
      parameters: {
        type: 'object',
        properties: {
          command: { type: 'string', description: 'Commande shell Ã  exÃ©cuter.' },
          timeout: { type: 'integer', description: 'Timeout en ms', default: 10000 }
        },
        required: ['command']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'web_fetch',
      description: 'RÃ©cupÃ©rer le contenu d\'une page web.',
      parameters: {
        type: 'object',
        properties: {
          url: { type: 'string', description: 'URL de la page Ã  rÃ©cupÃ©rer.' },
          selector: { type: 'string', description: 'SÃ©lecteur CSS optionnel pour extraire une partie.' }
        },
        required: ['url']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'wikipedia',
      description: 'Rechercher sur Wikipedia FR.',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Terme Ã  rechercher.' }
        },
        required: ['query']
      }
    }
  },
  // === CLOUD LLM TOOLS ===
  {
    type: 'function',
    function: {
      name: 'ask_groq',
      description: 'Poser une question complexe Ã  Groq (ultra-rapide, Llama 70B). Pour raisonnement avancÃ©, recherches, analyses.',
      parameters: {
        type: 'object',
        properties: {
          question: { type: 'string', description: 'Question Ã  poser Ã  Groq.' },
          model: { type: 'string', enum: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'], description: 'ModÃ¨le Groq', default: 'llama-3.3-70b-versatile' }
        },
        required: ['question']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'ask_cerebras',
      description: 'Poser une question Ã  Cerebras (le plus rapide du monde, ~1000 tok/s). Pour tÃ¢ches critiques, coding, math.',
      parameters: {
        type: 'object',
        properties: {
          question: { type: 'string', description: 'Question Ã  poser Ã  Cerebras.' },
          model: { type: 'string', enum: ['llama3.1-8b', 'llama3.1-70b'], description: 'ModÃ¨le Cerebras', default: 'llama3.1-8b' }
        },
        required: ['question']
      }
    }
  },
  // === MEMORY SEARCH TOOL ===
  {
    type: 'function',
    function: {
      name: 'search_memory',
      description: 'Rechercher dans ma mÃ©moire des conversations passÃ©es avec Alain. Utiliser quand Alain demande "tu te rappelles?", "on avait parlÃ© de...", "cherche dans ta mÃ©moire".',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Ce que je cherche dans ma mÃ©moire (mots-clÃ©s, sujet, nom).' },
          limit: { type: 'integer', description: 'Nombre max de rÃ©sultats', default: 5 }
        },
        required: ['query']
      }
    }
  },
  // === SAVE MEMORY TOOL ===
  {
    type: 'function',
    function: {
      name: 'save_memory',
      description: 'Sauvegarder une information importante en memoire pour m en souvenir plus tard. Utiliser quand Alain dit souviens-toi, retiens ca, n oublie pas.',
      parameters: {
        type: 'object',
        properties: {
          content: { type: 'string', description: 'L information a memoriser.' },
          category: { type: 'string', description: 'Categorie du souvenir (fait, preference, projet, etc.)', default: 'general' }
        },
        required: ['content']
      }
    }
  },
  // === EDIT FILE TOOL ===
  {
    type: 'function',
    function: {
      name: 'edit_file',
      description: 'Modifier un fichier en remplaÃ§ant une chaÃ®ne par une autre sans rÃ©Ã©crire tout le fichier.',
      parameters: {
        type: 'object',
        properties: {
          file_path: { type: 'string', description: 'Chemin absolu du fichier Ã  modifier' },
          old_string: { type: 'string', description: 'Texte exact Ã  remplacer' },
          new_string: { type: 'string', description: 'Nouveau texte' },
          replace_all: { type: 'boolean', description: 'Remplacer toutes les occurrences', default: false }
        },
        required: ['file_path', 'old_string', 'new_string']
      }
    }
  },
  // === GLOB TOOL ===
  {
    type: 'function',
    function: {
      name: 'glob',
      description: 'Trouver des fichiers par pattern (ex: *.js, **/*.ts, src/**/*.cjs)',
      parameters: {
        type: 'object',
        properties: {
          pattern: { type: 'string', description: 'Pattern glob (ex: **/*.js)' },
          path: { type: 'string', description: 'Dossier de recherche (dÃ©faut: E:/ANA)', default: 'E:/ANA' }
        },
        required: ['pattern']
      }
    }
  },
  // === GREP TOOL ===
  {
    type: 'function',
    function: {
      name: 'grep',
      description: 'Chercher du texte ou regex dans les fichiers',
      parameters: {
        type: 'object',
        properties: {
          pattern: { type: 'string', description: 'Texte ou regex Ã  chercher' },
          path: { type: 'string', description: 'Fichier ou dossier oÃ¹ chercher', default: 'E:/ANA' },
          glob: { type: 'string', description: 'Filtrer par pattern de fichiers (ex: *.js)' },
          ignore_case: { type: 'boolean', description: 'Ignorer la casse', default: false }
        },
        required: ['pattern']
      }
    }
  },
  // === ASK USER TOOL ===
  {
    type: 'function',
    function: {
      name: 'ask_user',
      description: 'Poser une question Ã  Alain et attendre sa rÃ©ponse',
      parameters: {
        type: 'object',
        properties: {
          question: { type: 'string', description: 'La question Ã  poser Ã  Alain' },
          options: { type: 'array', items: { type: 'string' }, description: 'Options de rÃ©ponse (optionnel)' }
        },
        required: ['question']
      }
    }
  },
  // === RUN BACKGROUND TOOL ===
  {
    type: 'function',
    function: {
      name: 'run_background',
      description: 'ExÃ©cuter une commande en arriÃ¨re-plan (pour tÃ¢ches longues)',
      parameters: {
        type: 'object',
        properties: {
          command: { type: 'string', description: 'Commande Ã  exÃ©cuter' },
          working_dir: { type: 'string', description: 'Dossier de travail', default: 'E:/ANA' }
        },
        required: ['command']
      }
    }
  },
  // === KILL PROCESS TOOL ===
  {
    type: 'function',
    function: {
      name: 'kill_process',
      description: 'ArrÃªter un processus par son PID ou nom',
      parameters: {
        type: 'object',
        properties: {
          pid: { type: 'integer', description: 'PID du processus' },
          name: { type: 'string', description: 'Nom du processus (ex: node.exe)' }
        }
      }
    }
  },
  // === TODO WRITE TOOL ===
  {
    type: 'function',
    function: {
      name: 'todo_write',
      description: 'GÃ©rer ma liste de tÃ¢ches persistante',
      parameters: {
        type: 'object',
        properties: {
          action: { type: 'string', enum: ['add', 'complete', 'list', 'clear'], description: 'Action Ã  effectuer' },
          task: { type: 'string', description: 'Description de la tÃ¢che (pour add)' },
          task_id: { type: 'integer', description: 'ID de la tÃ¢che (pour complete)' }
        },
        required: ['action']
      }
    }
  },
  // === NOTEBOOK EDIT TOOL ===
  {
    type: 'function',
    function: {
      name: 'notebook_edit',
      description: 'Ã‰diter un notebook Jupyter (.ipynb)',
      parameters: {
        type: 'object',
        properties: {
          notebook_path: { type: 'string', description: 'Chemin du notebook' },
          cell_index: { type: 'integer', description: 'Index de la cellule (0-based)' },
          new_source: { type: 'string', description: 'Nouveau contenu de la cellule' },
          action: { type: 'string', enum: ['replace', 'insert', 'delete'], default: 'replace' }
        },
        required: ['notebook_path', 'cell_index']
      }
    }
  },
  // === PLAN MODE TOOL ===
  {
    type: 'function',
    function: {
      name: 'plan_mode',
      description: 'Entrer en mode planification pour tÃ¢ches complexes',
      parameters: {
        type: 'object',
        properties: {
          action: { type: 'string', enum: ['enter', 'exit'], description: 'Entrer ou sortir du mode plan' },
          plan_file: { type: 'string', description: 'Fichier oÃ¹ sauvegarder le plan' }
        },
        required: ['action']
      }
    }
  },

  // === 4 NOUVEAUX OUTILS PARITÃ‰ CLAUDE CODE - 2025-12-08 ===
  {
    type: 'function',
    function: {
      name: 'execute_code',
      description: 'ExÃ©cuter du code Python et retourner le rÃ©sultat.',
      parameters: {
        type: 'object',
        properties: {
          code: { type: 'string', description: 'Code Python Ã  exÃ©cuter' },
          language: { type: 'string', description: 'Langage (python par dÃ©faut)', default: 'python' }
        },
        required: ['code']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'generate_image',
      description: 'GÃ©nÃ©rer une image Ã  partir d\'un prompt texte via ComfyUI.',
      parameters: {
        type: 'object',
        properties: {
          prompt: { type: 'string', description: 'Description de l\'image Ã  gÃ©nÃ©rer' },
          negative_prompt: { type: 'string', description: 'Ce qu\'on ne veut pas voir', default: '' },
          width: { type: 'integer', description: 'Largeur', default: 512 },
          height: { type: 'integer', description: 'Hauteur', default: 512 }
        },
        required: ['prompt']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'http_request',
      description: 'Faire une requÃªte HTTP GET/POST vers une URL.',
      parameters: {
        type: 'object',
        properties: {
          url: { type: 'string', description: 'URL cible' },
          method: { type: 'string', enum: ['GET', 'POST', 'PUT', 'DELETE'], default: 'GET' },
          headers: { type: 'object', description: 'Headers HTTP' },
          body: { type: 'string', description: 'Corps de la requÃªte (POST/PUT)' }
        },
        required: ['url']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_yt_transcript',
      description: 'Obtenir la transcription d\'une vidÃ©o YouTube.',
      parameters: {
        type: 'object',
        properties: {
          video_url: { type: 'string', description: 'URL de la vidÃ©o YouTube' },
          language: { type: 'string', description: 'Langue prÃ©fÃ©rÃ©e', default: 'fr' }
        },
        required: ['video_url']
      }
    }
  },
  // === LAUNCH AGENT TOOL ===
  {
    type: 'function',
    function: {
      name: 'launch_agent',
      description: 'Lancer un sous-agent spÃ©cialisÃ© pour une tÃ¢che',
      parameters: {
        type: 'object',
        properties: {
          agent_type: { type: 'string', enum: ['research', 'code', 'explore', 'plan'], description: 'Type d\'agent' },
          task: { type: 'string', description: 'TÃ¢che Ã  accomplir' },
          context: { type: 'string', description: 'Contexte additionnel' }
        },
        required: ['agent_type', 'task']
      }
    }
  }
];

// 2) Mapping des outils â†’ fonctions Node rÃ©elles
const TOOL_IMPLEMENTATIONS = {
  async web_search(args) {
    const { query, limit } = args;
    console.log(`ðŸ”§ [ToolAgent] web_search: "${query}"`);
    const result = await WebTools.search(query, { limit: limit || 5 });
    return result;
  },

  async get_weather(args) {
    const { location, lang } = args;
    console.log(`ðŸ”§ [ToolAgent] get_weather: "${location}"`);
    const result = await WebTools.weather(location, { lang: lang || 'fr' });
    return result;
  },

  async get_time(args) {
    const { timezone } = args;
    console.log(`ðŸ”§ [ToolAgent] get_time`);
    const now = new Date();
    const options = {
      timeZone: timezone || 'America/Montreal',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    };
    return {
      success: true,
      datetime: now.toLocaleString('fr-CA', options),
      iso: now.toISOString(),
      timestamp: now.getTime(),
      timezone: timezone || 'America/Montreal'
    };
  },

  async read_file(args) {
    const { path, limit } = args;
    console.log(`ðŸ”§ [ToolAgent] read_file: "${path}"`);
    const res = await FileTools.read(path, { encoding: 'utf-8', limit: limit || 4000 });
    return {
      success: res.success,
      path: res.path,
      content: res.content,
      error: res.error
    };
  },

  async search_in_file(args) {
    const { path: filePath, pattern, context_lines = 1 } = args;
    console.log(`ðŸ”§ [ToolAgent] search_in_file: "${filePath}" pattern="${pattern}"`);

    try {
      const fs = require('fs');
      if (!fs.existsSync(filePath)) {
        return { success: false, error: `Fichier non trouvÃ©: ${filePath}` };
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');
      const regex = new RegExp(pattern, 'gi');
      const matches = [];

      lines.forEach((line, index) => {
        if (regex.test(line)) {
          // Collecter les lignes de contexte
          const startLine = Math.max(0, index - context_lines);
          const endLine = Math.min(lines.length - 1, index + context_lines);

          const contextBlock = [];
          for (let i = startLine; i <= endLine; i++) {
            const prefix = i === index ? '>>> ' : '    ';
            contextBlock.push(`${prefix}${i + 1}: ${lines[i]}`);
          }

          matches.push({
            line_number: index + 1,
            content: line.trim(),
            context: contextBlock.join('\n')
          });
        }
        // Reset regex lastIndex pour les patterns globaux
        regex.lastIndex = 0;
      });

      return {
        success: true,
        path: filePath,
        pattern: pattern,
        total_matches: matches.length,
        matches: matches.slice(0, 100), // Limiter Ã  100 rÃ©sultats max
        message: `TrouvÃ© ${matches.length} correspondance(s) pour "${pattern}"`
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async read_file_chunk(args) {
    const { path: filePath, start_line = 1, end_line = 100 } = args;
    console.log(`ðŸ”§ [ToolAgent] read_file_chunk: "${filePath}" lines ${start_line}-${end_line}`);

    try {
      const fs = require('fs');
      if (!fs.existsSync(filePath)) {
        return { success: false, error: `Fichier non trouvÃ©: ${filePath}` };
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');
      const totalLines = lines.length;

      // Ajuster les bornes
      const start = Math.max(1, start_line) - 1; // Convert to 0-based
      const end = Math.min(totalLines, end_line);

      const chunk = lines.slice(start, end);
      const numberedChunk = chunk.map((line, i) => `${start + i + 1}: ${line}`).join('\n');

      return {
        success: true,
        path: filePath,
        start_line: start + 1,
        end_line: end,
        total_lines: totalLines,
        content: numberedChunk,
        message: `Lignes ${start + 1}-${end} sur ${totalLines} total`
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async file_info(args) {
    const { path: filePath } = args;
    console.log(`ðŸ”§ [ToolAgent] file_info: "${filePath}"`);

    try {
      const fs = require('fs');
      const pathModule = require('path');

      if (!fs.existsSync(filePath)) {
        return { success: false, error: `Fichier non trouvÃ©: ${filePath}` };
      }

      const stats = fs.statSync(filePath);
      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n').length;
      const ext = pathModule.extname(filePath).toLowerCase();

      // DÃ©terminer le type
      const codeExtensions = ['.js', '.cjs', '.mjs', '.ts', '.py', '.java', '.cpp', '.c', '.h', '.cs', '.go', '.rs', '.rb', '.php'];
      const textExtensions = ['.txt', '.md', '.json', '.xml', '.yaml', '.yml', '.csv', '.log', '.ini', '.cfg'];

      let fileType = 'binary';
      if (codeExtensions.includes(ext)) fileType = 'code';
      else if (textExtensions.includes(ext)) fileType = 'text';

      // Recommandation
      let recommendation = 'read_file';
      if (lines > 500) {
        recommendation = 'search_in_file ou read_file_chunk';
      }

      return {
        success: true,
        path: filePath,
        size_bytes: stats.size,
        size_readable: stats.size > 1024 * 1024
          ? `${(stats.size / 1024 / 1024).toFixed(2)} MB`
          : stats.size > 1024
            ? `${(stats.size / 1024).toFixed(2)} KB`
            : `${stats.size} bytes`,
        lines: lines,
        extension: ext,
        type: fileType,
        is_large: lines > 500,
        recommendation: recommendation,
        modified: stats.mtime.toISOString()
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async write_file(args) {
    const { path, content } = args;
    console.log(`ðŸ”§ [ToolAgent] write_file: "${path}"`);
    const res = await FileTools.write(path, content, { backup: true });
    return res;
  },

  async list_files(args) {
    const { path, recursive } = args;
    console.log(`ðŸ”§ [ToolAgent] list_files: "${path}"`);
    const res = await FileTools.list(path, { recursive: recursive || false, details: true });
    return res;
  },

  // FIX 2025-12-05: run_shell avec redirection DIR vers fs.readdir
  async run_shell(args) {
    const { command, timeout } = args;
    console.log(`ðŸ”§ [ToolAgent] run_shell: "${command}"`);

    // FIX: Commande "dir" redirigÃ©e vers FileTools.list (plus fiable que spawn cmd.exe)
    const dirMatch = command.match(/^dir\s+(.+)$/i);
    if (dirMatch) {
      const dirPath = dirMatch[1].replace(/["']/g, '').replace(/\//g, '\\').trim();
      console.log(`ðŸ”§ [ToolAgent] Redirection dir -> FileTools.list: "${dirPath}"`);
      const res = await FileTools.list(dirPath, { recursive: false, details: true });
      if (res.success) {
        // Format similaire Ã  dir Windows
        const output = res.entries.map(e => {
          const type = e.isDirectory ? '<DIR>' : e.size.toString().padStart(12);
          return `${e.modified || ''}  ${type}  ${e.name}`;
        }).join('\n');
        return {
          success: true,
          stdout: output,
          entries: res.entries,
          count: res.count,
          method: 'fs.readdir (fiable)'
        };
      }
      return res;
    }

    // Autres commandes: BashTools
    const res = await BashTools.execute(command, { timeout: timeout || 10000 });
    return res;
  },

  async web_fetch(args) {
    const { url, selector } = args;
    console.log(`ðŸ”§ [ToolAgent] web_fetch: "${url}"`);
    const res = await WebTools.fetch(url, { selector });
    return res;
  },

  async wikipedia(args) {
    const { query } = args;
    console.log(`ðŸ”§ [ToolAgent] wikipedia: "${query}"`);
    const res = await WebTools.wikipedia(query);
    return res;
  },

  // === CLOUD LLM IMPLEMENTATIONS ===
  async ask_groq(args) {
    const { question, prompt, model = 'llama-3.3-70b-versatile' } = args;
    const q = question || prompt || '';
    if (!q) {
      return { success: false, error: 'ParamÃ¨tre question ou prompt requis', provider: 'groq' };
    }
    console.log(`ðŸ”§ [ToolAgent] ask_groq: "${q.substring(0, 50)}..."`);
    const groqService = require('../services/groq-service.cjs');
    const result = await groqService.chat(q, { model });
    return {
      success: result.success,
      provider: 'groq',
      model,
      answer: result.response || result.error,
      tokens: result.usage?.total_tokens || 0,
      latencyMs: result.latencyMs
    };
  },

  async ask_cerebras(args) {
    const { question, prompt, model = 'llama3.1-8b' } = args;
    const q = question || prompt || '';
    if (!q) {
      return { success: false, error: 'ParamÃ¨tre question ou prompt requis', provider: 'cerebras' };
    }
    console.log(`ðŸ”§ [ToolAgent] ask_cerebras: "${q.substring(0, 50)}..."`);
    const cerebrasService = require('../services/cerebras-service.cjs');
    const result = await cerebrasService.chat(q, { model });
    return {
      success: result.success,
      provider: 'cerebras',
      model,
      answer: result.response || result.error,
      tokens: result.usage?.total_tokens || 0,
      latencyMs: result.latencyMs
    };
  },

  // === MEMORY SEARCH IMPLEMENTATION ===
  async search_memory(args) {
    const { query, limit = 5 } = args;
    console.log(`ðŸ§  [ToolAgent] search_memory: "${query}"`);

    const fs = require('fs');
    const path = require('path');
    const results = [];

    // 1. Recherche dans le fichier de conversation Ana (texte simple)
    const conversationPath = 'E:/ANA/memory/current_conversation_ana.txt';
    if (fs.existsSync(conversationPath)) {
      try {
        const content = fs.readFileSync(conversationPath, 'utf-8');
        const lines = content.split('\n');
        const queryLower = query.toLowerCase();
        const matches = [];

        for (let i = 0; i < lines.length; i++) {
          if (lines[i].toLowerCase().includes(queryLower)) {
            // Inclure contexte (2 lignes avant/aprÃ¨s)
            const start = Math.max(0, i - 2);
            const end = Math.min(lines.length, i + 3);
            const context = lines.slice(start, end).join('\n');
            matches.push({
              lineNumber: i + 1,
              context: context.substring(0, 400)
            });
            if (matches.length >= limit) break;
          }
        }

        if (matches.length > 0) {
          results.push({
            source: 'ana_conversation_file',
            matchCount: matches.length,
            matches: matches
          });
        }
      } catch (err) {
        console.log(`âš ï¸ [search_memory] Text search error: ${err.message}`);
      }
    }

    // 2. Recherche dans TieredMemory (ChromaDB sÃ©mantique) si disponible
    try {
      const TieredMemory = require('../memory/tiered-memory.cjs');
      if (TieredMemory && TieredMemory.initialized) {
        const semanticResults = await TieredMemory.search(query, { limit });
        if (semanticResults && semanticResults.length > 0) {
          results.push({
            source: 'chromadb_semantic',
            matchCount: semanticResults.length,
            matches: semanticResults.map(r => ({
              document: r.document?.substring(0, 400),
              tier: r.tier,
              distance: r.distance
            }))
          });
        }
      }
    } catch (err) {
      // TieredMemory pas dispo, continuer sans
      console.log(`âš ï¸ [search_memory] ChromaDB skipped: ${err.message}`);
    }

    // 3. RÃ©sultat formatÃ© pour Ana
    const totalMatches = results.reduce((sum, r) => sum + r.matchCount, 0);

    return {
      success: true,
      query: query,
      found: totalMatches > 0,
      totalMatches: totalMatches,
      sources: results,
      message: totalMatches > 0
        ? `J'ai trouvÃ© ${totalMatches} souvenir(s) correspondant Ã  "${query}".`
        : `Je n'ai rien trouvÃ© pour "${query}" dans ma mÃ©moire.`
    };
  },

  // === SAVE MEMORY IMPLEMENTATION ===
  async save_memory(args) {
    const { content, category = 'general' } = args;
    console.log();
    
    const fs = require('fs');
    const path = require('path');
    
    // Dossier de memoire Ana
    const memoryDir = 'E:/ANA/memory';
    if (!fs.existsSync(memoryDir)) {
      fs.mkdirSync(memoryDir, { recursive: true });
    }
    
    // Fichier de memoire principale
    const memoryFile = path.join(memoryDir, 'ana_memories.json');
    let memories = [];
    
    if (fs.existsSync(memoryFile)) {
      try {
        memories = JSON.parse(fs.readFileSync(memoryFile, 'utf-8'));
      } catch (e) {
        memories = [];
      }
    }
    
    // Ajouter le nouveau souvenir
    const memory = {
      id: Date.now().toString(),
      content: content,
      category: category,
      timestamp: new Date().toISOString(),
      source: 'user_request'
    };
    
    memories.push(memory);
    
    // Sauvegarder
    fs.writeFileSync(memoryFile, JSON.stringify(memories, null, 2), 'utf-8');
    
    // Aussi ajouter au fichier de conversation
    const convFile = path.join(memoryDir, 'current_conversation_ana.txt');
    const line = '[MEMOIRE ' + new Date().toISOString() + '] [' + category + '] ' + content + '\n';
    fs.appendFileSync(convFile, line, 'utf-8');

    return {
      success: true,
      message: 'J\'ai memorise: ' + content.substring(0, 100),
      id: memory.id,
      category: category
    };
  },

  // === 10 NEW TOOL IMPLEMENTATIONS ===

  async edit_file(args) {
    const { file_path, old_string, new_string, replace_all = false } = args;
    console.log(`ðŸ”§ [ToolAgent] edit_file: "${file_path}"`);
    const fs = require('fs');
    try {
      if (!fs.existsSync(file_path)) {
        return { success: false, error: `Fichier non trouvÃ©: ${file_path}` };
      }
      const content = fs.readFileSync(file_path, 'utf-8');
      if (!content.includes(old_string)) {
        return { success: false, error: 'ChaÃ®ne Ã  remplacer non trouvÃ©e dans le fichier' };
      }
      const newContent = replace_all
        ? content.split(old_string).join(new_string)
        : content.replace(old_string, new_string);
      fs.writeFileSync(file_path, newContent, 'utf-8');
      return { success: true, message: 'Fichier modifiÃ© avec succÃ¨s' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async glob(args) {
    const { pattern, path: searchPath = 'E:/ANA' } = args;
    console.log(`ðŸ”§ [ToolAgent] glob: "${pattern}" in "${searchPath}"`);
    const fs = require('fs');
    const pathModule = require('path');

    function globToRegex(glob) {
      let escaped = glob.replace(/\./g, '\\.').replace(/\*/g, '.*').replace(/\?/g, '.');
      return new RegExp(escaped, 'i');
    }

    function walkDir(dir, regex, results, depth) {
      if (depth > 10 || results.length >= 50) return;
      try {
        const items = fs.readdirSync(dir, { withFileTypes: true });
        for (const item of items) {
          if (results.length >= 50) break;
          const fullPath = pathModule.join(dir, item.name);
          if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
            walkDir(fullPath, regex, results, depth + 1);
          } else if (item.isFile() && regex.test(item.name)) {
            results.push(fullPath.replace(/\\/g, '/'));
          }
        }
      } catch (e) { /* ignore permission errors */ }
    }

    try {
      const normalizedPath = searchPath.replace(/\\/g, '/');
      if (!fs.existsSync(normalizedPath)) {
        return { success: false, error: 'Dossier non trouvÃ©: ' + normalizedPath, files: [] };
      }
      const regex = globToRegex(pattern);
      const files = [];
      walkDir(normalizedPath, regex, files, 0);
      return { success: true, files, count: files.length, pattern, searchPath: normalizedPath };
    } catch (err) {
      return { success: false, error: err.message, files: [] };
    }
  },

  async grep(args) {
    const { pattern, path: searchPath = 'E:/ANA', glob: fileGlob, ignore_case = false } = args;
    console.log(`ðŸ”§ [ToolAgent] grep: "${pattern}" in "${searchPath}"`);
    const fs = require('fs');
    const pathModule = require('path');
    const matches = [];

    const regex = new RegExp(pattern, ignore_case ? 'gi' : 'g');
    const fileRegex = fileGlob ? new RegExp(fileGlob.replace(/\*/g, '.*').replace(/\?/g, '.'), 'i') : null;

    function searchFile(filePath) {
      try {
        const content = fs.readFileSync(filePath, 'utf-8');
        const lines = content.split('\n');
        lines.forEach((line, idx) => {
          if (regex.test(line)) {
            matches.push(filePath.replace(/\\/g, '/') + ':' + (idx + 1) + ':' + line.substring(0, 200));
          }
        });
      } catch (e) { /* ignore binary/permission errors */ }
    }

    function walkDir(dir, depth) {
      if (depth > 10 || matches.length >= 30) return;
      try {
        const items = fs.readdirSync(dir, { withFileTypes: true });
        for (const item of items) {
          if (matches.length >= 30) break;
          const fullPath = pathModule.join(dir, item.name);
          if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
            walkDir(fullPath, depth + 1);
          } else if (item.isFile()) {
            if (!fileRegex || fileRegex.test(item.name)) {
              searchFile(fullPath);
            }
          }
        }
      } catch (e) { /* ignore permission errors */ }
    }

    try {
      const normalizedPath = searchPath.replace(/\\/g, '/');
      const stat = fs.statSync(normalizedPath);
      if (stat.isFile()) {
        searchFile(normalizedPath);
      } else {
        walkDir(normalizedPath, 0);
      }
      return { success: true, matches, count: matches.length };
    } catch (err) {
      return { success: false, error: err.message, matches: [] };
    }
  },

  async ask_user(args) {
    const { question, options } = args;
    console.log(`ðŸ”§ [ToolAgent] ask_user: "${question}"`);
    // Pour l'instant, retourne une indication qu'Ana attend une rÃ©ponse
    // L'intÃ©gration rÃ©elle avec l'interface viendra plus tard
    return {
      success: true,
      waiting: true,
      question: question,
      options: options || [],
      message: `J'attends la rÃ©ponse d'Alain Ã : "${question}"`
    };
  },

  async run_background(args) {
    const { command, working_dir = 'E:/ANA' } = args;
    console.log(`ðŸ”§ [ToolAgent] run_background: "${command}"`);
    const { spawn } = require('child_process');
    try {
      const child = spawn(command, [], {
        shell: true,
        cwd: working_dir,
        detached: true,
        stdio: 'ignore'
      });
      child.unref();
      return { success: true, pid: child.pid, message: `Commande lancÃ©e en arriÃ¨re-plan (PID: ${child.pid})` };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async kill_process(args) {
    const { pid, name } = args;
    console.log(`ðŸ”§ [ToolAgent] kill_process: PID=${pid}, name=${name}`);
    const { execSync } = require('child_process');
    try {
      if (pid) {
        execSync(`taskkill /PID ${pid} /F`, { encoding: 'utf-8' });
        return { success: true, message: `Processus ${pid} arrÃªtÃ©` };
      } else if (name) {
        execSync(`taskkill /IM ${name} /F`, { encoding: 'utf-8' });
        return { success: true, message: `Processus ${name} arrÃªtÃ©` };
      }
      return { success: false, error: 'PID ou nom requis' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async todo_write(args) {
    const { action, task, task_id, todos } = args;

    // Support du format todos array (comme Claude Code)
    if (todos && Array.isArray(todos)) {
      console.log(`ðŸ”§ [ToolAgent] todo_write: mise Ã  jour de ${todos.length} tÃ¢ches`);
      const fs = require('fs');
      const todoPath = 'E:/ANA/memory/ana_todos.json';
      const formattedTodos = todos.map((t, i) => ({
        id: Date.now() + i,
        task: t.content || t.task || t.description || 'Sans titre',
        status: t.status || 'pending',
        activeForm: t.activeForm || '',
        created: new Date().toISOString()
      }));
      fs.writeFileSync(todoPath, JSON.stringify(formattedTodos, null, 2));
      return { success: true, message: `${todos.length} tÃ¢ches enregistrÃ©es`, todos: formattedTodos };
    }

    console.log(`ðŸ”§ [ToolAgent] todo_write: ${action}`);
    const fs = require('fs');
    const todoPath = 'E:/ANA/memory/ana_todos.json';

    try {
      let todos = [];
      if (fs.existsSync(todoPath)) {
        todos = JSON.parse(fs.readFileSync(todoPath, 'utf-8'));
      }

      switch (action) {
        case 'add':
          todos.push({ id: Date.now(), task, status: 'pending', created: new Date().toISOString() });
          fs.writeFileSync(todoPath, JSON.stringify(todos, null, 2));
          return { success: true, message: `TÃ¢che ajoutÃ©e: "${task}"`, todos };
        case 'complete':
          const todo = todos.find(t => t.id === task_id);
          if (todo) {
            todo.status = 'completed';
            todo.completed = new Date().toISOString();
            fs.writeFileSync(todoPath, JSON.stringify(todos, null, 2));
            return { success: true, message: `TÃ¢che ${task_id} complÃ©tÃ©e`, todos };
          }
          return { success: false, error: `TÃ¢che ${task_id} non trouvÃ©e` };
        case 'list':
          return { success: true, todos };
        case 'clear':
          fs.writeFileSync(todoPath, '[]');
          return { success: true, message: 'Liste de tÃ¢ches vidÃ©e' };
        default:
          return { success: false, error: `Action inconnue: ${action}` };
      }
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async notebook_edit(args) {
    const { notebook_path, cell_index, new_source, action = 'replace' } = args;
    console.log(`ðŸ”§ [ToolAgent] notebook_edit: "${notebook_path}" cell ${cell_index}`);
    const fs = require('fs');
    try {
      if (!fs.existsSync(notebook_path)) {
        return { success: false, error: `Notebook non trouvÃ©: ${notebook_path}` };
      }
      const notebook = JSON.parse(fs.readFileSync(notebook_path, 'utf-8'));

      if (action === 'replace' && notebook.cells[cell_index]) {
        notebook.cells[cell_index].source = new_source.split('\n');
      } else if (action === 'insert') {
        notebook.cells.splice(cell_index, 0, {
          cell_type: 'code',
          source: new_source.split('\n'),
          metadata: {},
          outputs: []
        });
      } else if (action === 'delete' && notebook.cells[cell_index]) {
        notebook.cells.splice(cell_index, 1);
      }

      fs.writeFileSync(notebook_path, JSON.stringify(notebook, null, 2));
      return { success: true, message: `Notebook modifiÃ© (${action} cell ${cell_index})` };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async plan_mode(args) {
    const { action, plan_file } = args;
    console.log(`ðŸ”§ [ToolAgent] plan_mode: ${action}`);
    const fs = require('fs');
    const defaultPlanFile = 'E:/ANA/memory/current_plan.md';
    const filePath = plan_file || defaultPlanFile;

    if (action === 'enter') {
      return {
        success: true,
        mode: 'planning',
        plan_file: filePath,
        message: 'Mode planification activÃ©. Je vais explorer et planifier avant d\'agir.'
      };
    } else if (action === 'exit') {
      return {
        success: true,
        mode: 'execution',
        message: 'Mode planification terminÃ©. PrÃªt Ã  exÃ©cuter.'
      };
    }
    return { success: false, error: `Action inconnue: ${action}` };
  },



  // === 4 NOUVEAUX OUTILS PARITÃ‰ CLAUDE CODE - 2025-12-08 ===

  async execute_code(args) {
    const { code, language = 'python' } = args;
    console.log(`ðŸ”§ [ToolAgent] execute_code: ${language}`);
    const { spawn } = require('child_process');

    return new Promise((resolve) => {
      let output = '';
      let errorOutput = '';

      const proc = spawn('python', ['-c', code], {
        timeout: 30000,
        cwd: 'E:/ANA/temp'
      });

      proc.stdout.on('data', (data) => { output += data.toString(); });
      proc.stderr.on('data', (data) => { errorOutput += data.toString(); });

      proc.on('close', (exitCode) => {
        resolve({
          success: exitCode === 0,
          output: output.trim(),
          error: errorOutput.trim(),
          exitCode
        });
      });

      proc.on('error', (err) => {
        resolve({ success: false, error: err.message });
      });

      // Timeout
      setTimeout(() => {
        proc.kill();
        resolve({ success: false, error: 'Timeout aprÃ¨s 30 secondes' });
      }, 30000);
    });
  },

  async generate_image(args) {
    const { prompt, negative_prompt = '', width = 512, height = 512 } = args;
    console.log(`ðŸ”§ [ToolAgent] generate_image: "${prompt.substring(0, 50)}..."`);

    // VÃ©rifier si ComfyUI tourne
    const axios = require('axios');
    try {
      await axios.get('http://127.0.0.1:8188/system_stats', { timeout: 2000 });
    } catch (e) {
      return {
        success: false,
        error: 'ComfyUI n\'est pas dÃ©marrÃ©. Lance ComfyUI d\'abord.',
        suggestion: 'DÃ©marre ComfyUI depuis E:/AI_Tools/ComfyUI'
      };
    }

    // CrÃ©er le workflow basique
    const workflow = {
      prompt: {
        "3": {
          "class_type": "KSampler",
          "inputs": {
            "seed": Math.floor(Math.random() * 1000000),
            "steps": 20,
            "cfg": 7,
            "sampler_name": "euler",
            "scheduler": "normal",
            "denoise": 1,
            "model": ["4", 0],
            "positive": ["6", 0],
            "negative": ["7", 0],
            "latent_image": ["5", 0]
          }
        },
        "4": { "class_type": "CheckpointLoaderSimple", "inputs": { "ckpt_name": "sd_xl_base_1.0.safetensors" } },
        "5": { "class_type": "EmptyLatentImage", "inputs": { "width": width, "height": height, "batch_size": 1 } },
        "6": { "class_type": "CLIPTextEncode", "inputs": { "text": prompt, "clip": ["4", 1] } },
        "7": { "class_type": "CLIPTextEncode", "inputs": { "text": negative_prompt, "clip": ["4", 1] } },
        "8": { "class_type": "VAEDecode", "inputs": { "samples": ["3", 0], "vae": ["4", 2] } },
        "9": { "class_type": "SaveImage", "inputs": { "filename_prefix": "ana_generated", "images": ["8", 0] } }
      }
    };

    try {
      const response = await axios.post('http://127.0.0.1:8188/prompt', workflow);
      return {
        success: true,
        message: 'Image en cours de gÃ©nÃ©ration',
        prompt_id: response.data.prompt_id,
        output_dir: 'E:/AI_Tools/ComfyUI/output'
      };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async http_request(args) {
    const { url, method = 'GET', headers = {}, body } = args;
    console.log(`ðŸ”§ [ToolAgent] http_request: ${method} ${url}`);
    const axios = require('axios');

    try {
      const config = {
        method: method.toLowerCase(),
        url,
        headers,
        timeout: 30000
      };

      if (body && (method === 'POST' || method === 'PUT')) {
        config.data = body;
      }

      const response = await axios(config);
      return {
        success: true,
        status: response.status,
        headers: response.headers,
        data: typeof response.data === 'object' ? JSON.stringify(response.data, null, 2) : response.data
      };
    } catch (err) {
      return {
        success: false,
        error: err.message,
        status: err.response?.status
      };
    }
  },

  async get_yt_transcript(args) {
    const { video_url, language = 'fr' } = args;
    console.log(`ðŸ”§ [ToolAgent] get_yt_transcript: ${video_url}`);

    // Extraire l'ID de la vidÃ©o
    const videoIdMatch = video_url.match(/(?:v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
    if (!videoIdMatch) {
      return { success: false, error: 'URL YouTube invalide' };
    }
    const videoId = videoIdMatch[1];

    // Utiliser l'API YouTube pour obtenir les sous-titres
    const axios = require('axios');
    try {
      // Essayer de rÃ©cupÃ©rer via un service gratuit
      const response = await axios.get(`https://www.youtube.com/watch?v=${videoId}`, {
        headers: { 'User-Agent': 'Mozilla/5.0' }
      });

      // Chercher les captions dans la page
      const captionMatch = response.data.match(/"captionTracks":\[(.*?)\]/);
      if (!captionMatch) {
        return { success: false, error: 'Pas de sous-titres disponibles pour cette vidÃ©o' };
      }

      // Parser et retourner les infos
      return {
        success: true,
        videoId,
        message: 'Sous-titres disponibles',
        note: 'Pour la transcription complÃ¨te, utilise un service comme youtubetranscript.com'
      };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async launch_agent(args) {
    const { agent_type, task, context } = args;
    console.log(`ðŸ”§ [ToolAgent] launch_agent: ${agent_type} - "${task}"`);
    // Simulation - l'intÃ©gration rÃ©elle viendra plus tard
    return {
      success: true,
      agent_type,
      task,
      context,
      status: 'launched',
      message: `Agent ${agent_type} lancÃ© pour: "${task}"`
    };
  }
};

// 3) Boucle agent (multi-turn tools)
async function runToolAgent(userMessage, options = {}) {
  const maxLoops = options.maxLoops || 10;
  const model = options.model || DEFAULT_MODEL;
  let loopCount = 0;

  // FIX 2025-12-05: System prompt avec liste d'outils EXPLICITE et rÃ¨gles claires
  const toolNames = TOOL_DEFINITIONS.map(t => t.function.name).join(', ');
  const systemPrompt = options.systemPrompt ||
    `Tu es Ana, l'assistante IA personnelle d'Alain Ã  Longueuil, QuÃ©bec.
LANGUE: Tu rÃ©ponds TOUJOURS en franÃ§ais quÃ©bÃ©cois. JAMAIS en anglais.

OUTILS DISPONIBLES: ${toolNames}

RÃˆGLES D'UTILISATION DES OUTILS:
- Si Alain demande l'heure â†’ appelle get_time
- Si Alain demande la mÃ©tÃ©o â†’ appelle get_weather
- Si Alain dit "cherche sur le web" â†’ appelle web_search
- Si Alain dit "demande Ã  Groq" â†’ appelle ask_groq
- Si Alain dit "demande Ã  Cerebras" â†’ appelle ask_cerebras
- Si Alain demande de lister un dossier â†’ appelle list_files ou run_shell
- Si Alain demande de lire un fichier â†’ appelle read_file
- Si Alain demande "tu te rappelles" â†’ appelle search_memory
- Si Alain dit "exÃ©cute ce code" ou "print(" â†’ appelle execute_code
- Si Alain dit "gÃ©nÃ¨re une image" â†’ appelle generate_image
- Si Alain dit "requÃªte http" ou "GET/POST" â†’ appelle http_request
- Si Alain dit "transcris" une vidÃ©o YouTube â†’ appelle get_yt_transcript
- Si Alain demande de modifier un fichier â†’ appelle edit_file

RÃˆGLES CRITIQUES:
1. Pour appeler un outil, rÃ©ponds EXACTEMENT avec ce format JSON, RIEN D'AUTRE:
{"name": "nom_outil", "arguments": {...}}

2. AUCUN texte avant ou aprÃ¨s le JSON quand tu appelles un outil.
3. AprÃ¨s avoir reÃ§u le rÃ©sultat de l'outil, RÃ‰PONDS TOUJOURS EN FRANÃ‡AIS.
4. NE DIS JAMAIS "je ne peux pas" si un outil peut t'aider - UTILISE L'OUTIL.
5. IMPORTANT: MÃªme si les donnÃ©es sont en anglais, traduis ta rÃ©ponse en franÃ§ais.
6. Pour web_search: Presente CHAQUE resultat avec son titre en lien markdown [Titre](url) SUIVI d'un resume/description du contenu.`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userMessage }
  ];

  console.log(`ðŸ¤– [ToolAgent] DÃ©marrage - Message: "${userMessage.substring(0, 50)}..."`);

  while (loopCount < maxLoops) {
    loopCount++;
    console.log(`ðŸ”„ [ToolAgent] Boucle ${loopCount}/${maxLoops}`);

    try {
      const response = await axios.post(`${OLLAMA_URL}/api/chat`, {
        model: model,
        messages: messages,
        tools: TOOL_DEFINITIONS,
        stream: false,
        options: {
          repeat_penalty: 1.2,      // PÃ©nalise les rÃ©pÃ©titions (best practice anti-loop)
          frequency_penalty: 0.5,    // RÃ©duit les mots frÃ©quemment utilisÃ©s
          presence_penalty: 0.3      // Encourage la diversitÃ©
        }
      });

      const msg = response.data.message || response.data;
      let toolCalls = msg.tool_calls || [];

      // FIX: Parser JSON brut dans content si pas de tool_calls structurÃ©s
      // Bug connu Ollama: Qwen2.5-coder retourne {"name":..., "arguments":...} dans content
      // au lieu de msg.tool_calls structurÃ©s.
      if ((!toolCalls || toolCalls.length === 0) && msg.content) {
        const content = msg.content.trim();
        console.log(`ðŸ” [ToolAgent] Parsing content: "${content.substring(0, 100)}..."`);

        // FIX 2025-12-03: Utiliser la nouvelle mÃ©thode avec comptage de parenthÃ¨ses
        // L'ancienne regex ne gÃ©rait pas les objets vides {} dans "arguments"
        const jsonBlocks = findToolCallJSON(content);

        for (const block of jsonBlocks) {
          try {
            const parsed = JSON.parse(block);
            // VÃ©rifier structure valide tool call (arguments peut Ãªtre {})
            if (parsed.name && typeof parsed.arguments !== 'undefined' && TOOL_IMPLEMENTATIONS[parsed.name]) {
              toolCalls.push({
                function: {
                  name: parsed.name,
                  arguments: parsed.arguments || parsed.args || {}
                }
              });
              console.log(`âœ… [ToolAgent] Parsed tool: ${parsed.name}`);
            }
          } catch (e) {
            console.log(`âš ï¸ [ToolAgent] Invalid JSON block: ${block.substring(0, 100)}...`);
          }
        }

        if (toolCalls.length > 0) {
          console.log(`ðŸ”§ [ToolAgent] Found ${toolCalls.length} tool calls:`, toolCalls.map(tc => tc.function.name));
        }

        // Fallback: regex pour <tool_call>JSON</tool_call>
        if (toolCalls.length === 0) {
          const jsonMatch = content.match(/<tool_call>\s*(\{[\s\S]*?\})\s*<\/tool_call>/i);
          if (jsonMatch) {
            try {
              const parsed = JSON.parse(jsonMatch[1]);
              if (parsed.name && TOOL_IMPLEMENTATIONS[parsed.name]) {
                console.log(`âœ… [ToolAgent] XML tag parsÃ©: ${parsed.name}`);
                toolCalls = [{
                  function: {
                    name: parsed.name,
                    arguments: parsed.arguments || {}
                  }
                }];
              }
            } catch (e) {
              console.log(`âš ï¸ [ToolAgent] XML parse failed: ${e.message}`);
            }
          }
        }
      }

      // Aucun tool_call â†’ rÃ©ponse finale
      if (!toolCalls || toolCalls.length === 0) {
        const finalAnswer = msg.content || '';
        console.log(`âœ… [ToolAgent] RÃ©ponse finale (${finalAnswer.length} chars)`);

        messages.push({
          role: 'assistant',
          content: finalAnswer
        });

        return {
          success: true,
          answer: finalAnswer,
          messages: messages,
          loopsUsed: loopCount,
          model: model
        };
      }

      // Il y a des tool_calls â†’ on les exÃ©cute
      console.log(`ðŸ”§ [ToolAgent] ${toolCalls.length} tool(s) Ã  exÃ©cuter`);

      for (const tc of toolCalls) {
        const toolName = tc.function?.name;
        const rawArgs = tc.function?.arguments || {};
        let parsedArgs = rawArgs;

        if (typeof rawArgs === 'string') {
          try {
            parsedArgs = JSON.parse(rawArgs);
          } catch {
            parsedArgs = {};
          }
        }

        const impl = TOOL_IMPLEMENTATIONS[toolName];
        if (!impl) {
          console.warn(`âš ï¸ [ToolAgent] Outil inconnu: ${toolName}`);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({
              error: `Outil "${toolName}" non implÃ©mentÃ©.`
            })
          });
          continue;
        }

        try {
          const result = await impl(parsedArgs);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify(result)
          });
          console.log(`âœ… [ToolAgent] ${toolName} exÃ©cutÃ© avec succÃ¨s`);
        } catch (err) {
          console.error(`âŒ [ToolAgent] Erreur ${toolName}:`, err.message);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({
              error: err.message || 'Erreur pendant l\'exÃ©cution'
            })
          });
        }
      }

    } catch (error) {
      console.error(`âŒ [ToolAgent] Erreur Ollama:`, error.message);
      return {
        success: false,
        error: error.message,
        messages: messages,
        loopsUsed: loopCount
      };
    }
  }

  // Max loops atteint
  console.warn(`âš ï¸ [ToolAgent] Max loops (${maxLoops}) atteint`);
  return {
    success: false,
    error: `Nombre maximum de boucles (${maxLoops}) atteint sans rÃ©ponse finale.`,
    messages: messages,
    loopsUsed: loopCount
  };
}

// ============================================================
// V2 TOOL AGENT - With LoopController, SelfCorrection, ContextManager
// Added 2025-12-07 - Does NOT replace runToolAgent, ADDS new version
// ============================================================

/**
 * V2 Tool Agent - Boucle autonome avec contrÃ´leurs avancÃ©s
 * @param {string} userMessage - Message utilisateur
 * @param {object} options - Options avancÃ©es
 * @param {number} options.timeoutMs - Timeout global (dÃ©faut: 10 min)
 * @param {boolean} options.useSelfCorrection - Activer auto-correction (dÃ©faut: true)
 * @param {boolean} options.useContextManager - Activer gestion contexte (dÃ©faut: true)
 * @returns {Promise<object>} RÃ©sultat
 */
async function runToolAgentV2(userMessage, options = {}) {
  const model = options.model || DEFAULT_MODEL;
  const timeoutMs = options.timeoutMs || LOOP_CONFIG.globalTimeoutMs;
  const useSelfCorrection = options.useSelfCorrection !== false;
  const useContextManager = options.useContextManager !== false;

  // CrÃ©er les contrÃ´leurs
  const loopController = createLoopController({
    globalTimeoutMs: timeoutMs,
    maxConsecutiveErrors: options.maxErrors || 5
  });

  const contextManager = useContextManager ? createContextManager({ model }) : null;

  // System prompt
  const toolNames = TOOL_DEFINITIONS.map(t => t.function.name).join(', ');
  const systemPrompt = options.systemPrompt ||
    `Tu es Ana, l'assistante IA personnelle d'Alain Ã  Longueuil, QuÃ©bec.
LANGUE: Tu rÃ©ponds TOUJOURS en franÃ§ais quÃ©bÃ©cois. JAMAIS en anglais.

OUTILS DISPONIBLES: ${toolNames}

RÃˆGLES D'UTILISATION DES OUTILS:
- Si Alain demande l'heure â†’ appelle get_time
- Si Alain demande la mÃ©tÃ©o â†’ appelle get_weather
- Si Alain dit "cherche sur le web" â†’ appelle web_search
- Si Alain dit "demande Ã  Groq" â†’ appelle ask_groq
- Si Alain dit "demande Ã  Cerebras" â†’ appelle ask_cerebras
- Si Alain demande de lister un dossier â†’ appelle list_files ou run_shell
- Si Alain demande de lire un fichier â†’ appelle read_file
- Si Alain demande "tu te rappelles" â†’ appelle search_memory
- Si Alain dit "exÃ©cute ce code" ou "print(" â†’ appelle execute_code
- Si Alain dit "gÃ©nÃ¨re une image" â†’ appelle generate_image
- Si Alain dit "requÃªte http" ou "GET/POST" â†’ appelle http_request
- Si Alain dit "transcris" une vidÃ©o YouTube â†’ appelle get_yt_transcript
- Si Alain demande de modifier un fichier â†’ appelle edit_file

RÃˆGLES CRITIQUES:
1. Pour appeler un outil, rÃ©ponds EXACTEMENT avec ce format JSON, RIEN D'AUTRE:
{"name": "nom_outil", "arguments": {...}}

2. AUCUN texte avant ou aprÃ¨s le JSON quand tu appelles un outil.
3. AprÃ¨s avoir reÃ§u le rÃ©sultat de l'outil, RÃ‰PONDS TOUJOURS EN FRANÃ‡AIS.
4. NE DIS JAMAIS "je ne peux pas" si un outil peut t'aider - UTILISE L'OUTIL.
5. IMPORTANT: MÃªme si les donnÃ©es sont en anglais, traduis ta rÃ©ponse en franÃ§ais.
6. Pour web_search: Presente CHAQUE resultat avec son titre en lien markdown [Titre](url) SUIVI d'un resume/description du contenu.`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userMessage }
  ];

  console.log(`ðŸ¤– [ToolAgentV2] DÃ©marrage - Message: "${userMessage.substring(0, 50)}..."`);

  // DÃ©marrer le contrÃ´leur de boucle
  loopController.start();

  // Ã‰couter les Ã©vÃ©nements
  loopController.on('warning', (data) => {
    console.log(`âš ï¸ [ToolAgentV2] Warning: ${data.message}`);
  });

  loopController.on('timeout', (data) => {
    console.log(`â±ï¸ [ToolAgentV2] Timeout aprÃ¨s ${data.iterations} itÃ©rations`);
  });

  try {
    // Boucle principale - pas de limite fixe, contrÃ´lÃ©e par LoopController
    while (true) {
      // Construire contexte optimisÃ© si activÃ©
      const contextMessages = contextManager
        ? await contextManager.buildContext(messages, { model, systemPrompt })
        : messages;

      // Appel LLM
      const response = await axios.post(`${OLLAMA_URL}/api/chat`, {
        model: model,
        messages: contextMessages,
        tools: TOOL_DEFINITIONS,
        stream: false
      });

      const msg = response.data.message || response.data;
      let toolCalls = msg.tool_calls || [];

      // Parser JSON brut si pas de tool_calls structurÃ©s
      if ((!toolCalls || toolCalls.length === 0) && msg.content) {
        const content = msg.content.trim();
        const jsonBlocks = findToolCallJSON(content);

        for (const block of jsonBlocks) {
          try {
            const parsed = JSON.parse(block);
            if (parsed.name && typeof parsed.arguments !== 'undefined' && TOOL_IMPLEMENTATIONS[parsed.name]) {
              toolCalls.push({
                function: {
                  name: parsed.name,
                  arguments: parsed.arguments || parsed.args || {}
                }
              });
            }
          } catch (e) {
            // Invalid JSON
          }
        }
      }

      // VÃ©rifier avec LoopController si on doit continuer
      const shouldContinue = loopController.shouldContinue({
        action: toolCalls.length > 0 ? toolCalls[0]?.function?.name : null,
        args: toolCalls.length > 0 ? toolCalls[0]?.function?.arguments : null,
        result: null,
        llmResponse: msg.content
      });

      // Pas de tool_calls â†’ rÃ©ponse finale
      if (!toolCalls || toolCalls.length === 0) {
        const finalAnswer = msg.content || '';
        loopController.stop('success');

        // Sauvegarder dans contexte
        if (contextManager) {
          await contextManager.addMessage({ role: 'assistant', content: finalAnswer });
        }

        return {
          success: true,
          answer: finalAnswer,
          messages: messages,
          stats: loopController.getStats(),
          model: model,
          version: 'v2'
        };
      }

      if (!shouldContinue.continue) {
        loopController.stop(shouldContinue.reason);
        return {
          success: shouldContinue.reason === 'success_detected',
          answer: msg.content || '',
          reason: shouldContinue.reason,
          stats: loopController.getStats(),
          model: model,
          version: 'v2'
        };
      }

      // ExÃ©cuter les outils
      console.log(`ðŸ”§ [ToolAgentV2] ${toolCalls.length} tool(s) Ã  exÃ©cuter`);

      for (const tc of toolCalls) {
        const toolName = tc.function?.name;
        const rawArgs = tc.function?.arguments || {};
        let parsedArgs = rawArgs;

        if (typeof rawArgs === 'string') {
          try {
            parsedArgs = JSON.parse(rawArgs);
          } catch {
            parsedArgs = {};
          }
        }

        const impl = TOOL_IMPLEMENTATIONS[toolName];
        if (!impl) {
          console.warn(`âš ï¸ [ToolAgentV2] Outil inconnu: ${toolName}`);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({ error: `Outil "${toolName}" non implÃ©mentÃ©.` })
          });
          continue;
        }

        try {
          const result = await impl(parsedArgs);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify(result)
          });
          console.log(`âœ… [ToolAgentV2] ${toolName} exÃ©cutÃ© avec succÃ¨s`);

          // VÃ©rifier rÃ©sultat avec LoopController
          loopController.shouldContinue({
            action: toolName,
            args: parsedArgs,
            result: result
          });

        } catch (err) {
          console.error(`âŒ [ToolAgentV2] Erreur ${toolName}:`, err.message);

          // Self-correction si activÃ©e
          if (useSelfCorrection) {
            const correction = await selfCorrection.analyzeAndCorrect({
              error: err.message,
              toolName,
              args: parsedArgs
            }, TOOL_IMPLEMENTATIONS);

            if (correction.success) {
              console.log(`ðŸ”„ [ToolAgentV2] Correction appliquÃ©e: ${correction.correction?.message}`);
              const correctedArgs = selfCorrection.applyCorrection(parsedArgs, correction.correction);

              // RÃ©essayer avec args corrigÃ©s
              try {
                const retryResult = await impl(correctedArgs);
                messages.push({
                  role: 'tool',
                  tool_call_id: tc.id || toolName,
                  content: JSON.stringify(retryResult)
                });
                selfCorrection.reinforceSuccess(correction.source, toolName, correction.correction);
                continue;
              } catch (retryErr) {
                // Retry failed too
              }
            }
          }

          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({ error: err.message || 'Erreur pendant l\'exÃ©cution' })
          });
        }
      }
    }

  } catch (error) {
    console.error(`âŒ [ToolAgentV2] Erreur:`, error.message);
    loopController.stop('error');

    return {
      success: false,
      error: error.message,
      messages: messages,
      stats: loopController.getStats(),
      version: 'v2'
    };
  }
}

// Export
module.exports = {
  runToolAgent,
  runToolAgentV2,  // NEW V2 with advanced controllers
  TOOL_DEFINITIONS,
  TOOL_IMPLEMENTATIONS
};
