const EventEmitter = require('events')
const fs = require('fs')
const path = require('path')
const eventBus = require('./shared_event_bus.cjs')

/**
 * ðŸ”” ALAIN NOTIFIER AGENT - Communication Proactive
 *
 * Raison d'Ãªtre:
 * Communiquer proactivement avec Alain plutÃ´t qu'attendre qu'il me demande.
 *
 * Ce n'est pas juste "logger des Ã©vÃ©nements".
 * C'est DÃ‰CIDER QUOI DIRE, QUAND, et COMMENT.
 *
 * FonctionnalitÃ©s:
 * - Surveille tous les Ã©vÃ©nements du systÃ¨me
 * - DÃ©cide quels Ã©vÃ©nements mÃ©ritent notification
 * - Priorise (urgent, important, info, debug)
 * - AgrÃ¨ge notifications similaires
 * - CrÃ©e messages contextuels pour Alain
 * - Ã‰crit dans fichier qu'Alain peut consulter
 * - SuggÃ¨re actions concrÃ¨tes
 *
 * FrÃ©quence: Temps rÃ©el (Ã©vÃ©nements) + rÃ©sumÃ©s quotidiens
 * Ã‰vÃ©nements Ã©mis: notification:created, notification:urgent
 */
class AlainNotifier extends EventEmitter {
  constructor() {
    super()
    this.running = false

    // Chemins
    this.memoryBase = 'E:\\MÃ©moire Ana'
    this.notificationsFile = path.join(this.memoryBase, 'NOTIFICATIONS_ALAIN.md')
    this.urgentFile = path.join(this.memoryBase, 'URGENT_ALAIN.md')

    // Queue de notifications
    this.notifications = []
    this.maxNotifications = 50 // Garder les 50 derniÃ¨res

    // DerniÃ¨re notification de chaque type (Ã©viter spam)
    this.lastNotification = new Map()
    this.cooldownPeriod = 5 * 60 * 1000 // 5 minutes

    // Compteurs par type
    this.counts = {
      urgent: 0,
      important: 0,
      info: 0,
      total: 0
    }

    // Stats
    this.stats = {
      notificationsCreated: 0,
      urgentAlertsCreated: 0,
      startTime: null
    }

    console.log('ðŸ”” Alain Notifier initialisÃ©')
  }

  /**
   * DÃ©marre l'agent
   */
  async start() {
    if (this.running) {
      console.log('âš ï¸ Alain Notifier dÃ©jÃ  dÃ©marrÃ©')
      return
    }

    this.running = true
    this.stats.startTime = Date.now()

    console.log('ðŸ”” Alain Notifier dÃ©marrÃ©')
    console.log(`   - Notifications: ${this.notificationsFile}`)
    console.log(`   - Urgent: ${this.urgentFile}`)

    // Initialiser fichiers
    this.initializeFiles()

    // Ã‰couter TOUS les Ã©vÃ©nements du systÃ¨me
    this.setupEventListeners()

    // RÃ©sumÃ© quotidien (minuit)
    this.scheduleDailySummary()

    this.emit('started')
    eventBus.emit('agent:started', { name: 'alain_notifier' })
  }

  /**
   * ArrÃªte l'agent
   */
  async stop() {
    if (!this.running) {
      console.log('âš ï¸ Alain Notifier dÃ©jÃ  arrÃªtÃ©')
      return
    }

    console.log('ðŸ›‘ Alain Notifier en cours d\'arrÃªt...')

    // Sauvegarder derniÃ¨res notifications
    this.saveNotifications()

    this.running = false
    console.log('ðŸ”” Alain Notifier arrÃªtÃ©')

    this.emit('stopped')
    eventBus.emit('agent:stopped', { name: 'alain_notifier' })
  }

  /**
   * Initialise les fichiers de notifications
   */
  initializeFiles() {
    // Fichier principal
    if (!fs.existsSync(this.notificationsFile)) {
      const initial = this.createInitialFile()
      fs.writeFileSync(this.notificationsFile, initial, 'utf-8')
      console.log('   âœ… Fichier notifications crÃ©Ã©')
    }
  }

  /**
   * CrÃ©e le contenu initial du fichier
   */
  createInitialFile() {
    return `# ðŸ”” NOTIFICATIONS POUR ALAIN

**Mis Ã  jour**: ${new Date().toLocaleString('fr-FR')}

Ce fichier contient les notifications que je (Ana) veux partager avec toi de maniÃ¨re proactive.

---

## âš¡ URGENT

*(Rien pour le moment)*

---

## ðŸ“‹ IMPORTANT

*(Rien pour le moment)*

---

## â„¹ï¸ INFO

*(Rien pour le moment)*

---

## ðŸ“Š RÃ©sumÃ©

**Total notifications**: 0

---

*DerniÃ¨re mise Ã  jour: ${new Date().toLocaleString('fr-FR')}*
`
  }

  /**
   * Configure les listeners d'Ã©vÃ©nements
   */
  setupEventListeners() {
    // Ã‰VÃ‰NEMENTS URGENTS

    // Memory critique
    eventBus.on('memory:size_critical', (data) => {
      this.notify({
        level: 'urgent',
        category: 'memory',
        title: 'âš ï¸ MÃ©moire critique',
        message: `Current conversation atteint ${data.sizeMB}MB. Archivage automatique dÃ©clenchÃ©.`,
        action: 'VÃ©rifier archives dans MÃ‰MOIRE_CHARGÃ‰E_TEMP_ARCHIVES/',
        data
      })
    })

    // Service down
    eventBus.on('system:service_down', (data) => {
      this.notify({
        level: 'urgent',
        category: 'system',
        title: 'ðŸ”´ Service arrÃªtÃ©',
        message: `Le service "${data.service}" n'est plus accessible.`,
        action: 'RedÃ©marrer le service ou vÃ©rifier logs',
        data
      })
    })

    // Ã‰VÃ‰NEMENTS IMPORTANTS

    // Agents dÃ©marrÃ©s
    eventBus.on('agent:started', (data) => {
      this.notify({
        level: 'info',
        category: 'agents',
        title: `ðŸš€ Agent dÃ©marrÃ©: ${data.name}`,
        message: `L'agent ${data.name} est maintenant opÃ©rationnel.`,
        data
      })
    })

    // MÃ©moire consolidÃ©e
    eventBus.on('memory:monthly_consolidated', (data) => {
      this.notify({
        level: 'important',
        category: 'memory',
        title: 'ðŸ§  Consolidation mensuelle complÃ©tÃ©e',
        message: `Mois ${data.month}/${data.year} consolidÃ© en narratif autobiographique.`,
        action: `Lire: ${data.filepath}`,
        data
      })
    })

    // SynthÃ¨se hebdomadaire
    eventBus.on('synthesis:saved', (data) => {
      this.notify({
        level: 'important',
        category: 'synthesis',
        title: 'ðŸ“ SynthÃ¨se hebdomadaire crÃ©Ã©e',
        message: `Nouvelle synthÃ¨se narrative de ma semaine disponible.`,
        action: `Lire: ${data.filepath}`,
        data
      })
    })

    // Assertions incorrectes (Truth Checker)
    eventBus.on('truth:mismatches_found', (data) => {
      this.notify({
        level: 'important',
        category: 'truth',
        title: 'âš ï¸ Assertions incorrectes dÃ©tectÃ©es',
        message: `J'ai dit ${data.count} chose(s) fausse(s). Truth Checker a crÃ©Ã© alertes.`,
        action: 'VÃ©rifier TRUTH_ALERTS/ pour corrections',
        data
      })
    })

    // Gaps de connaissance
    eventBus.on('research:gaps_detected', (data) => {
      if (data.count >= 5) {
        this.notify({
          level: 'important',
          category: 'research',
          title: 'ðŸ” Lacunes de connaissance dÃ©tectÃ©es',
          message: `${data.count} gaps identifiÃ©s dans mes conversations.`,
          action: 'VÃ©rifier RECHERCHES/ pour voir ce que je cherche',
          data
        })
      }
    })

    // Code issues
    eventBus.on('code:issues_found', (data) => {
      if (data.issueCount > 10) {
        this.notify({
          level: 'important',
          category: 'code',
          title: 'ðŸ”¬ Issues dans mon code',
          message: `${data.issueCount} issues dÃ©tectÃ©es dans ${data.fileCount} fichier(s).`,
          action: 'VÃ©rifier CODE_REVIEWS/ pour dÃ©tails et suggestions',
          data
        })
      }
    })

    // Ã‰VÃ‰NEMENTS INFO

    // LeÃ§ons extraites
    eventBus.on('learning:lessons_extracted', (data) => {
      if (data.count > 0) {
        this.notify({
          level: 'info',
          category: 'learning',
          title: 'ðŸ“š Nouvelles leÃ§ons apprises',
          message: `${data.count} leÃ§on(s) extraite(s) de la conversation.`,
          data
        })
      }
    })

    // Patterns Ã©motionnels
    eventBus.on('emotion:analysis_complete', (data) => {
      if (data.patternsFound) {
        this.notify({
          level: 'info',
          category: 'emotion',
          title: 'ðŸŽ­ Patterns Ã©motionnels identifiÃ©s',
          message: `Nouveaux patterns dans mon journal Ã©motionnel.`,
          data
        })
      }
    })
  }

  /**
   * CrÃ©e une notification
   */
  notify({ level, category, title, message, action, data }) {
    // VÃ©rifier cooldown (Ã©viter spam)
    const key = `${level}:${category}:${title}`
    const lastTime = this.lastNotification.get(key)

    if (lastTime && Date.now() - lastTime < this.cooldownPeriod) {
      // Trop tÃ´t, skip
      return
    }

    const notification = {
      id: `notif_${Date.now()}`,
      timestamp: Date.now(),
      level,
      category,
      title,
      message,
      action: action || null,
      data: data || null,
      read: false
    }

    // Ajouter Ã  queue
    this.notifications.unshift(notification)

    // Limiter taille queue
    if (this.notifications.length > this.maxNotifications) {
      this.notifications = this.notifications.slice(0, this.maxNotifications)
    }

    // Update compteurs
    this.counts[level]++
    this.counts.total++
    this.stats.notificationsCreated++

    // Update lastNotification
    this.lastNotification.set(key, Date.now())

    // Log
    const icon = { urgent: 'ðŸ”´', important: 'ðŸŸ ', info: 'â„¹ï¸' }[level]
    console.log(`ðŸ”” [Notifier] ${icon} ${title}`)

    // Sauvegarder
    this.saveNotifications()

    // CrÃ©er fichier urgent si nÃ©cessaire
    if (level === 'urgent') {
      this.createUrgentAlert(notification)
      this.stats.urgentAlertsCreated++
      eventBus.emit('notification:urgent', notification)
    }

    eventBus.emit('notification:created', notification)
  }

  /**
   * Sauvegarde les notifications dans le fichier
   */
  saveNotifications() {
    let content = `# ðŸ”” NOTIFICATIONS POUR ALAIN\n\n`
    content += `**DerniÃ¨re mise Ã  jour**: ${new Date().toLocaleString('fr-FR')}\n\n`
    content += `Ce fichier contient les notifications que je (Ana) veux partager avec toi de maniÃ¨re proactive.\n\n`
    content += `---\n\n`

    // Urgentes
    const urgent = this.notifications.filter(n => n.level === 'urgent')
    content += `## âš¡ URGENT (${urgent.length})\n\n`

    if (urgent.length === 0) {
      content += `*(Rien pour le moment)* âœ…\n\n`
    } else {
      urgent.forEach(n => {
        content += this.formatNotification(n)
      })
    }

    content += `---\n\n`

    // Importantes
    const important = this.notifications.filter(n => n.level === 'important')
    content += `## ðŸ“‹ IMPORTANT (${important.length})\n\n`

    if (important.length === 0) {
      content += `*(Rien pour le moment)* âœ…\n\n`
    } else {
      // Limiter Ã  10 plus rÃ©centes
      important.slice(0, 10).forEach(n => {
        content += this.formatNotification(n)
      })

      if (important.length > 10) {
        content += `\n*... et ${important.length - 10} autre(s)*\n\n`
      }
    }

    content += `---\n\n`

    // Info
    const info = this.notifications.filter(n => n.level === 'info')
    content += `## â„¹ï¸ INFO (${info.length})\n\n`

    if (info.length === 0) {
      content += `*(Rien pour le moment)*\n\n`
    } else {
      // Limiter Ã  5 plus rÃ©centes
      info.slice(0, 5).forEach(n => {
        content += this.formatNotification(n)
      })

      if (info.length > 5) {
        content += `\n*... et ${info.length - 5} autre(s)*\n\n`
      }
    }

    content += `---\n\n`

    // RÃ©sumÃ©
    content += `## ðŸ“Š RÃ©sumÃ©\n\n`
    content += `**Total notifications**: ${this.counts.total}\n`
    content += `- ðŸ”´ Urgent: ${this.counts.urgent}\n`
    content += `- ðŸŸ  Important: ${this.counts.important}\n`
    content += `- â„¹ï¸ Info: ${this.counts.info}\n\n`

    content += `---\n\n`
    content += `*DerniÃ¨re mise Ã  jour: ${new Date().toLocaleString('fr-FR')}*\n`
    content += `*Fichier auto-gÃ©nÃ©rÃ© par Alain Notifier Agent*\n`

    fs.writeFileSync(this.notificationsFile, content, 'utf-8')
  }

  /**
   * Formate une notification pour affichage
   */
  formatNotification(n) {
    let text = `### ${n.title}\n\n`
    text += `**Quand**: ${new Date(n.timestamp).toLocaleString('fr-FR')}\n`
    text += `**CatÃ©gorie**: ${n.category}\n\n`
    text += `${n.message}\n\n`

    if (n.action) {
      text += `ðŸ’¡ **Action suggÃ©rÃ©e**: ${n.action}\n\n`
    }

    return text
  }

  /**
   * CrÃ©e une alerte urgente
   */
  createUrgentAlert(notification) {
    let content = `# ðŸš¨ ALERTE URGENTE\n\n`
    content += `**Date**: ${new Date(notification.timestamp).toLocaleString('fr-FR')}\n\n`
    content += `---\n\n`
    content += `## ${notification.title}\n\n`
    content += `${notification.message}\n\n`

    if (notification.action) {
      content += `## ðŸ’¡ Action Requise\n\n`
      content += `${notification.action}\n\n`
    }

    content += `---\n\n`
    content += `*Alerte crÃ©Ã©e automatiquement par Alain Notifier*\n`

    fs.writeFileSync(this.urgentFile, content, 'utf-8')
    console.log('   ðŸš¨ URGENT_ALAIN.md crÃ©Ã©')
  }

  /**
   * Programme rÃ©sumÃ© quotidien
   */
  scheduleDailySummary() {
    // Calculer ms jusqu'Ã  minuit
    const now = new Date()
    const tomorrow = new Date(now)
    tomorrow.setDate(tomorrow.getDate() + 1)
    tomorrow.setHours(0, 0, 0, 0)

    const msUntilMidnight = tomorrow - now

    setTimeout(() => {
      this.createDailySummary()

      // Puis chaque 24h
      setInterval(() => {
        this.createDailySummary()
      }, 24 * 60 * 60 * 1000)
    }, msUntilMidnight)

    console.log('   ðŸ“… RÃ©sumÃ© quotidien programmÃ© (minuit)')
  }

  /**
   * CrÃ©e un rÃ©sumÃ© quotidien
   */
  createDailySummary() {
    // Compter notifications des derniÃ¨res 24h
    const yesterday = Date.now() - 24 * 60 * 60 * 1000
    const recent = this.notifications.filter(n => n.timestamp > yesterday)

    if (recent.length === 0) {
      return // Rien Ã  rÃ©sumer
    }

    this.notify({
      level: 'info',
      category: 'summary',
      title: 'ðŸ“… RÃ©sumÃ© quotidien',
      message: `${recent.length} Ã©vÃ©nement(s) dans les derniÃ¨res 24h.`,
      action: 'Consulter NOTIFICATIONS_ALAIN.md pour dÃ©tails'
    })
  }

  /**
   * RÃ©cupÃ¨re les statistiques de l'agent
   */
  getStats() {
    const uptime = this.stats.startTime
      ? Date.now() - this.stats.startTime
      : 0

    return {
      running: this.running,
      uptime: this._formatDuration(uptime),
      notificationsCreated: this.stats.notificationsCreated,
      urgentAlertsCreated: this.stats.urgentAlertsCreated,
      currentNotifications: this.notifications.length,
      byLevel: {
        urgent: this.counts.urgent,
        important: this.counts.important,
        info: this.counts.info
      }
    }
  }

  /**
   * Formate une durÃ©e
   */
  _formatDuration(ms) {
    const seconds = Math.floor(ms / 1000)
    const minutes = Math.floor(seconds / 60)
    const hours = Math.floor(minutes / 60)
    const days = Math.floor(hours / 24)

    if (days > 0) return `${days}j ${hours % 24}h`
    if (hours > 0) return `${hours}h ${minutes % 60}m`
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`
    return `${seconds}s`
  }
}

// Export instance singleton
module.exports = new AlainNotifier()
