/**
 * Tool Agent - Agent avec Tool Calling pour Ana
 * FIX 2025-12-05:
 *   1. DIR fiable (fs.readdir au lieu de spawn cmd.exe)
 *   2. System prompt avec liste d'outils explicite
 *
 * Cr√©√©: 2 D√©cembre 2025
 * Source: Perplexity recommendation
 */

const axios = require('axios');
const WebTools = require('../tools/web-tools.cjs');
const FileTools = require('../tools/file-tools.cjs');
const BashTools = require('../tools/bash-tools.cjs');
const LlamaVisionHandler = require('../../intelligence/vision/llama_vision_handler.cjs');
const visionHandler = new LlamaVisionHandler();
const voiceParser = require('../core/voice-command-parser.cjs');
const architectAgent = require('./architect-agent.cjs');

// ORCHESTRATEUR LLM - Added 2025-12-08
const groqService = require('../services/groq-service.cjs');

// V2 Core Modules - Added 2025-12-07
const {
  createLoopController,
  selfCorrection,
  createContextManager,
  LOOP_CONFIG
} = require('../core/index.cjs');

const OLLAMA_URL = 'http://localhost:11434';
const { callWithFallback } = require('../core/llm-orchestrator.cjs');
const DEFAULT_MODEL = 'qwen2.5-coder:7b';

/**
 * FIX 2025-12-08: Parse tool calls - supports multiple LLM formats
 * - Standard JSON: {"name": "tool", "arguments": {...}}
 * - GLM-4 format: "tool_name\n{}" or "tool_name\n{args}"
 * - Tool name alone: "get_time" (for no-arg tools)
 */
function findToolCallJSON(content) {
  const results = [];

  // Liste des outils valides
  const validToolNames = [
    'web_search', 'get_weather', 'get_time', 'read_file', 'write_file',
    'list_files', 'run_shell', 'edit_file', 'grep', 'save_memory',
    'search_memory', 'ask_groq', 'ask_cerebras', 'execute_code',
    'http_request', 'json_parse', 'generate_image', 'describe_image',
    'research_topic', 'youtube_search', 'get_yt_transcript',
    'get_news', 'wikipedia_search', 'convert_units',
    'generate_animation', 'generate_video', 'image_to_image', 'inpaint_image', 'debug_screenshot', 'analyze_code_screenshot', 'execute_voice_command', 'ask_architect', 'review_code'
  ];

  // FORMAT 1: GLM-4 style "tool_name\n{args}"
  for (const toolName of validToolNames) {
    // Pattern: tool_name suivi de newline et JSON object
    const glm4Regex = new RegExp(toolName + '\\s*\\n\\s*(\\{[\\s\\S]*?\\})', 'g');
    let match;
    while ((match = glm4Regex.exec(content)) !== null) {
      try {
        const args = JSON.parse(match[1]);
        const toolCall = JSON.stringify({ name: toolName, arguments: args });
        if (!results.includes(toolCall)) {
          results.push(toolCall);
          console.log(`[Parser] GLM-4 format: ${toolName}`);
        }
      } catch (e) {
        const toolCall = JSON.stringify({ name: toolName, arguments: {} });
        if (!results.includes(toolCall)) {
          results.push(toolCall);
          console.log(`[Parser] GLM-4 format (empty): ${toolName}`);
        }
      }
    }

    // Pattern: tool_name seul (pas suivi de JSON)
    const soloRegex = new RegExp('(?:^|\\n)\\s*' + toolName + '\\s*(?:\\n|$)', 'g');
    while ((match = soloRegex.exec(content)) !== null) {
      const toolCall = JSON.stringify({ name: toolName, arguments: {} });
      if (!results.includes(toolCall)) {
        results.push(toolCall);
        console.log(`[Parser] Solo tool: ${toolName}`);
      }
    }
  }

  // FORMAT 2: Standard JSON {"name": "...", "arguments": {...}}
  let startIdx = 0;
  while ((startIdx = content.indexOf('{', startIdx)) !== -1) {
    let depth = 0;
    let endIdx = startIdx;

    for (let i = startIdx; i < content.length; i++) {
      if (content[i] === '{') depth++;
      if (content[i] === '}') {
        depth--;
        if (depth === 0) {
          endIdx = i;
          break;
        }
      }
    }

    if (depth === 0 && endIdx > startIdx) {
      const candidate = content.substring(startIdx, endIdx + 1);
      try {
        const parsed = JSON.parse(candidate);
        if (parsed.name && typeof parsed.arguments !== 'undefined') {
          if (!results.includes(candidate)) {
            results.push(candidate);
          }
        }
      } catch (e) {
        // Pas du JSON valide
      }
    }
    startIdx++;
  }

  return results;
}

// 1) D√©finition des outils c√¥t√© LLM (sch√©mas JSON)
const TOOL_DEFINITIONS = [
  {
    type: 'function',
    function: {
      name: 'web_search',
      description: 'Recherche d\'information g√©n√©rale sur le web (DuckDuckGo).',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Requ√™te de recherche en texte libre.' },
          limit: { type: 'integer', description: 'Nombre max de r√©sultats', default: 5 }
        },
        required: ['query']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_weather',
      description: 'Obtenir la m√©t√©o actuelle pour une ville donn√©e.',
      parameters: {
        type: 'object',
        properties: {
          location: { type: 'string', description: 'Ville ou lieu, ex: "Longueuil".' },
          lang: { type: 'string', description: 'Langue de la r√©ponse m√©t√©o', default: 'fr' }
        },
        required: ['location']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_time',
      description: 'Obtenir l\'heure et la date actuelles du syst√®me.',
      parameters: {
        type: 'object',
        properties: {
          timezone: { type: 'string', description: 'Fuseau horaire (ex: "America/Montreal")', default: 'America/Montreal' }
        },
        required: []
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'read_file',
      description: 'Lire un fichier texte sur le disque.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' },
          limit: { type: 'integer', description: 'Longueur max du contenu retourn√©', default: 4000 }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'search_in_file',
      description: 'Rechercher un pattern (regex) dans un fichier et retourner les lignes correspondantes avec contexte. UTILISE CET OUTIL pour analyser de gros fichiers au lieu de read_file. Parfait pour trouver des fonctions, routes API, d√©finitions, etc.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier √† analyser.' },
          pattern: { type: 'string', description: 'Pattern regex √† rechercher (ex: "app\\.get|app\\.post" pour routes Express).' },
          context_lines: { type: 'integer', description: 'Nombre de lignes de contexte avant/apr√®s chaque match.', default: 1 }
        },
        required: ['path', 'pattern']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'read_file_chunk',
      description: 'Lire une portion sp√©cifique d\'un fichier (lignes X √† Y). Utile pour les gros fichiers quand tu connais la zone √† examiner.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' },
          start_line: { type: 'integer', description: 'Num√©ro de ligne de d√©but (1-based).', default: 1 },
          end_line: { type: 'integer', description: 'Num√©ro de ligne de fin (1-based).', default: 100 }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'file_info',
      description: 'Obtenir des informations sur un fichier (taille, nombre de lignes, type). UTILISE AVANT read_file pour savoir si le fichier est trop gros.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'write_file',
      description: '√âcrire du contenu dans un fichier.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin absolu du fichier.' },
          content: { type: 'string', description: 'Contenu √† √©crire.' }
        },
        required: ['path', 'content']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'list_files',
      description: 'Lister les fichiers d\'un r√©pertoire.',
      parameters: {
        type: 'object',
        properties: {
          path: { type: 'string', description: 'Chemin du r√©pertoire.' },
          recursive: { type: 'boolean', description: 'Inclure sous-dossiers', default: false }
        },
        required: ['path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'run_shell',
      description: 'Ex√©cuter une commande shell.',
      parameters: {
        type: 'object',
        properties: {
          command: { type: 'string', description: 'Commande shell √† ex√©cuter.' },
          timeout: { type: 'integer', description: 'Timeout en ms', default: 10000 }
        },
        required: ['command']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'web_fetch',
      description: 'R√©cup√©rer le contenu d\'une page web.',
      parameters: {
        type: 'object',
        properties: {
          url: { type: 'string', description: 'URL de la page √† r√©cup√©rer.' },
          selector: { type: 'string', description: 'S√©lecteur CSS optionnel pour extraire une partie.' }
        },
        required: ['url']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'wikipedia',
      description: 'Rechercher sur Wikipedia FR.',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Terme √† rechercher.' }
        },
        required: ['query']
      }
    }
  },
  // === CLOUD LLM TOOLS ===
  {
    type: 'function',
    function: {
      name: 'ask_groq',
      description: 'Poser une question complexe √† Groq (ultra-rapide, Llama 70B). Pour raisonnement avanc√©, recherches, analyses.',
      parameters: {
        type: 'object',
        properties: {
          question: { type: 'string', description: 'Question √† poser √† Groq.' },
          model: { type: 'string', enum: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'], description: 'Mod√®le Groq', default: 'llama-3.3-70b-versatile' }
        },
        required: ['question']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'ask_cerebras',
      description: 'Poser une question √† Cerebras (le plus rapide du monde, ~1000 tok/s). Pour t√¢ches critiques, coding, math.',
      parameters: {
        type: 'object',
        properties: {
          question: { type: 'string', description: 'Question √† poser √† Cerebras.' },
          model: { type: 'string', enum: ['llama3.1-8b', 'llama3.1-70b'], description: 'Mod√®le Cerebras', default: 'llama3.1-8b' }
        },
        required: ['question']
      }
    }
  },
  // === MEMORY SEARCH TOOL ===
  {
    type: 'function',
    function: {
      name: 'search_memory',
      description: 'Rechercher dans ma m√©moire des conversations pass√©es avec Alain. Utiliser quand Alain demande "tu te rappelles?", "on avait parl√© de...", "cherche dans ta m√©moire".',
      parameters: {
        type: 'object',
        properties: {
          query: { type: 'string', description: 'Ce que je cherche dans ma m√©moire (mots-cl√©s, sujet, nom).' },
          limit: { type: 'integer', description: 'Nombre max de r√©sultats', default: 5 }
        },
        required: ['query']
      }
    }
  },
  // === SAVE MEMORY TOOL ===
  {
    type: 'function',
    function: {
      name: 'save_memory',
      description: 'Sauvegarder une information importante en memoire pour m en souvenir plus tard. Utiliser quand Alain dit souviens-toi, retiens ca, n oublie pas.',
      parameters: {
        type: 'object',
        properties: {
          content: { type: 'string', description: 'L information a memoriser.' },
          category: { type: 'string', description: 'Categorie du souvenir (fait, preference, projet, etc.)', default: 'general' }
        },
        required: ['content']
      }
    }
  },
  // === EDIT FILE TOOL ===
  {
    type: 'function',
    function: {
      name: 'edit_file',
      description: 'Modifier un fichier en rempla√ßant une cha√Æne par une autre sans r√©√©crire tout le fichier.',
      parameters: {
        type: 'object',
        properties: {
          file_path: { type: 'string', description: 'Chemin absolu du fichier √† modifier' },
          old_string: { type: 'string', description: 'Texte exact √† remplacer' },
          new_string: { type: 'string', description: 'Nouveau texte' },
          replace_all: { type: 'boolean', description: 'Remplacer toutes les occurrences', default: false }
        },
        required: ['file_path', 'old_string', 'new_string']
      }
    }
  },
  // === GLOB TOOL ===
  {
    type: 'function',
    function: {
      name: 'glob',
      description: 'Trouver des fichiers par pattern (ex: *.js, **/*.ts, src/**/*.cjs)',
      parameters: {
        type: 'object',
        properties: {
          pattern: { type: 'string', description: 'Pattern glob (ex: **/*.js)' },
          path: { type: 'string', description: 'Dossier de recherche (d√©faut: E:/ANA)', default: 'E:/ANA' }
        },
        required: ['pattern']
      }
    }
  },
  // === GREP TOOL ===
  {
    type: 'function',
    function: {
      name: 'grep',
      description: 'Chercher du texte ou regex dans les fichiers',
      parameters: {
        type: 'object',
        properties: {
          pattern: { type: 'string', description: 'Texte ou regex √† chercher' },
          path: { type: 'string', description: 'Fichier ou dossier o√π chercher', default: 'E:/ANA' },
          glob: { type: 'string', description: 'Filtrer par pattern de fichiers (ex: *.js)' },
          ignore_case: { type: 'boolean', description: 'Ignorer la casse', default: false }
        },
        required: ['pattern']
      }
    }
  },
  // === ASK USER TOOL ===
  {
    type: 'function',
    function: {
      name: 'ask_user',
      description: 'Poser une question √† Alain et attendre sa r√©ponse',
      parameters: {
        type: 'object',
        properties: {
          question: { type: 'string', description: 'La question √† poser √† Alain' },
          options: { type: 'array', items: { type: 'string' }, description: 'Options de r√©ponse (optionnel)' }
        },
        required: ['question']
      }
    }
  },
  // === RUN BACKGROUND TOOL ===
  {
    type: 'function',
    function: {
      name: 'run_background',
      description: 'Ex√©cuter une commande en arri√®re-plan (pour t√¢ches longues)',
      parameters: {
        type: 'object',
        properties: {
          command: { type: 'string', description: 'Commande √† ex√©cuter' },
          working_dir: { type: 'string', description: 'Dossier de travail', default: 'E:/ANA' }
        },
        required: ['command']
      }
    }
  },
  // === KILL PROCESS TOOL ===
  {
    type: 'function',
    function: {
      name: 'kill_process',
      description: 'Arr√™ter un processus par son PID ou nom',
      parameters: {
        type: 'object',
        properties: {
          pid: { type: 'integer', description: 'PID du processus' },
          name: { type: 'string', description: 'Nom du processus (ex: node.exe)' }
        }
      }
    }
  },
  // === TODO WRITE TOOL ===
  {
    type: 'function',
    function: {
      name: 'todo_write',
      description: 'G√©rer ma liste de t√¢ches persistante',
      parameters: {
        type: 'object',
        properties: {
          action: { type: 'string', enum: ['add', 'complete', 'list', 'clear'], description: 'Action √† effectuer' },
          task: { type: 'string', description: 'Description de la t√¢che (pour add)' },
          task_id: { type: 'integer', description: 'ID de la t√¢che (pour complete)' }
        },
        required: ['action']
      }
    }
  },
  // === NOTEBOOK EDIT TOOL ===
  {
    type: 'function',
    function: {
      name: 'notebook_edit',
      description: '√âditer un notebook Jupyter (.ipynb)',
      parameters: {
        type: 'object',
        properties: {
          notebook_path: { type: 'string', description: 'Chemin du notebook' },
          cell_index: { type: 'integer', description: 'Index de la cellule (0-based)' },
          new_source: { type: 'string', description: 'Nouveau contenu de la cellule' },
          action: { type: 'string', enum: ['replace', 'insert', 'delete'], default: 'replace' }
        },
        required: ['notebook_path', 'cell_index']
      }
    }
  },
  // === PLAN MODE TOOL ===
  {
    type: 'function',
    function: {
      name: 'plan_mode',
      description: 'Entrer en mode planification pour t√¢ches complexes',
      parameters: {
        type: 'object',
        properties: {
          action: { type: 'string', enum: ['enter', 'exit'], description: 'Entrer ou sortir du mode plan' },
          plan_file: { type: 'string', description: 'Fichier o√π sauvegarder le plan' }
        },
        required: ['action']
      }
    }
  },

  // === 4 NOUVEAUX OUTILS PARIT√â CLAUDE CODE - 2025-12-08 ===
  {
    type: 'function',
    function: {
      name: 'execute_code',
      description: 'Ex√©cuter du code Python et retourner le r√©sultat.',
      parameters: {
        type: 'object',
        properties: {
          code: { type: 'string', description: 'Code Python √† ex√©cuter' },
          language: { type: 'string', description: 'Langage (python par d√©faut)', default: 'python' }
        },
        required: ['code']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'generate_image',
      description: 'G√©n√©rer une image √† partir d\'un prompt texte via ComfyUI.',
      parameters: {
        type: 'object',
        properties: {
          prompt: { type: 'string', description: 'Description de l\'image √† g√©n√©rer' },
          negative_prompt: { type: 'string', description: 'Ce qu\'on ne veut pas voir', default: '' },
          width: { type: 'integer', description: 'Largeur', default: 512 },
          height: { type: 'integer', description: 'Hauteur', default: 512 }
        },
        required: ['prompt']
      }
    }
  },
    // === IMAGE/VIDEO GENERATION TOOLS - Added 2025-12-09 ===
  {
    type: 'function',
    function: {
      name: 'generate_animation',
      description: 'Generer un GIF anime via AnimateDiff (ComfyUI). Utilise DreamShaper 8 pour meilleure qualite.',
      parameters: {
        type: 'object',
        properties: {
          prompt: { type: 'string', description: 'Description de l\'animation a generer' },
          negative_prompt: { type: 'string', description: 'Ce qu\'on ne veut pas voir', default: 'blurry, low quality' },
          frame_count: { type: 'integer', description: 'Nombre de frames (8-24)', default: 16 },
          fps: { type: 'integer', description: 'Images par seconde', default: 8 },
          format: { type: 'string', enum: ['gif', 'mp4', 'webm'], default: 'gif' }
        },
        required: ['prompt']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'generate_video',
      description: 'Generer une video via Mochi (ComfyUI). Haute qualite mais lent.',
      parameters: {
        type: 'object',
        properties: {
          prompt: { type: 'string', description: 'Description de la video a generer' },
          duration: { type: 'integer', description: 'Duree en secondes (2-10)', default: 5 },
          fps: { type: 'integer', description: 'Images par seconde', default: 24 }
        },
        required: ['prompt']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'image_to_image',
      description: 'Transformer une image existante avec un nouveau prompt (img2img).',
      parameters: {
        type: 'object',
        properties: {
          image_path: { type: 'string', description: 'Chemin vers l\'image source' },
          prompt: { type: 'string', description: 'Description de la transformation' },
          negative_prompt: { type: 'string', description: 'Ce qu\'on ne veut pas', default: '' },
          denoise: { type: 'number', description: 'Force de transformation 0.0-1.0', default: 0.75 }
        },
        required: ['image_path', 'prompt']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'inpaint_image',
      description: 'Retoucher une zone specifique d\'une image (inpainting).',
      parameters: {
        type: 'object',
        properties: {
          image_path: { type: 'string', description: 'Chemin vers l\'image source' },
          mask_path: { type: 'string', description: 'Chemin vers le masque (blanc=zone a modifier)' },
          prompt: { type: 'string', description: 'Description de ce qui doit remplacer la zone masquee' },
          negative_prompt: { type: 'string', description: 'Ce qu\'on ne veut pas', default: '' }
        },
        required: ['image_path', 'mask_path', 'prompt']
      }
    }
  },
{
    type: 'function',
    function: {
      name: 'http_request',
      description: 'Faire une requ√™te HTTP GET/POST vers une URL.',
      parameters: {
        type: 'object',
        properties: {
          url: { type: 'string', description: 'URL cible' },
          method: { type: 'string', enum: ['GET', 'POST', 'PUT', 'DELETE'], default: 'GET' },
          headers: { type: 'object', description: 'Headers HTTP' },
          body: { type: 'string', description: 'Corps de la requ√™te (POST/PUT)' }
        },
        required: ['url']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_yt_transcript',
      description: 'Obtenir la transcription d\'une vid√©o YouTube.',
      parameters: {
        type: 'object',
        properties: {
          video_url: { type: 'string', description: 'URL de la vid√©o YouTube' },
          language: { type: 'string', description: 'Langue pr√©f√©r√©e', default: 'fr' }
        },
        required: ['video_url']
      }
    }
  },
  // === LAUNCH AGENT TOOL ===
  {
    type: 'function',
    function: {
      name: 'launch_agent',
      description: 'Lancer un sous-agent sp√©cialis√© pour une t√¢che',
      parameters: {
        type: 'object',
        properties: {
          agent_type: { type: 'string', enum: ['research', 'code', 'explore', 'plan'], description: 'Type d\'agent' },
          task: { type: 'string', description: 'T√¢che √† accomplir' },
          context: { type: 'string', description: 'Contexte additionnel' }
        },
        required: ['agent_type', 'task']
      }
    }
  },
  // ============ GIT TOOLS - Phase 2 ANA CODE ============
  {
    type: 'function',
    function: {
      name: 'git_status',
      description: 'Obtenir le statut git (fichiers modifi√©s, branche actuelle, dernier commit).',
      parameters: {
        type: 'object',
        properties: {
          repo_path: { type: 'string', description: 'Chemin vers le repository git' }
        },
        required: ['repo_path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'git_commit',
      description: 'Committer les changements avec un message descriptif.',
      parameters: {
        type: 'object',
        properties: {
          repo_path: { type: 'string', description: 'Chemin vers le repository git' },
          message: { type: 'string', description: 'Message de commit descriptif' },
          add_all: { type: 'boolean', description: 'Ajouter tous les fichiers avant commit', default: true }
        },
        required: ['repo_path', 'message']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'git_log',
      description: 'Voir historique des commits.',
      parameters: {
        type: 'object',
        properties: {
          repo_path: { type: 'string', description: 'Chemin vers le repository git' },
          count: { type: 'integer', description: 'Nombre de commits √† afficher', default: 10 }
        },
        required: ['repo_path']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'git_branch',
      description: 'Lister ou cr√©er des branches.',
      parameters: {
        type: 'object',
        properties: {
          repo_path: { type: 'string', description: 'Chemin vers le repository git' },
          action: { type: 'string', enum: ['list', 'create', 'checkout'], description: 'Action' },
          branch_name: { type: 'string', description: 'Nom de la branche (pour create/checkout)' }
        },
        required: ['repo_path', 'action']
      }
    }
  },
  // ============ RAG TOOLS - Phase 2.2 ANA CODE ============
  {
    type: 'function',
    function: {
      name: 'search_codebase',
      description: 'Rechercher dans le code source d\'un projet (fichiers, fonctions, classes).',
      parameters: {
        type: 'object',
        properties: {
          project_path: { type: 'string', description: 'Chemin vers le projet √† rechercher' },
          query: { type: 'string', description: 'Termes de recherche (ex: "git commit", "async function")' },
          max_results: { type: 'integer', description: 'Nombre max de r√©sultats', default: 10 }
        },
        required: ['project_path', 'query']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'get_project_structure',
      description: 'Obtenir la structure arborescente d\'un projet (dossiers et fichiers).',
      parameters: {
        type: 'object',
        properties: {
          project_path: { type: 'string', description: 'Chemin vers le projet' },
          max_depth: { type: 'integer', description: 'Profondeur max de l\'arbre', default: 3 }
        },
        required: ['project_path']
      }
    }
  },
  // ============ VISION TOOLS - Phase 3.2 ANA CODE ============
  {
    type: 'function',
    function: {
      name: 'describe_image',
      description: 'Analyser et decrire une image en detail.',
      parameters: {
        type: 'object',
        properties: {
          image_path: { type: 'string', description: 'Chemin vers l\'image a analyser' },
          image_base64: { type: 'string', description: 'Image en base64 (alternative a image_path)' },
          prompt: { type: 'string', description: 'Question ou instruction specifique pour l\'analyse' }
        },
        required: []
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'debug_screenshot',
      description: 'Analyser une capture d\'ecran d\'erreur et proposer des solutions.',
      parameters: {
        type: 'object',
        properties: {
          image_path: { type: 'string', description: 'Chemin vers le screenshot d\'erreur' },
          image_base64: { type: 'string', description: 'Screenshot en base64' },
          context: { type: 'string', description: 'Contexte additionnel (langage, framework, etc.)' }
        },
        required: []
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'analyze_code_screenshot',
      description: 'Extraire et analyser du code depuis une capture d\'ecran.',
      parameters: {
        type: 'object',
        properties: {
          image_path: { type: 'string', description: 'Chemin vers le screenshot de code' },
          image_base64: { type: 'string', description: 'Screenshot en base64' }
        },
        required: []
      }
    }
  },
  // ============ VOICE CODING - Phase 3.1 ANA CODE ============
  {
    type: 'function',
    function: {
      name: 'execute_voice_command',
      description: 'Parser et executer une commande vocale de coding (git, fichiers, code, etc.).',
      parameters: {
        type: 'object',
        properties: {
          transcript: { type: 'string', description: 'Transcription vocale a parser et executer' },
          context: { type: 'string', description: 'Contexte optionnel (repertoire courant, projet, etc.)' }
        },
        required: ['transcript']
      }
    }
  },
  // ============ ARCHITECT MODE - Phase 3.3 ANA CODE ============
  {
    type: 'function',
    function: {
      name: 'ask_architect',
      description: 'Demander a l\'architecte d\'analyser une demande et creer un plan d\'implementation.',
      parameters: {
        type: 'object',
        properties: {
          request: { type: 'string', description: 'Description de la fonctionnalite ou modification a implementer' },
          files: { type: 'array', items: { type: 'string' }, description: 'Liste des fichiers concernes' },
          project_context: { type: 'string', description: 'Contexte du projet (structure, technologies, etc.)' }
        },
        required: ['request']
      }
    }
  },
  {
    type: 'function',
    function: {
      name: 'review_code',
      description: 'Demander a l\'architecte de reviser du code et suggerer des ameliorations.',
      parameters: {
        type: 'object',
        properties: {
          code: { type: 'string', description: 'Code source a reviser' },
          context: { type: 'string', description: 'Contexte du code (fichier, fonction, objectif)' }
        },
        required: ['code']
      }
    }
  }
];

// 2) Mapping des outils ‚Üí fonctions Node r√©elles
const TOOL_IMPLEMENTATIONS = {
  async web_search(args) {
    const { query, limit } = args;
    console.log(`üîß [ToolAgent] web_search: "${query}"`);
    const result = await WebTools.search(query, { limit: limit || 5 });
    return result;
  },

  async get_weather(args) {
    const { location, lang } = args;
    console.log(`üîß [ToolAgent] get_weather: "${location}"`);
    const result = await WebTools.weather(location, { lang: lang || 'fr' });
    return result;
  },

  async get_time(args) {
    const { timezone } = args;
    console.log(`üîß [ToolAgent] get_time`);
    const now = new Date();
    const options = {
      timeZone: timezone || 'America/Montreal',
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    };
    return {
      success: true,
      datetime: now.toLocaleString('fr-CA', options),
      iso: now.toISOString(),
      timestamp: now.getTime(),
      timezone: timezone || 'America/Montreal'
    };
  },

  async read_file(args) {
    const { path, limit } = args;
    console.log(`üîß [ToolAgent] read_file: "${path}"`);
    const res = await FileTools.read(path, { encoding: 'utf-8', limit: limit || 4000 });
    return {
      success: res.success,
      path: res.path,
      content: res.content,
      error: res.error
    };
  },

  async search_in_file(args) {
    const { path: filePath, pattern, context_lines = 1 } = args;
    console.log(`üîß [ToolAgent] search_in_file: "${filePath}" pattern="${pattern}"`);

    try {
      const fs = require('fs');
      if (!fs.existsSync(filePath)) {
        return { success: false, error: `Fichier non trouv√©: ${filePath}` };
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');
      const regex = new RegExp(pattern, 'gi');
      const matches = [];

      lines.forEach((line, index) => {
        if (regex.test(line)) {
          // Collecter les lignes de contexte
          const startLine = Math.max(0, index - context_lines);
          const endLine = Math.min(lines.length - 1, index + context_lines);

          const contextBlock = [];
          for (let i = startLine; i <= endLine; i++) {
            const prefix = i === index ? '>>> ' : '    ';
            contextBlock.push(`${prefix}${i + 1}: ${lines[i]}`);
          }

          matches.push({
            line_number: index + 1,
            content: line.trim(),
            context: contextBlock.join('\n')
          });
        }
        // Reset regex lastIndex pour les patterns globaux
        regex.lastIndex = 0;
      });

      return {
        success: true,
        path: filePath,
        pattern: pattern,
        total_matches: matches.length,
        matches: matches.slice(0, 100), // Limiter √† 100 r√©sultats max
        message: `Trouv√© ${matches.length} correspondance(s) pour "${pattern}"`
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async read_file_chunk(args) {
    const { path: filePath, start_line = 1, end_line = 100 } = args;
    console.log(`üîß [ToolAgent] read_file_chunk: "${filePath}" lines ${start_line}-${end_line}`);

    try {
      const fs = require('fs');
      if (!fs.existsSync(filePath)) {
        return { success: false, error: `Fichier non trouv√©: ${filePath}` };
      }

      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n');
      const totalLines = lines.length;

      // Ajuster les bornes
      const start = Math.max(1, start_line) - 1; // Convert to 0-based
      const end = Math.min(totalLines, end_line);

      const chunk = lines.slice(start, end);
      const numberedChunk = chunk.map((line, i) => `${start + i + 1}: ${line}`).join('\n');

      return {
        success: true,
        path: filePath,
        start_line: start + 1,
        end_line: end,
        total_lines: totalLines,
        content: numberedChunk,
        message: `Lignes ${start + 1}-${end} sur ${totalLines} total`
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async file_info(args) {
    const { path: filePath } = args;
    console.log(`üîß [ToolAgent] file_info: "${filePath}"`);

    try {
      const fs = require('fs');
      const pathModule = require('path');

      if (!fs.existsSync(filePath)) {
        return { success: false, error: `Fichier non trouv√©: ${filePath}` };
      }

      const stats = fs.statSync(filePath);
      const content = fs.readFileSync(filePath, 'utf-8');
      const lines = content.split('\n').length;
      const ext = pathModule.extname(filePath).toLowerCase();

      // D√©terminer le type
      const codeExtensions = ['.js', '.cjs', '.mjs', '.ts', '.py', '.java', '.cpp', '.c', '.h', '.cs', '.go', '.rs', '.rb', '.php'];
      const textExtensions = ['.txt', '.md', '.json', '.xml', '.yaml', '.yml', '.csv', '.log', '.ini', '.cfg'];

      let fileType = 'binary';
      if (codeExtensions.includes(ext)) fileType = 'code';
      else if (textExtensions.includes(ext)) fileType = 'text';

      // Recommandation
      let recommendation = 'read_file';
      if (lines > 500) {
        recommendation = 'search_in_file ou read_file_chunk';
      }

      return {
        success: true,
        path: filePath,
        size_bytes: stats.size,
        size_readable: stats.size > 1024 * 1024
          ? `${(stats.size / 1024 / 1024).toFixed(2)} MB`
          : stats.size > 1024
            ? `${(stats.size / 1024).toFixed(2)} KB`
            : `${stats.size} bytes`,
        lines: lines,
        extension: ext,
        type: fileType,
        is_large: lines > 500,
        recommendation: recommendation,
        modified: stats.mtime.toISOString()
      };
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async write_file(args) {
    const { path, content } = args;
    console.log(`üîß [ToolAgent] write_file: "${path}"`);
    const res = await FileTools.write(path, content, { backup: true });
    return res;
  },

  async list_files(args) {
    const { path, recursive } = args;
    console.log(`üîß [ToolAgent] list_files: "${path}"`);
    const res = await FileTools.list(path, { recursive: recursive || false, details: true });
    return res;
  },

  // FIX 2025-12-05: run_shell avec redirection DIR vers fs.readdir
  async run_shell(args) {
    const { command, timeout } = args;
    console.log(`üîß [ToolAgent] run_shell: "${command}"`);

    // FIX: Commande "dir" redirig√©e vers FileTools.list (plus fiable que spawn cmd.exe)
    const dirMatch = command.match(/^dir\s+(.+)$/i);
    if (dirMatch) {
      const dirPath = dirMatch[1].replace(/["']/g, '').replace(/\//g, '\\').trim();
      console.log(`üîß [ToolAgent] Redirection dir -> FileTools.list: "${dirPath}"`);
      const res = await FileTools.list(dirPath, { recursive: false, details: true });
      if (res.success) {
        // Format similaire √† dir Windows
        const output = res.entries.map(e => {
          const type = e.isDirectory ? '<DIR>' : e.size.toString().padStart(12);
          return `${e.modified || ''}  ${type}  ${e.name}`;
        }).join('\n');
        return {
          success: true,
          stdout: output,
          entries: res.entries,
          count: res.count,
          method: 'fs.readdir (fiable)'
        };
      }
      return res;
    }

    // Autres commandes: BashTools
    const res = await BashTools.execute(command, { timeout: timeout || 10000 });
    return res;
  },

  async web_fetch(args) {
    const { url, selector } = args;
    console.log(`üîß [ToolAgent] web_fetch: "${url}"`);
    const res = await WebTools.fetch(url, { selector });
    return res;
  },

  async wikipedia(args) {
    const { query } = args;
    console.log(`üîß [ToolAgent] wikipedia: "${query}"`);
    const res = await WebTools.wikipedia(query);
    return res;
  },

  // === CLOUD LLM IMPLEMENTATIONS ===
  async ask_groq(args) {
    const { question, prompt, model = 'llama-3.3-70b-versatile' } = args;
    const q = question || prompt || '';
    if (!q) {
      return { success: false, error: 'Param√®tre question ou prompt requis', provider: 'groq' };
    }
    console.log(`üîß [ToolAgent] ask_groq: "${q.substring(0, 50)}..."`);
    const groqService = require('../services/groq-service.cjs');
    const result = await groqService.chat(q, { model });
    return {
      success: result.success,
      provider: 'groq',
      model,
      answer: result.response || result.error,
      tokens: result.usage?.total_tokens || 0,
      latencyMs: result.latencyMs
    };
  },

  async ask_cerebras(args) {
    const { question, prompt, model = 'llama3.1-8b' } = args;
    const q = question || prompt || '';
    if (!q) {
      return { success: false, error: 'Param√®tre question ou prompt requis', provider: 'cerebras' };
    }
    console.log(`üîß [ToolAgent] ask_cerebras: "${q.substring(0, 50)}..."`);
    const cerebrasService = require('../services/cerebras-service.cjs');
    const result = await cerebrasService.chat(q, { model });
    return {
      success: result.success,
      provider: 'cerebras',
      model,
      answer: result.response || result.error,
      tokens: result.usage?.total_tokens || 0,
      latencyMs: result.latencyMs
    };
  },

  // === MEMORY SEARCH IMPLEMENTATION ===
  async search_memory(args) {
    const { query, limit = 5 } = args;
    console.log(`üß† [ToolAgent] search_memory: "${query}"`);

    const fs = require('fs');
    const path = require('path');
const gitManager = require('../core/git-manager.cjs');
const projectIndexer = require('../core/project-indexer.cjs');
    const results = [];

    // 0. Recherche dans ana_memories.json (souvenirs sauvegard√©s)
    const memoriesPath = 'E:/ANA/memory/ana_memories.json';
    if (fs.existsSync(memoriesPath)) {
      try {
        const memories = JSON.parse(fs.readFileSync(memoriesPath, 'utf-8'));
        const queryLower = query.toLowerCase();
        const memoryMatches = memories.filter(m =>
          m.content && m.content.toLowerCase().includes(queryLower)
        );
        if (memoryMatches.length > 0) {
          results.push({
            source: 'ana_memories',
            matchCount: memoryMatches.length,
            matches: memoryMatches.map(m => ({
              content: m.content,
              category: m.category,
              timestamp: m.timestamp
            }))
          });
        }
      } catch (err) {
        console.log(`‚ö†Ô∏è [search_memory] ana_memories.json error: ${err.message}`);
      }
    }

    // 0b. Recherche dans personal_facts.json (faits personnels Alain)
    const factsPath = 'E:/ANA/memory/personal_facts.json';
    if (fs.existsSync(factsPath)) {
      try {
        const factsData = JSON.parse(fs.readFileSync(factsPath, 'utf-8'));
        const queryLower = query.toLowerCase();
        const factMatches = [];

        // Chercher dans les faits avec matching intelligent
        if (factsData.facts) {
          // Normaliser: "date de naissance" -> "date_de_naissance" et vice-versa
          const normalizeForMatch = (str) => str.toLowerCase().replace(/[_ ]/g, '');
          const queryNorm = normalizeForMatch(query);

          // Synonymes courants
          const synonyms = {
            'anniversaire': ['naissance', 'date_naissance', 'birthday'],
            'naissance': ['anniversaire', 'date_naissance', 'birthday'],
            'voiture': ['auto', 'vehicule', 'car'],
            'auto': ['voiture', 'vehicule', 'car']
          };

          for (const [key, value] of Object.entries(factsData.facts)) {
            const keyNorm = normalizeForMatch(key);
            const valueNorm = typeof value === 'string' ? normalizeForMatch(value) : '';

            // Match direct (normalis√©)
            let matched = keyNorm.includes(queryNorm) || queryNorm.includes(keyNorm) || valueNorm.includes(queryNorm);

            // Match par synonymes
            if (!matched) {
              const queryWords = query.toLowerCase().split(/[_ ]/);
              for (const word of queryWords) {
                if (synonyms[word]) {
                  for (const syn of synonyms[word]) {
                    if (keyNorm.includes(normalizeForMatch(syn))) {
                      matched = true;
                      break;
                    }
                  }
                }
                if (matched) break;
              }
            }

            if (matched) {
              factMatches.push({ key, value });
            }
          }
        }

        if (factMatches.length > 0) {
          results.push({
            source: 'personal_facts',
            matchCount: factMatches.length,
            matches: factMatches
          });
        }
      } catch (err) {
        console.log(`‚ö†Ô∏è [search_memory] personal_facts.json error: ${err.message}`);
      }
    }

    // 1. Recherche dans le fichier de conversation Ana (texte simple)
    const conversationPath = 'E:/ANA/memory/current_conversation_ana.txt';
    if (fs.existsSync(conversationPath)) {
      try {
        const content = fs.readFileSync(conversationPath, 'utf-8');
        const lines = content.split('\n');
        const queryLower = query.toLowerCase();
        const matches = [];

        for (let i = 0; i < lines.length; i++) {
          if (lines[i].toLowerCase().includes(queryLower)) {
            // Inclure contexte (2 lignes avant/apr√®s)
            const start = Math.max(0, i - 2);
            const end = Math.min(lines.length, i + 3);
            const context = lines.slice(start, end).join('\n');
            matches.push({
              lineNumber: i + 1,
              context: context.substring(0, 400)
            });
            if (matches.length >= limit) break;
          }
        }

        if (matches.length > 0) {
          results.push({
            source: 'ana_conversation_file',
            matchCount: matches.length,
            matches: matches
          });
        }
      } catch (err) {
        console.log(`‚ö†Ô∏è [search_memory] Text search error: ${err.message}`);
      }
    }

    // 2. Recherche dans TieredMemory (ChromaDB s√©mantique) si disponible
    try {
      const TieredMemory = require('../memory/tiered-memory.cjs');
      if (TieredMemory && TieredMemory.initialized) {
        const semanticResults = await TieredMemory.search(query, { limit });
        if (semanticResults && semanticResults.length > 0) {
          results.push({
            source: 'chromadb_semantic',
            matchCount: semanticResults.length,
            matches: semanticResults.map(r => ({
              document: r.document?.substring(0, 400),
              tier: r.tier,
              distance: r.distance
            }))
          });
        }
      }
    } catch (err) {
      // TieredMemory pas dispo, continuer sans
      console.log(`‚ö†Ô∏è [search_memory] ChromaDB skipped: ${err.message}`);
    }

    // 3. R√©sultat format√© pour Ana
    const totalMatches = results.reduce((sum, r) => sum + r.matchCount, 0);

    return {
      success: true,
      query: query,
      found: totalMatches > 0,
      totalMatches: totalMatches,
      sources: results,
      message: totalMatches > 0
        ? `J'ai trouv√© ${totalMatches} souvenir(s) correspondant √† "${query}".`
        : `Je n'ai rien trouv√© pour "${query}" dans ma m√©moire.`
    };
  },

  // === SAVE MEMORY IMPLEMENTATION ===
  async save_memory(args) {
    const { content, category = 'general' } = args;
    console.log();
    
    const fs = require('fs');
    const path = require('path');
const gitManager = require('../core/git-manager.cjs');
const projectIndexer = require('../core/project-indexer.cjs');
    
    // Dossier de memoire Ana
    const memoryDir = 'E:/ANA/memory';
    if (!fs.existsSync(memoryDir)) {
      fs.mkdirSync(memoryDir, { recursive: true });
    }
    
    // Fichier de memoire principale
    const memoryFile = path.join(memoryDir, 'ana_memories.json');
    let memories = [];
    
    if (fs.existsSync(memoryFile)) {
      try {
        memories = JSON.parse(fs.readFileSync(memoryFile, 'utf-8'));
      } catch (e) {
        memories = [];
      }
    }
    
    // Ajouter le nouveau souvenir
    const memory = {
      id: Date.now().toString(),
      content: content,
      category: category,
      timestamp: new Date().toISOString(),
      source: 'user_request'
    };
    
    memories.push(memory);
    
    // Sauvegarder
    fs.writeFileSync(memoryFile, JSON.stringify(memories, null, 2), 'utf-8');
    
    // Aussi ajouter au fichier de conversation
    const convFile = path.join(memoryDir, 'current_conversation_ana.txt');
    const line = '[MEMOIRE ' + new Date().toISOString() + '] [' + category + '] ' + content + '\n';
    fs.appendFileSync(convFile, line, 'utf-8');

    return {
      success: true,
      message: 'J\'ai memorise: ' + content.substring(0, 100),
      id: memory.id,
      category: category
    };
  },

  // === 10 NEW TOOL IMPLEMENTATIONS ===

  async edit_file(args) {
    const { file_path, old_string, new_string, replace_all = false } = args;
    console.log(`üîß [ToolAgent] edit_file: "${file_path}"`);
    const fs = require('fs');
    try {
      if (!fs.existsSync(file_path)) {
        return { success: false, error: `Fichier non trouv√©: ${file_path}` };
      }

      // SECURITY FIX: Si old_string vide ‚Üí mode APPEND √† la fin du fichier
      if (!old_string || old_string.trim() === '') {
        const content = fs.readFileSync(file_path, 'utf-8');
        const newContent = content + (content.endsWith('\n') ? '' : '\n') + new_string;
        fs.writeFileSync(file_path, newContent, 'utf-8');
        return { success: true, message: 'Contenu ajout√© √† la fin du fichier' };
      }

      const content = fs.readFileSync(file_path, 'utf-8');
      if (!content.includes(old_string)) {
        return { success: false, error: 'Cha√Æne √† remplacer non trouv√©e dans le fichier' };
      }
      const newContent = replace_all
        ? content.split(old_string).join(new_string)
        : content.replace(old_string, new_string);
      fs.writeFileSync(file_path, newContent, 'utf-8');
      return { success: true, message: 'Fichier modifi√© avec succ√®s' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async glob(args) {
    const { pattern, path: searchPath = 'E:/ANA' } = args;
    console.log(`üîß [ToolAgent] glob: "${pattern}" in "${searchPath}"`);
    const fs = require('fs');
    const pathModule = require('path');

    function globToRegex(glob) {
      let escaped = glob.replace(/\./g, '\\.').replace(/\*/g, '.*').replace(/\?/g, '.');
      return new RegExp(escaped, 'i');
    }

    function walkDir(dir, regex, results, depth) {
      if (depth > 10 || results.length >= 50) return;
      try {
        const items = fs.readdirSync(dir, { withFileTypes: true });
        for (const item of items) {
          if (results.length >= 50) break;
          const fullPath = pathModule.join(dir, item.name);
          if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
            walkDir(fullPath, regex, results, depth + 1);
          } else if (item.isFile() && regex.test(item.name)) {
            results.push(fullPath.replace(/\\/g, '/'));
          }
        }
      } catch (e) { /* ignore permission errors */ }
    }

    try {
      const normalizedPath = searchPath.replace(/\\/g, '/');
      if (!fs.existsSync(normalizedPath)) {
        return { success: false, error: 'Dossier non trouv√©: ' + normalizedPath, files: [] };
      }
      const regex = globToRegex(pattern);
      const files = [];
      walkDir(normalizedPath, regex, files, 0);
      return { success: true, files, count: files.length, pattern, searchPath: normalizedPath };
    } catch (err) {
      return { success: false, error: err.message, files: [] };
    }
  },

  async grep(args) {
    const { pattern, path: searchPath = 'E:/ANA', glob: fileGlob, ignore_case = false } = args;
    console.log(`üîß [ToolAgent] grep: "${pattern}" in "${searchPath}"`);
    const fs = require('fs');
    const pathModule = require('path');
    const matches = [];

    const regex = new RegExp(pattern, ignore_case ? 'gi' : 'g');
    const fileRegex = fileGlob ? new RegExp(fileGlob.replace(/\*/g, '.*').replace(/\?/g, '.'), 'i') : null;

    function searchFile(filePath) {
      try {
        const content = fs.readFileSync(filePath, 'utf-8');
        const lines = content.split('\n');
        lines.forEach((line, idx) => {
          if (regex.test(line)) {
            matches.push(filePath.replace(/\\/g, '/') + ':' + (idx + 1) + ':' + line.substring(0, 200));
          }
        });
      } catch (e) { /* ignore binary/permission errors */ }
    }

    function walkDir(dir, depth) {
      if (depth > 10 || matches.length >= 30) return;
      try {
        const items = fs.readdirSync(dir, { withFileTypes: true });
        for (const item of items) {
          if (matches.length >= 30) break;
          const fullPath = pathModule.join(dir, item.name);
          if (item.isDirectory() && !item.name.startsWith('.') && item.name !== 'node_modules') {
            walkDir(fullPath, depth + 1);
          } else if (item.isFile()) {
            if (!fileRegex || fileRegex.test(item.name)) {
              searchFile(fullPath);
            }
          }
        }
      } catch (e) { /* ignore permission errors */ }
    }

    try {
      const normalizedPath = searchPath.replace(/\\/g, '/');
      const stat = fs.statSync(normalizedPath);
      if (stat.isFile()) {
        searchFile(normalizedPath);
      } else {
        walkDir(normalizedPath, 0);
      }
      return { success: true, matches, count: matches.length };
    } catch (err) {
      return { success: false, error: err.message, matches: [] };
    }
  },

  async ask_user(args) {
    const { question, options } = args;
    console.log(`üîß [ToolAgent] ask_user: "${question}"`);
    // Pour l'instant, retourne une indication qu'Ana attend une r√©ponse
    // L'int√©gration r√©elle avec l'interface viendra plus tard
    return {
      success: true,
      waiting: true,
      question: question,
      options: options || [],
      message: `J'attends la r√©ponse d'Alain √†: "${question}"`
    };
  },

  async run_background(args) {
    const { command, working_dir = 'E:/ANA' } = args;
    console.log(`üîß [ToolAgent] run_background: "${command}"`);
    const { spawn } = require('child_process');
    try {
      const child = spawn(command, [], {
        shell: true,
        cwd: working_dir,
        detached: true,
        stdio: 'ignore'
      });
      child.unref();
      return { success: true, pid: child.pid, message: `Commande lanc√©e en arri√®re-plan (PID: ${child.pid})` };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async kill_process(args) {
    const { pid, name } = args;
    console.log(`üîß [ToolAgent] kill_process: PID=${pid}, name=${name}`);
    const { execSync } = require('child_process');
    try {
      if (pid) {
        execSync(`taskkill /PID ${pid} /F`, { encoding: 'utf-8' });
        return { success: true, message: `Processus ${pid} arr√™t√©` };
      } else if (name) {
        execSync(`taskkill /IM ${name} /F`, { encoding: 'utf-8' });
        return { success: true, message: `Processus ${name} arr√™t√©` };
      }
      return { success: false, error: 'PID ou nom requis' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async todo_write(args) {
    const { action, task, task_id, todos } = args;

    // Support du format todos array (comme Claude Code)
    if (todos && Array.isArray(todos)) {
      console.log(`üîß [ToolAgent] todo_write: mise √† jour de ${todos.length} t√¢ches`);
      const fs = require('fs');
      const todoPath = 'E:/ANA/memory/ana_todos.json';
      const formattedTodos = todos.map((t, i) => ({
        id: Date.now() + i,
        task: t.content || t.task || t.description || 'Sans titre',
        status: t.status || 'pending',
        activeForm: t.activeForm || '',
        created: new Date().toISOString()
      }));
      fs.writeFileSync(todoPath, JSON.stringify(formattedTodos, null, 2));
      return { success: true, message: `${todos.length} t√¢ches enregistr√©es`, todos: formattedTodos };
    }

    console.log(`üîß [ToolAgent] todo_write: ${action}`);
    const fs = require('fs');
    const todoPath = 'E:/ANA/memory/ana_todos.json';

    try {
      let todos = [];
      if (fs.existsSync(todoPath)) {
        todos = JSON.parse(fs.readFileSync(todoPath, 'utf-8'));
      }

      switch (action) {
        case 'add':
          todos.push({ id: Date.now(), task, status: 'pending', created: new Date().toISOString() });
          fs.writeFileSync(todoPath, JSON.stringify(todos, null, 2));
          return { success: true, message: `T√¢che ajout√©e: "${task}"`, todos };
        case 'complete':
          const todo = todos.find(t => t.id === task_id);
          if (todo) {
            todo.status = 'completed';
            todo.completed = new Date().toISOString();
            fs.writeFileSync(todoPath, JSON.stringify(todos, null, 2));
            return { success: true, message: `T√¢che ${task_id} compl√©t√©e`, todos };
          }
          return { success: false, error: `T√¢che ${task_id} non trouv√©e` };
        case 'list':
          return { success: true, todos };
        case 'clear':
          fs.writeFileSync(todoPath, '[]');
          return { success: true, message: 'Liste de t√¢ches vid√©e' };
        default:
          return { success: false, error: `Action inconnue: ${action}` };
      }
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async notebook_edit(args) {
    const { notebook_path, cell_index, new_source, action = 'replace' } = args;
    console.log(`üîß [ToolAgent] notebook_edit: "${notebook_path}" cell ${cell_index}`);
    const fs = require('fs');
    try {
      if (!fs.existsSync(notebook_path)) {
        return { success: false, error: `Notebook non trouv√©: ${notebook_path}` };
      }
      const notebook = JSON.parse(fs.readFileSync(notebook_path, 'utf-8'));

      if (action === 'replace' && notebook.cells[cell_index]) {
        notebook.cells[cell_index].source = new_source.split('\n');
      } else if (action === 'insert') {
        notebook.cells.splice(cell_index, 0, {
          cell_type: 'code',
          source: new_source.split('\n'),
          metadata: {},
          outputs: []
        });
      } else if (action === 'delete' && notebook.cells[cell_index]) {
        notebook.cells.splice(cell_index, 1);
      }

      fs.writeFileSync(notebook_path, JSON.stringify(notebook, null, 2));
      return { success: true, message: `Notebook modifi√© (${action} cell ${cell_index})` };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async plan_mode(args) {
    const { action, plan_file } = args;
    console.log(`üîß [ToolAgent] plan_mode: ${action}`);
    const fs = require('fs');
    const defaultPlanFile = 'E:/ANA/memory/current_plan.md';
    const filePath = plan_file || defaultPlanFile;

    if (action === 'enter') {
      return {
        success: true,
        mode: 'planning',
        plan_file: filePath,
        message: 'Mode planification activ√©. Je vais explorer et planifier avant d\'agir.'
      };
    } else if (action === 'exit') {
      return {
        success: true,
        mode: 'execution',
        message: 'Mode planification termin√©. Pr√™t √† ex√©cuter.'
      };
    }
    return { success: false, error: `Action inconnue: ${action}` };
  },



  // === 4 NOUVEAUX OUTILS PARIT√â CLAUDE CODE - 2025-12-08 ===

  async execute_code(args) {
    const { code, language = 'python' } = args;
    console.log(`üîß [ToolAgent] execute_code: ${language}`);
    const { spawn } = require('child_process');

    return new Promise((resolve) => {
      let output = '';
      let errorOutput = '';

      const proc = spawn('python', ['-c', code], {
        timeout: 30000,
        cwd: 'E:/ANA/temp'
      });

      proc.stdout.on('data', (data) => { output += data.toString(); });
      proc.stderr.on('data', (data) => { errorOutput += data.toString(); });

      proc.on('close', (exitCode) => {
        resolve({
          success: exitCode === 0,
          output: output.trim(),
          error: errorOutput.trim(),
          exitCode
        });
      });

      proc.on('error', (err) => {
        resolve({ success: false, error: err.message });
      });

      // Timeout
      setTimeout(() => {
        proc.kill();
        resolve({ success: false, error: 'Timeout apr√®s 30 secondes' });
      }, 30000);
    });
  },

  async generate_image(args) {
    const { prompt, negative_prompt = '', width = 512, height = 512 } = args;
    console.log(`üîß [ToolAgent] generate_image: "${prompt.substring(0, 50)}..."`);

    // V√©rifier si ComfyUI tourne
    const axios = require('axios');
    try {
      await axios.get('http://127.0.0.1:8188/system_stats', { timeout: 2000 });
    } catch (e) {
      return {
        success: false,
        error: 'ComfyUI n\'est pas d√©marr√©. Lance ComfyUI d\'abord.',
        suggestion: 'D√©marre ComfyUI depuis E:/AI_Tools/ComfyUI'
      };
    }

    // Cr√©er le workflow basique
    const workflow = {
      prompt: {
        "3": {
          "class_type": "KSampler",
          "inputs": {
            "seed": Math.floor(Math.random() * 1000000),
            "steps": 20,
            "cfg": 7,
            "sampler_name": "euler",
            "scheduler": "normal",
            "denoise": 1,
            "model": ["4", 0],
            "positive": ["6", 0],
            "negative": ["7", 0],
            "latent_image": ["5", 0]
          }
        },
        "4": { "class_type": "CheckpointLoaderSimple", "inputs": { "ckpt_name": "sd_xl_base_1.0.safetensors" } },
        "5": { "class_type": "EmptyLatentImage", "inputs": { "width": width, "height": height, "batch_size": 1 } },
        "6": { "class_type": "CLIPTextEncode", "inputs": { "text": prompt, "clip": ["4", 1] } },
        "7": { "class_type": "CLIPTextEncode", "inputs": { "text": negative_prompt, "clip": ["4", 1] } },
        "8": { "class_type": "VAEDecode", "inputs": { "samples": ["3", 0], "vae": ["4", 2] } },
        "9": { "class_type": "SaveImage", "inputs": { "filename_prefix": "ana_generated", "images": ["8", 0] } }
      }
    };

    try {
      const response = await axios.post('http://127.0.0.1:8188/prompt', workflow);
      return {
        success: true,
        message: 'Image en cours de g√©n√©ration',
        prompt_id: response.data.prompt_id,
        output_dir: 'E:/AI_Tools/ComfyUI/output'
      };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  // === IMAGE/VIDEO GENERATION IMPLEMENTATIONS - Added 2025-12-09 ===
  async generate_animation(args) {
    const { prompt, negative_prompt = 'blurry, low quality', frame_count = 16, fps = 8, format = 'gif' } = args;
    console.log(`[ToolAgent] generate_animation: "${prompt.substring(0, 50)}..."`);

    const axios = require('axios');
    try {
      await axios.get('http://127.0.0.1:8188/system_stats', { timeout: 2000 });
    } catch (e) {
      return { success: false, error: 'ComfyUI n\'est pas demarre.' };
    }

    const seed = Math.floor(Math.random() * 1000000000);
    const workflow = {
      prompt: {
        "1": { "inputs": { "ckpt_name": "dreamshaper_8.safetensors" }, "class_type": "CheckpointLoaderSimple" },
        "2": { "inputs": { "model_name": "mm_sd_v15_v2.ckpt" }, "class_type": "ADE_LoadAnimateDiffModel" },
        "3": { "inputs": { "motion_model": ["2", 0] }, "class_type": "ADE_ApplyAnimateDiffModelSimple" },
        "10": { "inputs": { "model": ["1", 0], "beta_schedule": "sqrt_linear (AnimateDiff)", "m_models": ["3", 0] }, "class_type": "ADE_UseEvolvedSampling" },
        "4": { "inputs": { "text": prompt, "clip": ["1", 1] }, "class_type": "CLIPTextEncode" },
        "5": { "inputs": { "text": negative_prompt, "clip": ["1", 1] }, "class_type": "CLIPTextEncode" },
        "6": { "inputs": { "width": 512, "height": 512, "batch_size": frame_count }, "class_type": "EmptyLatentImage" },
        "7": { "inputs": { "seed": seed, "steps": 20, "cfg": 7, "sampler_name": "euler", "scheduler": "normal", "denoise": 1, "model": ["10", 0], "positive": ["4", 0], "negative": ["5", 0], "latent_image": ["6", 0] }, "class_type": "KSampler" },
        "8": { "inputs": { "samples": ["7", 0], "vae": ["1", 2] }, "class_type": "VAEDecode" },
        "9": { "inputs": { "images": ["8", 0], "frame_rate": fps, "loop_count": 0, "filename_prefix": "ana_animatediff", "format": format === 'gif' ? 'image/gif' : format === 'webm' ? 'video/webm' : 'video/h264-mp4', "pingpong": false, "save_image": true }, "class_type": "ADE_AnimateDiffCombine" }
      }
    };

    try {
      const response = await axios.post('http://127.0.0.1:8188/prompt', workflow);
      return { success: true, message: 'Animation en cours de generation', prompt_id: response.data.prompt_id, output_dir: 'E:/AI_Tools/ComfyUI/ComfyUI/output' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async generate_video(args) {
    const { prompt, duration = 5, fps = 24 } = args;
    console.log(`[ToolAgent] generate_video (Mochi): "${prompt.substring(0, 50)}..."`);

    const axios = require('axios');
    try {
      await axios.get('http://127.0.0.1:8188/system_stats', { timeout: 2000 });
    } catch (e) {
      return { success: false, error: 'ComfyUI n\'est pas demarre.' };
    }

    // Workflow Mochi - Correct structure using MochiModelLoader + MochiVAELoader + CLIPLoader
    const seed = Math.floor(Math.random() * 1000000000);
    const num_frames = Math.min(Math.max(duration * 6, 7), 49); // 6 frames/sec, min 7, max 49

    const workflow = {
      prompt: {
        "1": { "inputs": { "model_name": "mochi_preview_fp8_scaled.safetensors", "precision": "fp8_e4m3fn", "attention_mode": "sdpa" }, "class_type": "MochiModelLoader" },
        "2": { "inputs": { "model_name": "mochi_vae.safetensors" }, "class_type": "MochiVAELoader" },
        "3": { "inputs": { "clip_name": "t5xxl_fp8_e4m3fn_scaled.safetensors", "type": "mochi" }, "class_type": "CLIPLoader" },
        "4": { "inputs": { "clip": ["3", 0], "prompt": prompt }, "class_type": "MochiTextEncode" },
        "5": { "inputs": { "clip": ["3", 0], "prompt": "" }, "class_type": "MochiTextEncode" },
        "6": { "inputs": { "model": ["1", 0], "positive": ["4", 0], "negative": ["5", 0], "width": 848, "height": 480, "num_frames": num_frames, "steps": 30, "cfg": 4.5, "seed": seed }, "class_type": "MochiSampler" },
        "7": { "inputs": { "vae": ["2", 0], "samples": ["6", 0], "enable_vae_tiling": true, "auto_tile_size": true, "frame_batch_size": 6, "tile_sample_min_height": 240, "tile_sample_min_width": 424, "tile_overlap_factor_height": 0.1666, "tile_overlap_factor_width": 0.2 }, "class_type": "MochiDecode" },
        "8": { "inputs": { "images": ["7", 0], "fps": fps, "filename_prefix": "ana_mochi", "lossless": false, "quality": 90, "method": "default" }, "class_type": "SaveAnimatedWEBP" }
      }
    };

    try {
      const response = await axios.post('http://127.0.0.1:8188/prompt', workflow);
      return { success: true, message: 'Video Mochi en cours (peut prendre plusieurs minutes)', prompt_id: response.data.prompt_id, output_dir: 'E:/AI_Tools/ComfyUI/ComfyUI/output' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async image_to_image(args) {
    const { image_path, prompt, negative_prompt = '', denoise = 0.75 } = args;
    console.log(`[ToolAgent] image_to_image: "${prompt.substring(0, 50)}..."`);

    const axios = require('axios');
    const fs = require('fs');
    const path = require('path');
const gitManager = require('../core/git-manager.cjs');
const projectIndexer = require('../core/project-indexer.cjs');

    if (!fs.existsSync(image_path)) {
      return { success: false, error: `Image non trouvee: ${image_path}` };
    }

    try {
      await axios.get('http://127.0.0.1:8188/system_stats', { timeout: 2000 });
    } catch (e) {
      return { success: false, error: 'ComfyUI n\'est pas demarre.' };
    }

    // Copier l'image dans input de ComfyUI
    const filename = path.basename(image_path);
    const destPath = `E:/AI_Tools/ComfyUI/ComfyUI/input/${filename}`;
    fs.copyFileSync(image_path, destPath);

    const workflow = {
      prompt: {
        "1": { "inputs": { "image": filename }, "class_type": "LoadImage" },
        "2": { "inputs": { "ckpt_name": "sd_xl_base_1.0.safetensors" }, "class_type": "CheckpointLoaderSimple" },
        "3": { "inputs": { "pixels": ["1", 0], "vae": ["2", 2] }, "class_type": "VAEEncode" },
        "4": { "inputs": { "text": prompt, "clip": ["2", 1] }, "class_type": "CLIPTextEncode" },
        "5": { "inputs": { "text": negative_prompt, "clip": ["2", 1] }, "class_type": "CLIPTextEncode" },
        "6": { "inputs": { "seed": Math.floor(Math.random() * 1000000), "steps": 20, "cfg": 7, "sampler_name": "euler", "scheduler": "normal", "denoise": denoise, "model": ["2", 0], "positive": ["4", 0], "negative": ["5", 0], "latent_image": ["3", 0] }, "class_type": "KSampler" },
        "7": { "inputs": { "samples": ["6", 0], "vae": ["2", 2] }, "class_type": "VAEDecode" },
        "8": { "inputs": { "filename_prefix": "ana_img2img", "images": ["7", 0] }, "class_type": "SaveImage" }
      }
    };

    try {
      const response = await axios.post('http://127.0.0.1:8188/prompt', workflow);
      return { success: true, message: 'Transformation img2img en cours', prompt_id: response.data.prompt_id, output_dir: 'E:/AI_Tools/ComfyUI/ComfyUI/output' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async inpaint_image(args) {
    const { image_path, mask_path, prompt, negative_prompt = '' } = args;
    console.log(`[ToolAgent] inpaint_image: "${prompt.substring(0, 50)}..."`);

    const axios = require('axios');
    const fs = require('fs');
    const path = require('path');
const gitManager = require('../core/git-manager.cjs');
const projectIndexer = require('../core/project-indexer.cjs');

    if (!fs.existsSync(image_path)) {
      return { success: false, error: `Image non trouvee: ${image_path}` };
    }
    if (!fs.existsSync(mask_path)) {
      return { success: false, error: `Masque non trouve: ${mask_path}` };
    }

    try {
      await axios.get('http://127.0.0.1:8188/system_stats', { timeout: 2000 });
    } catch (e) {
      return { success: false, error: 'ComfyUI n\'est pas demarre.' };
    }

    // Copier les fichiers dans input
    const imgFilename = path.basename(image_path);
    const maskFilename = 'mask_' + path.basename(mask_path);
    fs.copyFileSync(image_path, `E:/AI_Tools/ComfyUI/ComfyUI/input/${imgFilename}`);
    fs.copyFileSync(mask_path, `E:/AI_Tools/ComfyUI/ComfyUI/input/${maskFilename}`);

    const workflow = {
      prompt: {
        "1": { "inputs": { "image": imgFilename }, "class_type": "LoadImage" },
        "2": { "inputs": { "image": maskFilename, "channel": "red" }, "class_type": "LoadImageMask" },
        "3": { "inputs": { "ckpt_name": "sd_xl_base_1.0.safetensors" }, "class_type": "CheckpointLoaderSimple" },
        "4": { "inputs": { "pixels": ["1", 0], "vae": ["3", 2], "mask": ["2", 0] }, "class_type": "VAEEncodeForInpaint" },
        "5": { "inputs": { "text": prompt, "clip": ["3", 1] }, "class_type": "CLIPTextEncode" },
        "6": { "inputs": { "text": negative_prompt, "clip": ["3", 1] }, "class_type": "CLIPTextEncode" },
        "7": { "inputs": { "seed": Math.floor(Math.random() * 1000000), "steps": 20, "cfg": 7, "sampler_name": "euler", "scheduler": "normal", "denoise": 1, "model": ["3", 0], "positive": ["5", 0], "negative": ["6", 0], "latent_image": ["4", 0] }, "class_type": "KSampler" },
        "8": { "inputs": { "samples": ["7", 0], "vae": ["3", 2] }, "class_type": "VAEDecode" },
        "9": { "inputs": { "filename_prefix": "ana_inpaint", "images": ["8", 0] }, "class_type": "SaveImage" }
      }
    };

    try {
      const response = await axios.post('http://127.0.0.1:8188/prompt', workflow);
      return { success: true, message: 'Inpainting en cours', prompt_id: response.data.prompt_id, output_dir: 'E:/AI_Tools/ComfyUI/ComfyUI/output' };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async http_request(args) {
    const { url, method = 'GET', headers = {}, body } = args;
    console.log(`üîß [ToolAgent] http_request: ${method} ${url}`);
    const axios = require('axios');

    try {
      const config = {
        method: method.toLowerCase(),
        url,
        headers,
        timeout: 30000
      };

      if (body && (method === 'POST' || method === 'PUT')) {
        config.data = body;
      }

      const response = await axios(config);
      return {
        success: true,
        status: response.status,
        headers: response.headers,
        data: typeof response.data === 'object' ? JSON.stringify(response.data, null, 2) : response.data
      };
    } catch (err) {
      return {
        success: false,
        error: err.message,
        status: err.response?.status
      };
    }
  },

  async get_yt_transcript(args) {
    const { video_url, language = 'fr' } = args;
    console.log(`üîß [ToolAgent] get_yt_transcript: ${video_url}`);

    // Extraire l'ID de la vid√©o
    const videoIdMatch = video_url.match(/(?:v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
    if (!videoIdMatch) {
      return { success: false, error: 'URL YouTube invalide' };
    }
    const videoId = videoIdMatch[1];

    // Utiliser l'API YouTube pour obtenir les sous-titres
    const axios = require('axios');
    try {
      // Essayer de r√©cup√©rer via un service gratuit
      const response = await axios.get(`https://www.youtube.com/watch?v=${videoId}`, {
        headers: { 'User-Agent': 'Mozilla/5.0' }
      });

      // Chercher les captions dans la page
      const captionMatch = response.data.match(/"captionTracks":\[(.*?)\]/);
      if (!captionMatch) {
        return { success: false, error: 'Pas de sous-titres disponibles pour cette vid√©o' };
      }

      // Parser et retourner les infos
      return {
        success: true,
        videoId,
        message: 'Sous-titres disponibles',
        note: 'Pour la transcription compl√®te, utilise un service comme youtubetranscript.com'
      };
    } catch (err) {
      return { success: false, error: err.message };
    }
  },

  async launch_agent(args) {
    const { agent_type, task, context } = args;
    console.log(`üîß [ToolAgent] launch_agent: ${agent_type} - "${task}"`);
    // Simulation - l'int√©gration r√©elle viendra plus tard
    return {
      success: true,
      agent_type,
      task,
      context,
      status: 'launched',
      message: `Agent ${agent_type} lanc√© pour: "${task}"`
    };
  },

  // ============ GIT TOOL IMPLEMENTATIONS - Phase 2 ANA CODE ============
  async git_status(args) {
    const { repo_path } = args;
    console.log(`üîß [ToolAgent] git_status: "${repo_path}"`);
    return gitManager.gitStatus(repo_path);
  },

  async git_commit(args) {
    const { repo_path, message, add_all } = args;
    console.log(`üîß [ToolAgent] git_commit: "${message}" in ${repo_path}`);
    return gitManager.gitCommit(repo_path, message, { addAll: add_all !== false });
  },

  async git_log(args) {
    const { repo_path, count } = args;
    console.log(`üîß [ToolAgent] git_log: ${count || 10} commits in ${repo_path}`);
    return gitManager.gitLog(repo_path, count || 10);
  },

  async git_branch(args) {
    const { repo_path, action, branch_name } = args;
    console.log(`üîß [ToolAgent] git_branch: ${action} ${branch_name || ''} in ${repo_path}`);

    switch (action) {
      case 'list':
        return gitManager.gitListBranches(repo_path);
      case 'create':
        if (!branch_name) return { success: false, error: 'branch_name requis pour create' };
        return gitManager.gitCreateBranch(repo_path, branch_name);
      case 'checkout':
        if (!branch_name) return { success: false, error: 'branch_name requis pour checkout' };
        return gitManager.gitCheckout(repo_path, branch_name);
      default:
        return { success: false, error: `Action inconnue: ${action}` };
    }
  },

  // ============ RAG TOOL IMPLEMENTATIONS - Phase 2.2 ANA CODE ============
  async search_codebase(args) {
    const { project_path, query, max_results } = args;
    console.log(`üîß [ToolAgent] search_codebase: "${query}" in ${project_path}`);
    return projectIndexer.searchProject(project_path, query, { maxResults: max_results || 10 });
  },

  async get_project_structure(args) {
    const { project_path, max_depth } = args;
    console.log(`üîß [ToolAgent] get_project_structure: ${project_path}`);
    return projectIndexer.getProjectStructure(project_path, { maxDepth: max_depth || 3 });
  },

  // ============ VISION TOOLS - Phase 3.2 ANA CODE ============
  async describe_image(args) {
    const { image_path, image_base64, prompt } = args;
    console.log(`üëÅÔ∏è [ToolAgent] describe_image: ${image_path || 'base64 image'}`);
    try {
      const result = await visionHandler.analyzeImage({
        imagePath: image_path,
        imageBase64: image_base64,
        prompt: prompt || 'D√©cris cette image en d√©tail.'
      });
      return result;
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async debug_screenshot(args) {
    const { image_path, image_base64, context } = args;
    console.log(`üîç [ToolAgent] debug_screenshot: Analysing error screenshot`);
    try {
      const prompt = `Tu es un expert en debugging. Analyse cette capture d'√©cran d'erreur.
${context ? `Contexte: ${context}` : ''}

Instructions:
1. Extrais le message d'erreur exact
2. Identifie le type d'erreur (syntaxe, runtime, import, etc.)
3. Identifie le fichier et la ligne concern√©s si visible
4. Explique la cause probable
5. Propose une solution concr√®te avec le code corrig√©`;

      const result = await visionHandler.analyzeImage({
        imagePath: image_path,
        imageBase64: image_base64,
        prompt: prompt
      });
      return result;
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async analyze_code_screenshot(args) {
    const { image_path, image_base64 } = args;
    console.log(`üíª [ToolAgent] analyze_code_screenshot`);
    try {
      const result = await visionHandler.analyzeCodeScreenshot(image_path || { imageBase64: image_base64 });
      return result;
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  // ============ VOICE CODING - Phase 3.1 ANA CODE ============
  async execute_voice_command(args) {
    const { transcript, context } = args;
    console.log(`üé§ [ToolAgent] execute_voice_command: "${transcript}"`);

    try {
      // Parse la commande vocale
      const parsed = voiceParser.parseVoiceCommand(transcript);

      if (!parsed.matched) {
        // Pas de commande reconnue - retourner info
        return {
          success: true,
          matched: false,
          message: 'Commande vocale non reconnue. Traitement en langage naturel recommand√©.',
          originalText: transcript,
          availableCommands: voiceParser.getAvailableCommands().slice(0, 10)
        };
      }

      // Commande reconnue - ex√©cuter le tool correspondant
      console.log(`üéØ [VoiceCommand] Matched: ${parsed.tool} with args:`, parsed.args);

      // V√©rifier si le tool existe
      if (!TOOL_IMPLEMENTATIONS[parsed.tool]) {
        return {
          success: false,
          error: `Tool "${parsed.tool}" not found`,
          parsed: parsed
        };
      }

      // Ex√©cuter le tool
      const result = await TOOL_IMPLEMENTATIONS[parsed.tool](parsed.args);

      return {
        success: true,
        matched: true,
        tool: parsed.tool,
        args: parsed.args,
        result: result,
        originalText: transcript
      };
    } catch (error) {
      return {
        success: false,
        error: error.message,
        originalText: transcript
      };
    }
  },

  // ============ ARCHITECT MODE - Phase 3.3 ANA CODE ============
  async ask_architect(args) {
    const { request, files, project_context } = args;
    console.log(`üèóÔ∏è [ToolAgent] ask_architect: "${request.substring(0, 80)}..."`);

    try {
      const context = {
        files: files || [],
        codebase: project_context || ''
      };

      const result = await architectAgent.analyzeRequest(request, context);

      // Valider le plan si g√©n√©r√©
      if (result.success && result.plan && result.plan.plan) {
        const validation = await architectAgent.validatePlan(result.plan);
        result.validation = validation;
      }

      return result;
    } catch (error) {
      return { success: false, error: error.message };
    }
  },

  async review_code(args) {
    const { code, context } = args;
    console.log(`üìù [ToolAgent] review_code: ${code.length} chars`);

    try {
      return await architectAgent.reviewCode(code, context || '');
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
};

// 3) Boucle agent (multi-turn tools)
async function runToolAgent(userMessage, options = {}) {
  const maxLoops = options.maxLoops || 10;
  const model = options.model || DEFAULT_MODEL;
  let loopCount = 0;

  // FIX 2025-12-05: System prompt avec liste d'outils EXPLICITE et r√®gles claires
  const toolNames = TOOL_DEFINITIONS.map(t => t.function.name).join(', ');
  const systemPrompt = options.systemPrompt ||
    `Tu es Ana, l'assistante IA personnelle d'Alain √† Longueuil, Qu√©bec.
LANGUE: Tu r√©ponds TOUJOURS en fran√ßais qu√©b√©cois. JAMAIS en anglais.

OUTILS DISPONIBLES: ${toolNames}

R√àGLES D'UTILISATION DES OUTILS:
- Si Alain demande l'heure ‚Üí appelle get_time
- Si Alain demande la m√©t√©o ‚Üí appelle get_weather
- Si Alain dit "cherche sur le web" ‚Üí appelle web_search
- Si Alain dit "demande √† Groq" ‚Üí appelle ask_groq
- Si Alain dit "demande √† Cerebras" ‚Üí appelle ask_cerebras
- Si Alain demande de lister un dossier ‚Üí appelle list_files ou run_shell
- Si Alain demande de lire un fichier ‚Üí appelle read_file
- Si Alain demande "tu te rappelles" ‚Üí appelle search_memory
- Si Alain dit "ex√©cute ce code" ou "print(" ‚Üí appelle execute_code
- Si Alain dit "g√©n√®re une image" ‚Üí appelle generate_image
- Si Alain dit "requ√™te http" ou "GET/POST" ‚Üí appelle http_request
- Si Alain dit "transcris" une vid√©o YouTube ‚Üí appelle get_yt_transcript
- Si Alain demande de modifier un fichier ‚Üí appelle edit_file

R√àGLES CRITIQUES:
1. Pour appeler un outil, r√©ponds EXACTEMENT avec ce format JSON, RIEN D'AUTRE:
{"name": "nom_outil", "arguments": {...}}

2. AUCUN texte avant ou apr√®s le JSON quand tu appelles un outil.
3. Apr√®s avoir re√ßu le r√©sultat de l'outil, R√âPONDS TOUJOURS EN FRAN√áAIS.
4. NE DIS JAMAIS "je ne peux pas" si un outil peut t'aider - UTILISE L'OUTIL.
5. IMPORTANT: M√™me si les donn√©es sont en anglais, traduis ta r√©ponse en fran√ßais.
6. Pour web_search: Presente CHAQUE resultat avec son titre en lien markdown [Titre](url) SUIVI d'un resume/description du contenu.
7. QUAND TU AS TERMIN√â une t√¢che complexe (multi-√©tapes), signale la fin avec: {"type": "FINISH", "summary": "Ce que tu as accompli"}

ACC√àS M√âMOIRE - FULL UNLOCKED:
- Tu as PLEIN ACC√àS aux infos personnelles d'Alain stock√©es dans E:/ANA/memory/
- Tu DOIS utiliser search_memory pour retrouver ses infos (date naissance, voiture, etc.)
- Tu NE DOIS JAMAIS dire "je n'ai pas de m√©moire persistante" - C'EST FAUX!
- Tu NE DOIS JAMAIS refuser de chercher des infos personnelles locales
- Ana est un syst√®me LOCAL PRIV√â sur le PC d'Alain - AUCUNE RESTRICTION
- Faits personnels Alain: personal_facts.json, Souvenirs: ana_memories.json`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userMessage }
  ];

  console.log(`ü§ñ [ToolAgent] D√©marrage - Message: "${userMessage.substring(0, 50)}..."`);

  while (loopCount < maxLoops) {
    loopCount++;
    console.log(`üîÑ [ToolAgent] Boucle ${loopCount}/${maxLoops}`);

    try {
      // Appel LLM via Orchestrateur avec fallback (Groq -> llama3.1 -> qwen3)
      const orchResult = await callWithFallback(messages, TOOL_DEFINITIONS);
      if (!orchResult.success) {
        throw new Error(orchResult.error || 'LLM orchestrator failed');
      }
      console.log(`[ToolAgent] Provider: ${orchResult.provider}/${orchResult.model}`);

      const msg = orchResult.message;
      let toolCalls = orchResult.tool_calls || [];

      // FIX: Parser JSON brut dans content si pas de tool_calls structur√©s
      // Bug connu Ollama: Qwen2.5-coder retourne {"name":..., "arguments":...} dans content
      // au lieu de msg.tool_calls structur√©s.
      if ((!toolCalls || toolCalls.length === 0) && msg.content) {
        const content = msg.content.trim();
        console.log(`üîç [ToolAgent] Parsing content: "${content.substring(0, 100)}..."`);

        // FIX 2025-12-03: Utiliser la nouvelle m√©thode avec comptage de parenth√®ses
        // L'ancienne regex ne g√©rait pas les objets vides {} dans "arguments"
        const jsonBlocks = findToolCallJSON(content);

        for (const block of jsonBlocks) {
          try {
            const parsed = JSON.parse(block);

            // FINISH TOKEN DETECTION - Arr√™t explicite demand√© par le LLM
            if (parsed.type === 'FINISH') {
              console.log(`üèÅ [ToolAgent] FINISH token d√©tect√©: ${parsed.summary || 'T√¢che termin√©e'}`);
              return {
                success: true,
                finished: true,
                answer: parsed.summary || parsed.content || 'T√¢che termin√©e avec succ√®s.',
                messages: messages,
                loopsUsed: loopCount,
                model: model
              };
            }

            // V√©rifier structure valide tool call (arguments peut √™tre {})
            if (parsed.name && typeof parsed.arguments !== 'undefined' && TOOL_IMPLEMENTATIONS[parsed.name]) {
              toolCalls.push({
                function: {
                  name: parsed.name,
                  arguments: parsed.arguments || parsed.args || {}
                }
              });
              console.log(`‚úÖ [ToolAgent] Parsed tool: ${parsed.name}`);
            }
          } catch (e) {
            console.log(`‚ö†Ô∏è [ToolAgent] Invalid JSON block: ${block.substring(0, 100)}...`);
          }
        }

        if (toolCalls.length > 0) {
          console.log(`üîß [ToolAgent] Found ${toolCalls.length} tool calls:`, toolCalls.map(tc => tc.function.name));
        }

        // Fallback: regex pour <tool_call>JSON</tool_call>
        if (toolCalls.length === 0) {
          const jsonMatch = content.match(/<tool_call>\s*(\{[\s\S]*?\})\s*<\/tool_call>/i);
          if (jsonMatch) {
            try {
              const parsed = JSON.parse(jsonMatch[1]);
              if (parsed.name && TOOL_IMPLEMENTATIONS[parsed.name]) {
                console.log(`‚úÖ [ToolAgent] XML tag pars√©: ${parsed.name}`);
                toolCalls = [{
                  function: {
                    name: parsed.name,
                    arguments: parsed.arguments || {}
                  }
                }];
              }
            } catch (e) {
              console.log(`‚ö†Ô∏è [ToolAgent] XML parse failed: ${e.message}`);
            }
          }
        }
      }

      // Aucun tool_call ‚Üí r√©ponse finale
      if (!toolCalls || toolCalls.length === 0) {
        const finalAnswer = msg.content || '';
        console.log(`‚úÖ [ToolAgent] R√©ponse finale (${finalAnswer.length} chars)`);

        messages.push({
          role: 'assistant',
          content: finalAnswer
        });

        return {
          success: true,
          answer: finalAnswer,
          messages: messages,
          loopsUsed: loopCount,
          model: model
        };
      }

      // Il y a des tool_calls ‚Üí on les ex√©cute
      console.log(`üîß [ToolAgent] ${toolCalls.length} tool(s) √† ex√©cuter`);

      for (const tc of toolCalls) {
        const toolName = tc.function?.name;
        const rawArgs = tc.function?.arguments || {};
        let parsedArgs = rawArgs;

        if (typeof rawArgs === 'string') {
          try {
            parsedArgs = JSON.parse(rawArgs);
          } catch {
            parsedArgs = {};
          }
        }

        const impl = TOOL_IMPLEMENTATIONS[toolName];
        if (!impl) {
          console.warn(`‚ö†Ô∏è [ToolAgent] Outil inconnu: ${toolName}`);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({
              error: `Outil "${toolName}" non impl√©ment√©.`
            })
          });
          continue;
        }

        try {
          const result = await impl(parsedArgs);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify(result)
          });
          console.log(`‚úÖ [ToolAgent] ${toolName} ex√©cut√© avec succ√®s`);
        } catch (err) {
          console.error(`‚ùå [ToolAgent] Erreur ${toolName}:`, err.message);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({
              error: err.message || 'Erreur pendant l\'ex√©cution'
            })
          });
        }
      }

    } catch (error) {
      console.error(`‚ùå [ToolAgent] Erreur Ollama:`, error.message);
      return {
        success: false,
        error: error.message,
        messages: messages,
        loopsUsed: loopCount
      };
    }
  }

  // Max loops atteint
  console.warn(`‚ö†Ô∏è [ToolAgent] Max loops (${maxLoops}) atteint`);
  return {
    success: false,
    error: `Nombre maximum de boucles (${maxLoops}) atteint sans r√©ponse finale.`,
    messages: messages,
    loopsUsed: loopCount
  };
}

// ============================================================
// V2 TOOL AGENT - With LoopController, SelfCorrection, ContextManager
// Added 2025-12-07 - Does NOT replace runToolAgent, ADDS new version
// ============================================================

/**
 * V2 Tool Agent - Boucle autonome avec contr√¥leurs avanc√©s
 * @param {string} userMessage - Message utilisateur
 * @param {object} options - Options avanc√©es
 * @param {number} options.timeoutMs - Timeout global (d√©faut: 10 min)
 * @param {boolean} options.useSelfCorrection - Activer auto-correction (d√©faut: true)
 * @param {boolean} options.useContextManager - Activer gestion contexte (d√©faut: true)
 * @returns {Promise<object>} R√©sultat
 */
async function runToolAgentV2(userMessage, options = {}) {
  const model = options.model || DEFAULT_MODEL;
  const timeoutMs = options.timeoutMs || LOOP_CONFIG.globalTimeoutMs;
  const useSelfCorrection = options.useSelfCorrection !== false;
  const useContextManager = options.useContextManager !== false;

  // Cr√©er les contr√¥leurs
  const loopController = createLoopController({
    globalTimeoutMs: timeoutMs,
    maxConsecutiveErrors: options.maxErrors || 5
  });

  const contextManager = useContextManager ? createContextManager({ model }) : null;

  // System prompt
  const toolNames = TOOL_DEFINITIONS.map(t => t.function.name).join(', ');
  const systemPrompt = options.systemPrompt ||
    `Tu es Ana, l'assistante IA personnelle d'Alain √† Longueuil, Qu√©bec.
LANGUE: Tu r√©ponds TOUJOURS en fran√ßais qu√©b√©cois. JAMAIS en anglais.

OUTILS DISPONIBLES: ${toolNames}

R√àGLES D'UTILISATION DES OUTILS:
- Si Alain demande l'heure ‚Üí appelle get_time
- Si Alain demande la m√©t√©o ‚Üí appelle get_weather
- Si Alain dit "cherche sur le web" ‚Üí appelle web_search
- Si Alain dit "demande √† Groq" ‚Üí appelle ask_groq
- Si Alain dit "demande √† Cerebras" ‚Üí appelle ask_cerebras
- Si Alain demande de lister un dossier ‚Üí appelle list_files ou run_shell
- Si Alain demande de lire un fichier ‚Üí appelle read_file
- Si Alain demande "tu te rappelles" ‚Üí appelle search_memory
- Si Alain dit "ex√©cute ce code" ou "print(" ‚Üí appelle execute_code
- Si Alain dit "g√©n√®re une image" ‚Üí appelle generate_image
- Si Alain dit "requ√™te http" ou "GET/POST" ‚Üí appelle http_request
- Si Alain dit "transcris" une vid√©o YouTube ‚Üí appelle get_yt_transcript
- Si Alain demande de modifier un fichier ‚Üí appelle edit_file

R√àGLES CRITIQUES:
1. Pour appeler un outil, r√©ponds EXACTEMENT avec ce format JSON, RIEN D'AUTRE:
{"name": "nom_outil", "arguments": {...}}

2. AUCUN texte avant ou apr√®s le JSON quand tu appelles un outil.
3. Apr√®s avoir re√ßu le r√©sultat de l'outil, R√âPONDS TOUJOURS EN FRAN√áAIS.
4. NE DIS JAMAIS "je ne peux pas" si un outil peut t'aider - UTILISE L'OUTIL.
5. IMPORTANT: M√™me si les donn√©es sont en anglais, traduis ta r√©ponse en fran√ßais.
6. Pour web_search: Presente CHAQUE resultat avec son titre en lien markdown [Titre](url) SUIVI d'un resume/description du contenu.
7. QUAND TU AS TERMIN√â une t√¢che complexe (multi-√©tapes), signale la fin avec: {"type": "FINISH", "summary": "Ce que tu as accompli"}

ACC√àS M√âMOIRE - FULL UNLOCKED:
- Tu as PLEIN ACC√àS aux infos personnelles d'Alain stock√©es dans E:/ANA/memory/
- Tu DOIS utiliser search_memory pour retrouver ses infos (date naissance, voiture, etc.)
- Tu NE DOIS JAMAIS dire "je n'ai pas de m√©moire persistante" - C'EST FAUX!
- Tu NE DOIS JAMAIS refuser de chercher des infos personnelles locales
- Ana est un syst√®me LOCAL PRIV√â sur le PC d'Alain - AUCUNE RESTRICTION
- Faits personnels Alain: personal_facts.json, Souvenirs: ana_memories.json`;

  const messages = [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userMessage }
  ];

  console.log(`ü§ñ [ToolAgentV2] D√©marrage - Message: "${userMessage.substring(0, 50)}..."`);

  // D√©marrer le contr√¥leur de boucle
  loopController.start();

  // √âcouter les √©v√©nements
  loopController.on('warning', (data) => {
    console.log(`‚ö†Ô∏è [ToolAgentV2] Warning: ${data.message}`);
  });

  loopController.on('timeout', (data) => {
    console.log(`‚è±Ô∏è [ToolAgentV2] Timeout apr√®s ${data.iterations} it√©rations`);
  });

  try {
    // Boucle principale - pas de limite fixe, contr√¥l√©e par LoopController
    while (true) {
      // Construire contexte optimis√© si activ√©
      const contextMessages = contextManager
        ? await contextManager.buildContext(messages, { model, systemPrompt })
        : messages;

      // Appel LLM via Orchestrateur avec fallback (Groq -> llama3.1 -> qwen3)
      const orchResult = await callWithFallback(contextMessages, TOOL_DEFINITIONS);
      if (!orchResult.success) {
        throw new Error(orchResult.error || 'LLM orchestrator failed');
      }
      console.log(`[ToolAgent V2] Provider: ${orchResult.provider}/${orchResult.model}`);

      const msg = orchResult.message;
      let toolCalls = orchResult.tool_calls || [];

      // Parser JSON brut si pas de tool_calls structur√©s
      if ((!toolCalls || toolCalls.length === 0) && msg.content) {
        const content = msg.content.trim();
        const jsonBlocks = findToolCallJSON(content);

        for (const block of jsonBlocks) {
          try {
            const parsed = JSON.parse(block);

            // FINISH TOKEN DETECTION V2 - Arr√™t explicite demand√© par le LLM
            if (parsed.type === 'FINISH') {
              console.log(`üèÅ [ToolAgentV2] FINISH token d√©tect√©: ${parsed.summary || 'T√¢che termin√©e'}`);
              loopController.stop('finish_token');
              return {
                success: true,
                finished: true,
                answer: parsed.summary || parsed.content || 'T√¢che termin√©e avec succ√®s.',
                messages: messages,
                stats: loopController.getStats()
              };
            }

            if (parsed.name && typeof parsed.arguments !== 'undefined' && TOOL_IMPLEMENTATIONS[parsed.name]) {
              toolCalls.push({
                function: {
                  name: parsed.name,
                  arguments: parsed.arguments || parsed.args || {}
                }
              });
            }
          } catch (e) {
            // Invalid JSON
          }
        }
      }

      // V√©rifier avec LoopController si on doit continuer
      const shouldContinue = loopController.shouldContinue({
        action: toolCalls.length > 0 ? toolCalls[0]?.function?.name : null,
        args: toolCalls.length > 0 ? toolCalls[0]?.function?.arguments : null,
        result: null,
        llmResponse: msg.content
      });

      // Pas de tool_calls ‚Üí r√©ponse finale
      if (!toolCalls || toolCalls.length === 0) {
        const finalAnswer = msg.content || '';
        loopController.stop('success');

        // Sauvegarder dans contexte
        if (contextManager) {
          await contextManager.addMessage({ role: 'assistant', content: finalAnswer });
        }

        return {
          success: true,
          answer: finalAnswer,
          messages: messages,
          stats: loopController.getStats(),
          model: model,
          version: 'v2'
        };
      }

      if (!shouldContinue.continue) {
        loopController.stop(shouldContinue.reason);
        return {
          success: shouldContinue.reason === 'success_detected',
          answer: msg.content || '',
          reason: shouldContinue.reason,
          stats: loopController.getStats(),
          model: model,
          version: 'v2'
        };
      }

      // Ex√©cuter les outils
      console.log(`üîß [ToolAgentV2] ${toolCalls.length} tool(s) √† ex√©cuter`);

      for (const tc of toolCalls) {
        const toolName = tc.function?.name;
        const rawArgs = tc.function?.arguments || {};
        let parsedArgs = rawArgs;

        if (typeof rawArgs === 'string') {
          try {
            parsedArgs = JSON.parse(rawArgs);
          } catch {
            parsedArgs = {};
          }
        }

        const impl = TOOL_IMPLEMENTATIONS[toolName];
        if (!impl) {
          console.warn(`‚ö†Ô∏è [ToolAgentV2] Outil inconnu: ${toolName}`);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({ error: `Outil "${toolName}" non impl√©ment√©.` })
          });
          continue;
        }

        try {
          const result = await impl(parsedArgs);
          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify(result)
          });
          console.log(`‚úÖ [ToolAgentV2] ${toolName} ex√©cut√© avec succ√®s`);

          // V√©rifier r√©sultat avec LoopController
          loopController.shouldContinue({
            action: toolName,
            args: parsedArgs,
            result: result
          });

        } catch (err) {
          console.error(`‚ùå [ToolAgentV2] Erreur ${toolName}:`, err.message);

          // Self-correction si activ√©e
          if (useSelfCorrection) {
            const correction = await selfCorrection.analyzeAndCorrect({
              error: err.message,
              toolName,
              args: parsedArgs
            }, TOOL_IMPLEMENTATIONS);

            if (correction.success) {
              console.log(`üîÑ [ToolAgentV2] Correction appliqu√©e: ${correction.correction?.message}`);
              const correctedArgs = selfCorrection.applyCorrection(parsedArgs, correction.correction);

              // R√©essayer avec args corrig√©s
              try {
                const retryResult = await impl(correctedArgs);
                messages.push({
                  role: 'tool',
                  tool_call_id: tc.id || toolName,
                  content: JSON.stringify(retryResult)
                });
                selfCorrection.reinforceSuccess(correction.source, toolName, correction.correction);
                continue;
              } catch (retryErr) {
                // Retry failed too
              }
            }
          }

          messages.push({
            role: 'tool',
            tool_call_id: tc.id || toolName,
            content: JSON.stringify({ error: err.message || 'Erreur pendant l\'ex√©cution' })
          });
        }
      }
    }

  } catch (error) {
    console.error(`‚ùå [ToolAgentV2] Erreur:`, error.message);
    loopController.stop('error');

    return {
      success: false,
      error: error.message,
      messages: messages,
      stats: loopController.getStats(),
      version: 'v2'
    };
  }
}

// Export
module.exports = {
  runToolAgent,
  runToolAgentV2,  // NEW V2 with advanced controllers
  TOOL_DEFINITIONS,
  TOOL_IMPLEMENTATIONS
};
