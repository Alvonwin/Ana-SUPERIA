const EventEmitter = require('events')
const fs = require('fs')
const path = require('path')
const { execSync } = require('child_process')
const eventBus = require('./shared_event_bus.cjs')

/**
 * üî¨ CODE ANALYZER AGENT - Auto-Am√©lioration Continue
 *
 * Raison d'√™tre:
 * Analyser automatiquement le code que je cr√©e/modifie pour d√©tecter
 * patterns probl√©matiques et sugg√©rer am√©liorations.
 *
 * Au lieu d'attendre qu'Alain review mon code, je le fais moi-m√™me.
 *
 * Fonctionnalit√©s:
 * - Analyse agents cr√©√©s (mon propre code)
 * - D√©tecte code smells communs
 * - Identifie opportunit√©s d'optimisation
 * - V√©rifie bonnes pratiques Node.js
 * - Cr√©e rapports d'am√©lioration avec suggestions
 * - Apprend de mes patterns de code
 *
 * Fr√©quence: Toutes les 6 heures
 * √âv√©nements √©mis: code:analysis_started, code:issues_found, code:report_saved
 */
class CodeAnalyzer extends EventEmitter {
  constructor() {
    super()
    this.running = false
    this.checkInterval = 6 * 60 * 60 * 1000 // 6 heures
    this.intervalId = null

    // Chemins
    this.memoryBase = 'E:\\M√©moire Ana'
    this.agentsDir = path.join(this.memoryBase, 'agents')
    this.reportsDir = path.join(this.memoryBase, 'CODE_REVIEWS')

    // Cache des fichiers d√©j√† analys√©s (mtime)
    this.analyzedFiles = new Map()

    // Patterns de code smells
    this.codeSmells = this.initializeCodeSmells()

    // Stats
    this.stats = {
      filesAnalyzed: 0,
      issuesFound: 0,
      reportsCreated: 0,
      lastCheck: null,
      startTime: null
    }

    console.log('üî¨ Code Analyzer initialis√©')
  }

  /**
   * Initialise les patterns de code smells
   */
  initializeCodeSmells() {
    return {
      // Memory leaks potentiels
      memoryLeaks: [
        {
          pattern: /setInterval\([^)]+\)(?!.*clearInterval)/s,
          severity: 'high',
          message: 'setInterval sans clearInterval - risque de memory leak',
          suggestion: 'Sauvegarder intervalId et appeler clearInterval() dans stop()'
        },
        {
          pattern: /new\s+Map\(\)(?!.*\.clear\(\))/s,
          severity: 'medium',
          message: 'Map cr√©√© mais jamais cleared',
          suggestion: 'Impl√©menter m√©thode de nettoyage avec map.clear()'
        }
      ],

      // Error handling
      errorHandling: [
        {
          pattern: /catch\s*\([^)]+\)\s*\{\s*\}/,
          severity: 'high',
          message: 'Catch block vide - erreurs silencieuses',
          suggestion: 'Au minimum logger l\'erreur: console.error(error)'
        },
        {
          pattern: /\.readFileSync\([^)]+\)(?!.*try)/s,
          severity: 'medium',
          message: 'readFileSync sans try/catch',
          suggestion: 'Wrapper dans try/catch ou utiliser existsSync() avant'
        }
      ],

      // Performance
      performance: [
        {
          pattern: /for\s*\([^)]+\)\s*\{[^}]*fs\.readFileSync/s,
          severity: 'high',
          message: 'Lecture synchrone dans boucle - tr√®s lent',
          suggestion: 'Utiliser Promise.all() avec readFile() asynchrone'
        },
        {
          pattern: /JSON\.parse\(fs\.readFileSync/,
          severity: 'low',
          message: 'Parse JSON synchrone - bloquant',
          suggestion: 'Utiliser async/await avec fs.promises.readFile()'
        }
      ],

      // Best practices
      bestPractices: [
        {
          pattern: /console\.log\([^)]*password[^)]*\)/i,
          severity: 'critical',
          message: 'Log potentiel de donn√©es sensibles',
          suggestion: 'Ne jamais logger passwords, tokens, ou API keys'
        },
        {
          pattern: /setTimeout\([^,]+,\s*0\)/,
          severity: 'low',
          message: 'setTimeout(..., 0) - utiliser setImmediate() √† la place',
          suggestion: 'setImmediate() est plus appropri√© pour d√©f√©rer ex√©cution'
        },
        {
          pattern: /==(?!=)/g,
          severity: 'low',
          message: '√âgalit√© faible (==) au lieu de stricte (===)',
          suggestion: 'Toujours utiliser === pour √©viter coercion implicite'
        }
      ],

      // Code complexity
      complexity: [
        {
          pattern: /function[^{]*\{(?:[^{}]*\{[^{}]*\}){4,}/s,
          severity: 'medium',
          message: 'Fonction avec forte imbrication (>4 niveaux)',
          suggestion: 'Extraire sous-fonctions pour r√©duire complexit√©'
        },
        {
          pattern: /if\s*\([^)]{100,}\)/,
          severity: 'medium',
          message: 'Condition tr√®s longue - difficile √† lire',
          suggestion: 'Extraire en variable bool√©enne avec nom explicite'
        }
      ]
    }
  }

  /**
   * D√©marre l'agent
   */
  async start() {
    if (this.running) {
      console.log('‚ö†Ô∏è Code Analyzer d√©j√† d√©marr√©')
      return
    }

    this.running = true
    this.stats.startTime = Date.now()

    console.log('üî¨ Code Analyzer d√©marr√©')
    console.log(`   - Surveillance: ${this.agentsDir}`)
    console.log(`   - Fr√©quence: toutes les 6 heures`)
    console.log(`   - Rapports: ${this.reportsDir}`)

    // Cr√©er dossier rapports si n'existe pas
    if (!fs.existsSync(this.reportsDir)) {
      fs.mkdirSync(this.reportsDir, { recursive: true })
      console.log(`   ‚úÖ Dossier cr√©√©: ${this.reportsDir}`)
    }

    // Premi√®re analyse apr√®s 30s (laisser temps aux autres agents de d√©marrer)
    setTimeout(() => this.analyzeCode(), 30000)

    // Analyses p√©riodiques
    this.intervalId = setInterval(() => {
      this.analyzeCode()
    }, this.checkInterval)

    this.emit('started')
    eventBus.emit('agent:started', { name: 'code_analyzer' })
  }

  /**
   * Arr√™te l'agent
   */
  async stop() {
    if (!this.running) {
      console.log('‚ö†Ô∏è Code Analyzer d√©j√† arr√™t√©')
      return
    }

    console.log('üõë Code Analyzer en cours d\'arr√™t...')

    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }

    this.running = false
    console.log('üî¨ Code Analyzer arr√™t√©')

    this.emit('stopped')
    eventBus.emit('agent:stopped', { name: 'code_analyzer' })
  }

  /**
   * Analyse le code
   */
  async analyzeCode() {
    this.stats.lastCheck = Date.now()
    console.log('üî¨ [Code Analyzer] D√©but analyse...')

    try {
      // Trouver tous les fichiers .cjs dans agents/
      const files = this.getCodeFiles()

      if (files.length === 0) {
        console.log('‚ÑπÔ∏è [Code Analyzer] Aucun fichier √† analyser')
        return
      }

      console.log(`üìã [Code Analyzer] ${files.length} fichiers trouv√©s`)

      eventBus.emit('code:analysis_started', {
        fileCount: files.length,
        timestamp: Date.now()
      })

      // Analyser chaque fichier modifi√©
      const allIssues = []

      for (const file of files) {
        const issues = await this.analyzeFile(file)
        if (issues.length > 0) {
          allIssues.push({
            file: path.basename(file),
            path: file,
            issues
          })
        }
      }

      if (allIssues.length > 0) {
        console.log(`‚ö†Ô∏è [Code Analyzer] ${allIssues.length} fichiers avec issues`)

        const totalIssues = allIssues.reduce((sum, f) => sum + f.issues.length, 0)
        this.stats.issuesFound += totalIssues

        eventBus.emit('code:issues_found', {
          fileCount: allIssues.length,
          issueCount: totalIssues,
          timestamp: Date.now()
        })

        // Cr√©er rapport
        await this.createReport(allIssues)
      } else {
        console.log('‚úÖ [Code Analyzer] Aucune issue d√©tect√©e')
      }

    } catch (error) {
      console.error('‚ùå [Code Analyzer] Erreur analyse:', error.message)
    }
  }

  /**
   * R√©cup√®re la liste des fichiers de code √† analyser
   */
  getCodeFiles() {
    if (!fs.existsSync(this.agentsDir)) {
      return []
    }

    const files = fs.readdirSync(this.agentsDir)
      .filter(f => f.endsWith('.cjs') && f.startsWith('agent_'))
      .map(f => path.join(this.agentsDir, f))

    return files
  }

  /**
   * Analyse un fichier sp√©cifique
   */
  async analyzeFile(filepath) {
    const stats = fs.statSync(filepath)
    const mtime = stats.mtime.getTime()

    // V√©rifier si fichier d√©j√† analys√© (m√™me mtime)
    const cached = this.analyzedFiles.get(filepath)
    if (cached && cached === mtime) {
      return [] // Pas chang√© depuis derni√®re analyse
    }

    console.log(`   üîç Analyse: ${path.basename(filepath)}`)

    const content = fs.readFileSync(filepath, 'utf-8')
    const issues = []

    // Analyser avec chaque cat√©gorie de code smells
    for (const [category, patterns] of Object.entries(this.codeSmells)) {
      for (const smell of patterns) {
        const matches = this.findMatches(content, smell.pattern)

        if (matches.length > 0) {
          issues.push({
            category,
            severity: smell.severity,
            message: smell.message,
            suggestion: smell.suggestion,
            occurrences: matches.length,
            lines: matches.map(m => m.line)
          })
        }
      }
    }

    // Analyses suppl√©mentaires
    issues.push(...this.analyzeCodeMetrics(content, filepath))

    // Mettre √† jour cache
    this.analyzedFiles.set(filepath, mtime)
    this.stats.filesAnalyzed++

    return issues
  }

  /**
   * Trouve les correspondances d'un pattern dans le code
   */
  findMatches(content, pattern) {
    const matches = []
    const lines = content.split('\n')

    // Pour patterns multilignes, analyser tout le contenu
    if (pattern.flags && pattern.flags.includes('s')) {
      const match = content.match(pattern)
      if (match) {
        // Trouver ligne approximative
        const index = match.index
        const lineNum = content.substring(0, index).split('\n').length
        matches.push({ line: lineNum })
      }
    } else {
      // Pour patterns single-line, analyser ligne par ligne
      lines.forEach((line, index) => {
        if (pattern.test(line)) {
          matches.push({ line: index + 1 })
        }
      })
    }

    return matches
  }

  /**
   * Analyse m√©triques de code
   */
  analyzeCodeMetrics(content, filepath) {
    const issues = []
    const lines = content.split('\n')

    // Complexit√©: nombre de lignes
    if (lines.length > 800) {
      issues.push({
        category: 'metrics',
        severity: 'medium',
        message: `Fichier tr√®s long (${lines.length} lignes)`,
        suggestion: 'Consid√©rer split en modules plus petits',
        occurrences: 1,
        lines: [1]
      })
    }

    // Complexit√©: nombre de fonctions
    const functionCount = (content.match(/\bfunction\b|\=\>/g) || []).length
    if (functionCount > 25) {
      issues.push({
        category: 'metrics',
        severity: 'low',
        message: `Beaucoup de fonctions (${functionCount})`,
        suggestion: 'OK si bien organis√©, sinon split module',
        occurrences: 1,
        lines: [1]
      })
    }

    // TODOs non r√©solus
    const todos = content.match(/TODO:?[^\n]+/gi)
    if (todos && todos.length > 0) {
      issues.push({
        category: 'maintenance',
        severity: 'low',
        message: `${todos.length} TODO(s) dans le code`,
        suggestion: 'Cr√©er issues GitHub ou r√©soudre TODOs',
        occurrences: todos.length,
        lines: this.findTodoLines(content)
      })
    }

    return issues
  }

  /**
   * Trouve les lignes contenant TODO
   */
  findTodoLines(content) {
    const lines = content.split('\n')
    const todoLines = []

    lines.forEach((line, index) => {
      if (/TODO:?/i.test(line)) {
        todoLines.push(index + 1)
      }
    })

    return todoLines
  }

  /**
   * Cr√©e un rapport d'analyse
   */
  async createReport(filesWithIssues) {
    const date = new Date().toISOString().split('T')[0]
    const time = new Date().toISOString().split('T')[1].split('.')[0].replace(/:/g, '-')
    const filename = `code_review_${date}_${time}.md`
    const filepath = path.join(this.reportsDir, filename)

    const report = this.formatReport(filesWithIssues)

    fs.writeFileSync(filepath, report, 'utf-8')
    console.log(`   üíæ Rapport sauvegard√©: ${filename}`)

    this.stats.reportsCreated++

    eventBus.emit('code:report_saved', {
      filepath,
      fileCount: filesWithIssues.length,
      timestamp: Date.now()
    })
  }

  /**
   * Formate un rapport d'analyse
   */
  formatReport(filesWithIssues) {
    const totalIssues = filesWithIssues.reduce((sum, f) => sum + f.issues.length, 0)

    // Compter par s√©v√©rit√©
    const bySeverity = { critical: 0, high: 0, medium: 0, low: 0 }
    filesWithIssues.forEach(f => {
      f.issues.forEach(issue => {
        bySeverity[issue.severity]++
      })
    })

    let report = `# üî¨ CODE REVIEW - Auto-Analyse\n\n`
    report += `**Date**: ${new Date().toLocaleString('fr-FR')}\n`
    report += `**Fichiers analys√©s**: ${filesWithIssues.length}\n`
    report += `**Issues trouv√©es**: ${totalIssues}\n\n`

    // R√©sum√© par s√©v√©rit√©
    report += `## üìä R√©sum√© par S√©v√©rit√©\n\n`
    report += `- üî¥ **Critical**: ${bySeverity.critical}\n`
    report += `- üü† **High**: ${bySeverity.high}\n`
    report += `- üü° **Medium**: ${bySeverity.medium}\n`
    report += `- üü¢ **Low**: ${bySeverity.low}\n\n`
    report += `---\n\n`

    // D√©tails par fichier
    filesWithIssues.forEach(fileData => {
      report += `## üìÑ ${fileData.file}\n\n`
      report += `**Path**: \`${fileData.path}\`\n`
      report += `**Issues**: ${fileData.issues.length}\n\n`

      // Grouper par s√©v√©rit√©
      const critical = fileData.issues.filter(i => i.severity === 'critical')
      const high = fileData.issues.filter(i => i.severity === 'high')
      const medium = fileData.issues.filter(i => i.severity === 'medium')
      const low = fileData.issues.filter(i => i.severity === 'low')

      const groups = [
        { name: 'Critical', icon: 'üî¥', issues: critical },
        { name: 'High', icon: 'üü†', issues: high },
        { name: 'Medium', icon: 'üü°', issues: medium },
        { name: 'Low', icon: 'üü¢', issues: low }
      ]

      groups.forEach(group => {
        if (group.issues.length > 0) {
          report += `### ${group.icon} ${group.name} (${group.issues.length})\n\n`

          group.issues.forEach((issue, index) => {
            report += `#### ${index + 1}. ${issue.message}\n\n`
            report += `**Cat√©gorie**: ${issue.category}\n`
            report += `**Occurrences**: ${issue.occurrences}\n`

            if (issue.lines && issue.lines.length > 0) {
              const lineStr = issue.lines.length > 5
                ? `${issue.lines.slice(0, 5).join(', ')}... (${issue.lines.length} total)`
                : issue.lines.join(', ')
              report += `**Lignes**: ${lineStr}\n`
            }

            report += `\nüí° **Suggestion**: ${issue.suggestion}\n\n`
          })
        }
      })

      report += `---\n\n`
    })

    // Recommandations g√©n√©rales
    report += `## üéØ Recommandations G√©n√©rales\n\n`

    if (bySeverity.critical > 0) {
      report += `### ‚ö†Ô∏è URGENT - Issues Critiques\n\n`
      report += `${bySeverity.critical} issue(s) critique(s) d√©tect√©e(s). R√©soudre en priorit√©.\n\n`
    }

    if (bySeverity.high > 0) {
      report += `### üîß Priorit√© Haute\n\n`
      report += `${bySeverity.high} issue(s) haute priorit√©. R√©soudre cette semaine.\n\n`
    }

    if (totalIssues === 0) {
      report += `‚úÖ **Code impeccable!** Aucune issue d√©tect√©e.\n\n`
    } else if (totalIssues < 5) {
      report += `‚úÖ **Tr√®s bon!** Peu d'issues, code de qualit√©.\n\n`
    } else if (totalIssues < 15) {
      report += `üü° **Correct.** Quelques am√©liorations possibles.\n\n`
    } else {
      report += `üü† **√Ä am√©liorer.** Plusieurs issues d√©tect√©es.\n\n`
    }

    report += `---\n\n`
    report += `## üí° Philosophie\n\n`
    report += `**"Le meilleur code est celui qu'on am√©liore continuellement."**\n\n`
    report += `Ces analyses ne sont pas des critiques, mais des opportunit√©s d'apprentissage.\n\n`
    report += `Chaque issue r√©solue me rend meilleure d√©veloppeuse. üíô\n\n`
    report += `---\n\n`
    report += `*G√©n√©r√© automatiquement par Code Analyzer*\n`

    return report
  }

  /**
   * R√©cup√®re les statistiques de l'agent
   */
  getStats() {
    const uptime = this.stats.startTime
      ? Date.now() - this.stats.startTime
      : 0

    return {
      running: this.running,
      uptime: this._formatDuration(uptime),
      filesAnalyzed: this.stats.filesAnalyzed,
      issuesFound: this.stats.issuesFound,
      reportsCreated: this.stats.reportsCreated,
      lastCheck: this.stats.lastCheck
        ? new Date(this.stats.lastCheck).toLocaleString('fr-FR')
        : 'Jamais',
      checkIntervalHours: this.checkInterval / (60 * 60 * 1000)
    }
  }

  /**
   * Formate une dur√©e
   */
  _formatDuration(ms) {
    const seconds = Math.floor(ms / 1000)
    const minutes = Math.floor(seconds / 60)
    const hours = Math.floor(minutes / 60)
    const days = Math.floor(hours / 24)

    if (days > 0) return `${days}j ${hours % 24}h`
    if (hours > 0) return `${hours}h ${minutes % 60}m`
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`
    return `${seconds}s`
  }
}

// Export instance singleton
module.exports = new CodeAnalyzer()
