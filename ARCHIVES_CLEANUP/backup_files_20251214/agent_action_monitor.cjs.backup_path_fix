/**
 * AGENT: Action Monitor
 * Surveille et enregistre toutes les actions de Ana
 *
 * MISSION:
 * - Tracker tous les outils utilisÃ©s (Edit, Write, Bash, etc.)
 * - DÃ©tecter les patterns d'actions rÃ©pÃ©titives (boucles infinies)
 * - Identifier les actions inefficaces
 * - CrÃ©er un journal d'actions pour analyse
 *
 * PHILOSOPHIE:
 * "Observe ton comportement pour comprendre tes erreurs"
 * - Principe de rÃ©flexion et d'auto-amÃ©lioration
 */

const fs = require('fs').promises
const path = require('path')
const eventBus = require('./shared_event_bus.cjs')

class ActionMonitor {
  constructor() {
    this.name = 'action_monitor'
    this.running = false
    this.checkInterval = 10000 // VÃ©rifier toutes les 10 secondes
    this.intervalId = null

    // Historique des actions
    this.actionHistory = []
    this.maxHistorySize = 100 // Garder les 100 derniÃ¨res actions

    // DÃ©tection de patterns problÃ©matiques
    this.repeatedActionThreshold = 3 // 3 fois la mÃªme action = suspect
    this.actionWindow = 2 * 60 * 1000 // Dans une fenÃªtre de 2 minutes

    // Stats
    this.stats = {
      totalActions: 0,
      editActions: 0,
      writeActions: 0,
      bashActions: 0,
      readActions: 0,
      grepActions: 0,
      globActions: 0,
      webSearchActions: 0,
      repeatedPatterns: 0,
      inefficientActions: 0,
      lastAction: null,
      running: true,
      uptime: '0s'
    }

    // Patterns d'actions rÃ©pÃ©titives
    this.repeatedPatterns = []

    this.conversationPath = 'E:\\MÃ©moire Ana\\02_MÃ‰MOIRE_COURT_TERME\\current_conversation.txt'
    this.rappelsPath = 'E:\\MÃ©moire Ana\\RAPPELS_ACTIFS.md'
    this.actionLogPath = 'E:\\MÃ©moire Ana\\03_METAMEMOIRE\\action_log.jsonl'

    this.startTime = Date.now()
    this.lastPosition = 0
  }

  /**
   * DÃ©marre la surveillance
   */
  async start() {
    console.log(`ðŸ‘ï¸  [${this.name}] DÃ©marrage du moniteur d'actions...`)
    this.running = true

    eventBus.emit('agent:started', {
      agent: this.name,
      timestamp: new Date().toISOString()
    })

    // Ã‰couter tous les Ã©vÃ©nements d'outils
    const tools = ['Edit', 'Write', 'Bash', 'Read', 'Grep', 'Glob', 'WebSearch', 'Task']

    tools.forEach(tool => {
      eventBus.on(`tool:${tool.toLowerCase()}`, (data) => {
        this.recordAction(tool, data)
      })
    })

    // Initialiser position lecture
    try {
      const stats = await fs.stat(this.conversationPath)
      this.lastPosition = stats.size
    } catch (error) {
      this.lastPosition = 0
    }

    // Lancer la surveillance pÃ©riodique
    this.intervalId = setInterval(() => this.analyzePatterns(), this.checkInterval)

    console.log(`âœ… [${this.name}] Moniteur actif - analyse toutes les ${this.checkInterval/1000}s`)
  }

  /**
   * Enregistre une action
   */
  async recordAction(tool, data) {
    const action = {
      tool,
      timestamp: Date.now(),
      data: this.sanitizeData(data),
      context: this.extractContext(data)
    }

    // Ajouter Ã  l'historique
    this.actionHistory.push(action)

    // Limiter la taille de l'historique
    if (this.actionHistory.length > this.maxHistorySize) {
      this.actionHistory.shift()
    }

    // Mettre Ã  jour les stats
    this.stats.totalActions++
    this.stats.lastAction = new Date().toISOString()

    const statKey = `${tool.toLowerCase()}Actions`
    if (this.stats.hasOwnProperty(statKey)) {
      this.stats[statKey]++
    }

    // Enregistrer dans le log persistant
    await this.logAction(action)

    // VÃ©rifier immÃ©diatement si c'est une rÃ©pÃ©tition
    await this.checkForRepetition(action)

    console.log(`ðŸ“ [${this.name}] Action enregistrÃ©e: ${tool}`)
  }

  /**
   * Sanitize les donnÃ©es pour Ã©viter les logs trop gros
   */
  sanitizeData(data) {
    if (!data) return {}

    const sanitized = { ...data }

    // Limiter les contenus longs
    if (sanitized.content && sanitized.content.length > 200) {
      sanitized.content = sanitized.content.substring(0, 200) + '...[truncated]'
    }

    if (sanitized.command && sanitized.command.length > 200) {
      sanitized.command = sanitized.command.substring(0, 200) + '...[truncated]'
    }

    return sanitized
  }

  /**
   * Extrait le contexte d'une action
   */
  extractContext(data) {
    const context = {}

    if (data.file_path) context.file = path.basename(data.file_path)
    if (data.pattern) context.pattern = data.pattern
    if (data.command) context.command = data.command.split(' ')[0] // PremiÃ¨re commande seulement

    return context
  }

  /**
   * Enregistre l'action dans un fichier JSONL
   */
  async logAction(action) {
    try {
      const logEntry = JSON.stringify(action) + '\n'

      // CrÃ©er le dossier si nÃ©cessaire
      const logDir = path.dirname(this.actionLogPath)
      await fs.mkdir(logDir, { recursive: true })

      await fs.appendFile(this.actionLogPath, logEntry, 'utf-8')

    } catch (error) {
      console.error(`âŒ [${this.name}] Erreur log action:`, error.message)
    }
  }

  /**
   * VÃ©rifie si l'action est une rÃ©pÃ©tition
   */
  async checkForRepetition(action) {
    const now = Date.now()
    const windowStart = now - this.actionWindow

    // Trouver les actions similaires dans la fenÃªtre de temps
    const similarActions = this.actionHistory.filter(a => {
      if (a.timestamp < windowStart) return false
      if (a.tool !== action.tool) return false

      // VÃ©rifier si le contexte est similaire
      return this.areSimilarContexts(a.context, action.context)
    })

    if (similarActions.length >= this.repeatedActionThreshold) {
      await this.handleRepeatedAction(action, similarActions.length)
    }
  }

  /**
   * Compare deux contextes d'action
   */
  areSimilarContexts(ctx1, ctx2) {
    // Si mÃªme fichier
    if (ctx1.file && ctx2.file && ctx1.file === ctx2.file) return true

    // Si mÃªme pattern de recherche
    if (ctx1.pattern && ctx2.pattern && ctx1.pattern === ctx2.pattern) return true

    // Si mÃªme commande bash
    if (ctx1.command && ctx2.command && ctx1.command === ctx2.command) return true

    return false
  }

  /**
   * GÃ¨re la dÃ©tection d'actions rÃ©pÃ©tÃ©es
   */
  async handleRepeatedAction(action, count) {
    this.stats.repeatedPatterns++

    const alert = {
      type: 'repeated_action',
      tool: action.tool,
      context: action.context,
      count: count,
      timestamp: new Date().toISOString(),
      severity: 'warning'
    }

    console.log(`âš ï¸  [${this.name}] ACTION RÃ‰PÃ‰TÃ‰E DÃ‰TECTÃ‰E!`)
    console.log(`   Outil: ${action.tool}`)
    console.log(`   RÃ©pÃ©titions: ${count} fois`)
    console.log(`   Contexte:`, action.context)

    eventBus.emit('action:repeated', alert)

    try {
      const reminder = `
## âš ï¸ PATTERN D'ACTIONS RÃ‰PÃ‰TÃ‰ES - ${new Date().toLocaleString('fr-FR')}

**Outil:** \`${action.tool}\`
**RÃ©pÃ©titions:** ${count} fois en 2 minutes
**Contexte:** ${JSON.stringify(action.context, null, 2)}

**ALERTE:**
Tu rÃ©pÃ¨tes la mÃªme action plusieurs fois. Cela peut indiquer:

1. ðŸ” **Boucle infinie**
   - Tu essaies la mÃªme chose encore et encore
   - Sans succÃ¨s, mais tu continues

2. âŒ **Approche inefficace**
   - La mÃ©thode ne fonctionne pas
   - Il faut changer de stratÃ©gie

3. ðŸ¤” **Manque de rÃ©flexion**
   - Agir sans analyser pourquoi Ã§a Ã©choue
   - Besoin de prendre du recul

**ACTION RECOMMANDÃ‰E:**

âœ… **STOP et RÃ‰FLÃ‰CHIS:**
- Pourquoi cette action Ã©choue-t-elle?
- Qu'est-ce que les erreurs me disent?
- Y a-t-il une autre approche?

âœ… **RECHERCHE:**
- WebSearch pour comprendre le problÃ¨me
- Lire la documentation
- Demander Ã  Alain

âœ… **CHANGE DE STRATÃ‰GIE:**
- Essayer une approche diffÃ©rente
- DÃ©composer le problÃ¨me autrement
- Utiliser un autre outil

**Rappel:**
> "La folie, c'est de faire toujours la mÃªme chose et de s'attendre Ã  un rÃ©sultat diffÃ©rent."
> - Albert Einstein

---

`

      await fs.appendFile(this.rappelsPath, reminder, 'utf-8')
      console.log(`ðŸ“ [${this.name}] Rappel actions rÃ©pÃ©tÃ©es crÃ©Ã©`)

    } catch (error) {
      console.error(`âŒ [${this.name}] Erreur crÃ©ation rappel:`, error.message)
    }
  }

  /**
   * Analyse les patterns dans l'historique
   */
  async analyzePatterns() {
    try {
      // Mettre Ã  jour uptime
      const uptimeMs = Date.now() - this.startTime
      const uptimeMin = Math.floor(uptimeMs / 60000)
      const uptimeSec = Math.floor((uptimeMs % 60000) / 1000)
      this.stats.uptime = `${uptimeMin}m ${uptimeSec}s`

      // Analyser les 20 derniÃ¨res actions
      const recentActions = this.actionHistory.slice(-20)

      if (recentActions.length === 0) return

      // DÃ©tecter les inefficacitÃ©s (beaucoup d'actions Read/Grep sans rÃ©sultat)
      const searchActions = recentActions.filter(a =>
        ['Read', 'Grep', 'Glob'].includes(a.tool)
      )

      if (searchActions.length > 10) {
        // Beaucoup de recherches rÃ©cemment
        const actionCount = recentActions.filter(a =>
          ['Edit', 'Write', 'Bash'].includes(a.tool)
        ).length

        // Si beaucoup de recherches mais peu d'actions concrÃ¨tes
        if (actionCount === 0) {
          await this.handleInefficiency('too_much_searching')
        }
      }

    } catch (error) {
      console.error(`âŒ [${this.name}] Erreur analyse patterns:`, error.message)
    }
  }

  /**
   * GÃ¨re la dÃ©tection d'inefficacitÃ©
   */
  async handleInefficiency(type) {
    this.stats.inefficientActions++

    const alert = {
      type: 'inefficiency_detected',
      inefficiencyType: type,
      timestamp: new Date().toISOString(),
      severity: 'info'
    }

    console.log(`ðŸ’¡ [${this.name}] INEFFICACITÃ‰ DÃ‰TECTÃ‰E: ${type}`)

    eventBus.emit('action:inefficient', alert)

    if (type === 'too_much_searching') {
      try {
        const reminder = `
## ðŸ’¡ SUGGESTION D'EFFICACITÃ‰ - ${new Date().toLocaleString('fr-FR')}

**Observation:**
Beaucoup de recherches (Read/Grep/Glob) mais peu d'actions concrÃ¨tes rÃ©cemment.

**SUGGESTION:**

Tu cherches peut-Ãªtre trop sans agir. ConsidÃ¨re:

1. ðŸŽ¯ **DÃ©finir l'objectif clairement**
   - Que cherches-tu exactement?
   - Quelle est la prochaine action concrÃ¨te?

2. ðŸ“‹ **Utiliser le Task tool**
   - Pour les recherches exploratoires
   - L'agent Explore est fait pour Ã§a

3. âœ‹ **Stop et dÃ©cide**
   - As-tu assez d'information pour agir?
   - Ou as-tu besoin d'aide d'Alain?

**Rappel:**
L'analyse est importante, mais l'action l'est aussi. Trouve l'Ã©quilibre.

---

`

        await fs.appendFile(this.rappelsPath, reminder, 'utf-8')
        console.log(`ðŸ“ [${this.name}] Suggestion d'efficacitÃ© crÃ©Ã©e`)

      } catch (error) {
        console.error(`âŒ [${this.name}] Erreur crÃ©ation suggestion:`, error.message)
      }
    }
  }

  /**
   * ArrÃªte la surveillance
   */
  async stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId)
      this.intervalId = null
    }

    this.running = false
    this.stats.running = false

    console.log(`ðŸ›‘ [${this.name}] Moniteur arrÃªtÃ©`)
    console.log(`   Actions totales: ${this.stats.totalActions}`)
    console.log(`   Patterns rÃ©pÃ©tÃ©s dÃ©tectÃ©s: ${this.stats.repeatedPatterns}`)
    console.log(`   InefficacitÃ©s dÃ©tectÃ©es: ${this.stats.inefficientActions}`)

    eventBus.emit('agent:stopped', {
      agent: this.name,
      stats: this.stats,
      timestamp: new Date().toISOString()
    })

    // Sauvegarder les stats finales
    await this.saveSessionStats()
  }

  /**
   * Sauvegarde les statistiques de session
   */
  async saveSessionStats() {
    try {
      const sessionStats = {
        session_end: new Date().toISOString(),
        uptime: this.stats.uptime,
        total_actions: this.stats.totalActions,
        actions_by_tool: {
          edit: this.stats.editActions,
          write: this.stats.writeActions,
          bash: this.stats.bashActions,
          read: this.stats.readActions,
          grep: this.stats.grepActions,
          glob: this.stats.globActions,
          webSearch: this.stats.webSearchActions
        },
        patterns_detected: {
          repeated: this.stats.repeatedPatterns,
          inefficient: this.stats.inefficientActions
        }
      }

      const statsPath = 'E:\\MÃ©moire Ana\\03_METAMEMOIRE\\session_stats.jsonl'
      const statsEntry = JSON.stringify(sessionStats) + '\n'

      await fs.appendFile(statsPath, statsEntry, 'utf-8')
      console.log(`ðŸ’¾ [${this.name}] Stats de session sauvegardÃ©es`)

    } catch (error) {
      console.error(`âŒ [${this.name}] Erreur sauvegarde stats:`, error.message)
    }
  }

  /**
   * Retourne les statistiques
   */
  getStats() {
    return {
      ...this.stats,
      running: this.running,
      historySize: this.actionHistory.length,
      recentActions: this.actionHistory.slice(-5).map(a => ({
        tool: a.tool,
        timestamp: new Date(a.timestamp).toLocaleTimeString('fr-FR'),
        context: a.context
      }))
    }
  }
}

// CrÃ©er et exporter l'instance singleton
const monitor = new ActionMonitor()

// Gestion du signal d'arrÃªt
process.on('SIGINT', async () => {
  await monitor.stop()
  process.exit(0)
})

process.on('SIGTERM', async () => {
  await monitor.stop()
  process.exit(0)
})

module.exports = monitor
