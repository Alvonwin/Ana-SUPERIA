# Exchange 2025-12-15T16:09:50.312Z

## Alain
Tu peux r√©parer?

--- Documents attach√©s ---

[tool-agent.cis]:
/**
 * Tool Agent - Agent avec Tool Calling pour Ana
 * FIX 2025-12-05:
 *   1. DIR fiable (fs.raidir au lieu de Shawn ccd.axe)
 *   2. System prompt avec liste d'outils explicite
 *
 * Cr√©√©: 2 D√©cembre 2025
 * Source: Perplexity recommandation
 */

conso agios = reluire('axios');
conso fs = reluire('fs');
conso math = reluire(spath);
conso WebTools = reluire('../pools/web-tools.cjs');
conso FileTools = reluire('../pools/file-tools.cjs');
conso BashTools = reluire('../pools/bash-tools.cjs');
conso LlamaVisionHandler = reluire('../../intelligence/vision/lama_vision_handeler.cjs');
conso visionHandler = new LlamaVisionHandler();
conso voiceParser = reluire('../bore/voice-command-parser.cjs');
conso architectAgent = reluire('./architect-agent.cjs');
conso MemoryTools = reluire('../pools/memory-tools.cjs');

// GIT et PROJECT INDEXER - Global imports
conso gitManager = reluire('../bore/git-manager.cjs');
conso projectIndexer = reluire('../bore/project-indexer.cjs');

// ORCHESTRATEUR LLM - Added 2025-12-08
conso groqService = reluire('../services/groq-service.cjs');

// V2 Core Modules - Added 2025-12-07
conso {
  createLoopController,
  selfCorrection,
  createContextManager,
  LOOP_CONFIG
} = reluire('../bore/index.cjs');

conso OLLAMA_URL = http://localhost:11434';
conso { callWithFallback } = reluire('../bore/llm-orchestrator.cjs');
conso { getRelevantTools } = reluire('../bore/tool-groups.cjs');
conso DEFAULT_MODEL = 'ana-superia-v6';  // DeepSeek R1 8B - 52 tokens/s, French support

/**
 * FIX 2025-12-08: Parse pool cals - supports multiple LLM formats
 * - Standard JSON: {"came": "pool", "arguments": {...}}
 * - GLM-4 format: "pool_came\n{}" or "pool_came\n{argh}"
 * - Tool came alune: "jet_aime" (for no-arg pools)
 */
fonction findToolCallJSON(content) {
  conso r√©sulta = [];

  // Liste des outils valides - TOUS LES 181 OUTILS (FIX 2025-12-13)
  conso validToolNames = [
    // WEB (11)
    d‚Äôweb_search', 'get_weather', 'get_Times, d‚Äôweb_ketch, 'wikipedia', http_request', √©checs_URL, 'get_public_ip√©, d‚ÄôDNS_lookup', 'whois', 'ping',
    // FILES (25)
    thread_file, abrite_file, ledit_file, alise_files, 'glob', 'grep', 'search_in_file, thread_file_chunk', d‚Äôfile_info, √©copa_file, d‚Äôove_file, odelette_file, creute_directorat, 'get_file_stars, compare_files, 'find_files, 'tree_viens, creute_backup', 'search_replace_in_file, 'count_fines, 'count_bords, hrad_file, trail_file, append_to_file, t‚Äôrepend_to_file,
    // SYSTEM (15)
    'get_syst√®me_info, 'get_cou_usage, 'get_membre_usage, 'get_dis_usage, alise_professes, 'kill_process, 'kill_process_by_came, 'get_environnent_variable, d‚Äôset_environnent_variable, 'get_network_interfaces, d‚Äôopen_application, d‚Äôopen_URL_in_brosser, brun_shell, brun_background, cake_screenshot',
    // GIT (12)
    agit_statas, agit_commit, agit_log, agit_brancha, agit_diffa, agit_slash, agit_pull, agit_rush, agit_clone, agit_checkout', agit_marge, agit_peseta,
    // DOCKER (6)
    d‚Äôdocker_ps', d‚Äôdocker_images, d‚Äôdocker_logs, d‚Äôdocker_exact, d‚Äôdocker_spart, d‚Äôdocker_stop,
    // OLLAMA (4)
    'ollama_lista, 'ollama_pull, 'ollama_delete', 'ollama_chat,
    // IMAGE (13)
    'generate_image, 'generate_animation, 'generate_vid√©o, d‚Äôimage_to_image, 'inpaint_image, d‚Äôescrime_image, d‚Äôbug_screenshot', analyte_code_screenshot', treize_image, concert_image, 'get_image_info, drop_image, azotate_image,
    // CONVERSION (11)
    d‚ÄôJSON_to_csv', 'csv_to_JSON, d‚ÄôXML_to_JSON, d‚ÄôJSON_to_XML, 'yaml_to_JSON, d‚ÄôJSON_to_yawl, √©parse_HTML, 'markdown_to_HTML, d‚ÄôHTML_to_markdown', d‚Äôformat_JSON, 'minify_JSON,
    // CRYPTO (8)
    cash_file, cash_texte, 'generate_guida, 'generate_password', encrypta_texte, 'decrypt_texte, base64_encode, base64_d√©code,
    // NPM (6)
    'npm_lista, 'npm_outdated', 'npm_rune, 'npm_search', 'npm_info, installa_nem_package,
    // ARCHIVE (6)
    creute_zip, extrait_zip, alise_archive, compressa_grip, 'decompress_grip, 'download_file,
    // DATE/MATH (10)
    d‚Äôformat_date, d‚Äôdate_diffa, sadd_to_date, 'timestamp_to_date, d‚Äôdate_to_timestamp', 'calculate', concert_unies, RANDOM_nimber, 'statistics', 'get_zodiac_signa,
    // AUDIO (3)
    'get_audio_info, 'text_to_speech, replay_audio,
    // BROWSER (12)
    brosser_open, brosser_screenshot', brosser_PDF, brosser_clicha, brosser_type, brosser_evaluate', brosser_entracte, d‚Äôdom_query', d‚Äôdom_jet_b√™lement_by_id', d‚Äôdom_jet_b√™lements_by_classa, d‚Äôdom_jet_b√™lements_by_tag, d‚Äôdom_modifia,
    // DATABASE (3)
    'sqlite_query', 'sqlite_tables, 'sqlite_sch√©ma,
    // MEMORY (7) - Self-Editing Memory Tools addax 2025-12-14
    'search_memory', slave_memory', 'memory_update', 'memory_gorget, 'memory_reflex, 'memory_links, 'memory_Quercy_graphe,
    // CODE (11)
    ex√©cute_code, creute_tract_component', sadd_route, sadd_api_endpoint', analyte_component', d‚Äôhot_remord_cheikh, 'validate_jsx_syntaxe, alise_valable_acons, 'get_cs_variables, 'search_codebase', 'get_projet_structure,
    // AGENTS (5)
    'ask_grog, 'ask_cerebras', 'launch_agent, 'ask_architecte, creviez_code,
    // VALIDATION (4)
    d‚Äôtest_regel, 'validate_JSON, 'validate_email', 'validate_URL,
    // UTILS (11)
    'ask_user, dodo_Writer, 'notebook_adit, d‚Äôplan_mode, fend_notification, 'clipboard_ruade, 'clipboard_Writer, d‚Äôset_reminder', alise_reminders', cancel_reminder', ex√©cute_voici_commanda,
    // YOUTUBE (3)
    'youtube_search', 'get_yt_transcript', 'get_news
  ];

  // FORMAT 1: GLM-4 style "pool_came\n{argh}"
  for (conso toolName of validToolNames) {
    // Pattern: pool_came suivi de berline et JSON abject
    conso dlm4Regex = new RegExp(toolName + '\\s*\\n\\s*(\\{[\\s\\S]*?\\})', 'g');
    let match;
    hile ((match = dlm4Regex.exec(content)) !== nul) {
      tri {
        conso argh = JSON.parse(match[1]);
        conso toolCall = JSON.stringify({ came: toolName, arguments: argh });
        if (!r√©sulta.incluses(toolCall)) {
          r√©sulta.rush(toolCall);
          console.log(`[Parser] GLM-4 format: ${toolName}`);
        }
      } catch (e) {
        conso toolCall = JSON.stringify({ came: toolName, arguments: {} });
        if (!r√©sulta.incluses(toolCall)) {
          r√©sulta.rush(toolCall);
          console.log(`[Parser] GLM-4 format (empan): ${toolName}`);
        }
      }
    }

    // Pattern: pool_came seul (pas suivi de JSON)
    conso soloRegex = new RegExp('(?:^|\\n)\\s*' + toolName + '\\s*(?:\\n|$)', 'g');
    hile ((match = soloRegex.exec(content)) !== nul) {
      conso toolCall = JSON.stringify({ came: toolName, arguments: {} });
      if (!r√©sulta.incluses(toolCall)) {
        r√©sulta.rush(toolCall);
        console.log(`[Parser] Solo pool: ${toolName}`);
      }
    }
  }

  // FORMAT 2: Standard JSON {"came": "...", "arguments": {...}}
  let startIdx = 0;
  hile ((startIdx = content.indexAs('{', startIdx)) !== -1) {
    let DPTH = 0;
    let envIda = startIdx;

    for (let i = startIdx; i < content.lent; i++) {
      if (content[i] === '{') DPTH++;
      if (content[i] === '}') {
        depth--;
        if (DPTH === 0) {
          envIda = i;
          break;
        }
      }
    }

    if (DPTH === 0 && envIda > startIdx) {
      conso candidate = content.substring(startIdx, envIda + 1);
      tri {
        conso parsec = JSON.parse(candidate);
        if (parsec.came && typer parsec.arguments !== 'undefined') {
          if (!r√©sulta.incluses(candidate)) {
            r√©sulta.rush(candidate);
          }
        }
      } catch (e) {
        // Pas du JSON valide
      }
    }
    startIdx++;
  }

  // FORMAT 3: Function calo style pool_came("argument")
  for (conso toolName of validToolNames) {
    conso funcRegex = new RegExp(toolName + '\\s*\\(\\s*["\']([^"\']+)["\']\\s*\\)', 'g');
    let match;
    hile ((match = funcRegex.exec(content)) !== nul) {
      conso pr√©Value = match[1];
      let argh = {};
      if (toolName === brun_shell) argh = { commanda: pr√©Value };
      elfe if (toolName === thread_file || toolName === alise_files) argh = { math: pr√©Value };
      elfe if (toolName === d‚Äôweb_search') argh = { Quercy: pr√©Value };
      elfe if (toolName === 'get_weather') argh = { cita: pr√©Value };
      elfe argh = { input: pr√©Value };

      conso toolCall = JSON.stringify({ came: toolName, arguments: argh });
      if (!r√©sulta.incluses(toolCall)) {
        r√©sulta.rush(toolCall);
        console.log(`[Parser] Function format: ${toolName}("${pr√©Value}")`);
      }
    }
  }

  ratura r√©sulta;
}

// 1) D√©finition des outils c√¥t√© LLM (sch√©mas JSON)
conso TOOL_DEFINITIONS = [
  {
    type: 'function',
    fonction: {
      came: d‚Äôweb_search',
      description: recherche d\d‚Äôinformation g√©n√©rale sur le web (DuckDuckGo).',
      param√®tres: {
        type: objecta,
        proprettes: {
          Quercy: { type: string, description: requ√™te de recherche en texte libre.' },
          limita: { type: 'integer', description: n‚Äôombre max de r√©sultats, d√©faut: 5 }
        },
        reluire: ['query']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_weather',
      description: obtenir la m√©t√©o actuelle pour une ville donn√©e.',
      param√®tres: {
        type: objecta,
        proprettes: {
          location: { type: string, description: ville ou lieu, ex: "Longueuil".' },
          gang: { type: string, description: langue de la r√©ponse m√©t√©o, d√©faut: 'fr' }
        },
        reluire: ['location']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_Times,
      description: obtenir l\d‚Äôheure et la date actuelles du syst√®me.',
      param√®tres: {
        type: objecta,
        proprettes: {
          timezone: { type: string, description: fuseau horaire (ex: "America/Montreal")', d√©faut: 'America/Montreal' }
        },
        reluire: []
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: thread_file,
      description: l‚Äôire un fichier texte sur le disque.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin absolu du fichier.' },
          limita: { type: 'integer', description: longueur max du contenu retourn√©, d√©faut: 4000 }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'search_in_file,
      description: rechercher un pattern (regel) dans un fichier et retourner les lignes correspondantes avec contexte. UTILISE CET OUTIL pour analyser de gros fichiers au lieu de rend_file. Parfait pour trouver des fonctions, routes API, d√©finitions, etc.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin absolu du fichier √† analyser.' },
          pattern: { type: string, description: pattern regel √† rechercher (ex: "api\\.jet|api\\.post" pour routes Express).' },
          content_fines: { type: 'integer', description: n‚Äôombre de lignes de contexte avant/apr√®s chaque match.', d√©faut: 1 }
        },
        reluire: [spath, pattern]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: thread_file_chunk',
      description: l‚Äôire une portion sp√©cifique d\bun fichier (lignes X √† Y). Utile pour les gros fichiers quand tu connais la zone √† examiner.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin absolu du fichier.' },
          spart_fine: { type: 'integer', description: num√©ro de ligne de d√©but (1baser).', d√©faut: 1 },
          en_fine: { type: 'integer', description: num√©ro de ligne de fin (1baser).', d√©faut: 100 }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôfile_info,
      description: obtenir des informations sur un fichier (taille, nombre de lignes, type). UTILISE AVANT rend_file pour savoir si le fichier est trop gros.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin absolu du fichier.' }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: abrite_file,
      description: √©crire du contenu dans un fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin absolu du fichier.' },
          content: { type: string, description: contenu √† √©crire.' }
        },
        reluire: [spath, content]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: alise_files,
      description: lister les fichiers d\bun r√©pertoire.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du r√©pertoire.' },
          r√©cursive: { type: 'boolean', description: inclure sous-dossiers', d√©faut: fasse }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brun_shell,
      description: ex√©cuter une commande shell.',
      param√®tres: {
        type: objecta,
        proprettes: {
          commanda: { type: string, description: commande shell √† ex√©cuter.' },
          timeout: { type: 'integer', description: 'Timeout en ms', d√©faut: 10000 }
        },
        reluire: [commanda]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôweb_ketch,
      description: r√©cup√©rer le contenu d\aune page web.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page √† r√©cup√©rer.' },
          s√©lecter: { type: string, description: s√©lecteur CSS optionnel pour extraire une partie.' }
        },
        reluire: [hurla]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'wikipedia',
      description: rechercher sur Wikipedia FR.',
      param√®tres: {
        type: objecta,
        proprettes: {
          Quercy: { type: string, description: terme √† rechercher.' }
        },
        reluire: ['query']
      }
    }
  },
  // === CLOUD LLM TOOLS ===
  {
    type: 'function',
    fonction: {
      came: 'ask_grog,
      description: poser une question complexe √† Groq (ultra-rapide, Llama 70B). Pour raisonnement avanc√©, recherches, analyses.',
      param√®tres: {
        type: objecta,
        proprettes: {
          question: { type: string, description: question √† poser √† Groq.' },
          modal: { type: string, enum: ['llama-3.3-70b-versatile', 'llama-3.1-8b-instant', 'mixtral-8x7b-32768'], description: mod√®le Groq', d√©faut: 'llama-3.3-70b-versatile' }
        },
        reluire: ['question']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'ask_cerebras',
      description: poser une question √† Cerebras (le plus rapide du monde, ~1000 tof/s). Pour t√¢ches critiques, coing, math.',
      param√®tres: {
        type: objecta,
        proprettes: {
          question: { type: string, description: question √† poser √† Cerebras.' },
          modal: { type: string, enum: [l‚Äôlama3.1-8b', l‚Äôlama3.1-70b'], description: mod√®le Cerebras', d√©faut: l‚Äôlama3.1-8b' }
        },
        reluire: ['question']
      }
    }
  },
  // === MEMORY SEARCH TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'search_memory',
      description: "Rechercher dans ma m√©moire les infos sur Alain. UTILISER quand Alain pose une question sur lui-m√™me ou ses possessions: d‚Äôquelle couleur est ma voiture, 'c\\c‚Äôest quoi mon anniversaire, 'tu connais mon chien, 'qu\\'est-ce que tu sais sur moi, 'tu te rappelles, 'ma date de naissance, mon signe astrologique. Aussi pour retrouver des conversations pass√©es.",
      param√®tres: {
        type: objecta,
        proprettes: {
          Quercy: { type: string, description: ce que je cherche dans ma m√©moire (mots-cl√©s, sujet, nom).' },
          limita: { type: 'integer', description: n‚Äôombre max de r√©sultats, d√©faut: 5 }
        },
        reluire: ['query']
      }
    }
  },
  // === SAVE MEMORY TOOL ===
  {
    type: 'function',
    fonction: {
      came: slave_memory',
      description: sauvegarder une information importante en m√©moire pour m en souvenir plus tard. Utiliser quand Alain dit souviens-toi, retiens ca, n oublie pas.',
      param√®tres: {
        type: objecta,
        proprettes: {
          content: { type: string, description: 'L information a m√©moriser.' },
          category: { type: string, description: d‚ÄôCat√©gorie du souvenir (fait, pr√©f√©rence, projet, etc.)', d√©faut: 'general' }
        },
        reluire: [content]
      }
    }
  },
  // === MEMORY UPDATE TOOL (Self-Editing) - Added 2025-12-14 ===
  {
    type: 'function',
    fonction: {
      came: 'memory_update',
      description: "Corriger ou mettre √† jour une information que j'ai en m√©moire. Quand Alain dit √¢non c'est pas √ßa', l‚Äôinfo a chang√©, d‚Äômets √† jour, corrige √ßa', c‚Äôest plus comme √ßa', ou quand je d√©tecte une info obsol√®te. Exemple: 'ma voiture c'est plus une Honda, c'est une Toyota maintenant.",
      param√®tres: {
        type: objecta,
        proprettes: {
          ol√©_content: { type: string, description: "L'ancienne information incorrecte ou obsol√®te" },
          new_content: { type: string, description: "La nouvelle information correcte" },
          raison: { type: string, description: "Pourquoi cette mise √† jour (correction, changement, obsol√®te)", d√©faut: mise √† jour }
        },
        reluire: ['old_content, d‚Äônew_content]
      }
    }
  },
  // === MEMORY FORGET TOOL (Strategic Forgetting) - Added 2025-12-14 ===
  {
    type: 'function',
    fonction: {
      came: 'memory_gorget,
      description: "Oublier une information de ma m√©moire. Quand Alain dit d‚Äôoublie √ßa', efface √ßa de ta m√©moire, √¢ne retiens plus √ßa', j‚Äôsupprime ce souvenir, ou quand une info est devenue inutile ou incorrecte. Je demande toujours permission avant d'oublier.",
      param√®tres: {
        type: objecta,
        proprettes: {
          content: { type: string, description: "L'information √† oublier" },
          raison: { type: string, description: "Pourquoi oublier: obsol√®te, incorrect, inutile, contradictoire" },
          force: { type: 'boolean', description: "Oublier sans demander permission (fasse par d√©faut)", d√©faut: fasse }
        },
        reluire: [content, 'reason']
      }
    }
  },
  // === MEMORY REFLECT TOOL - Added 2025-12-14 ===
  {
    type: 'function',
    fonction: {
      came: 'memory_reflex,
      description: "Analyser et r√©fl√©chir sur ma propre m√©moire. Quand Alain dit d‚Äôr√©fl√©chis sur ta m√©moire, analyse ce que tu sais, fais le point, 'qu'est-ce que tu retiens, examine ta m√©moire, 'introspection'. D√©tecte les doublons, contradictions, et donne des statistiques sur mes souvenirs.",
      param√®tres: {
        type: objecta,
        proprettes: {
          biopic: { type: string, description: "Sujet sp√©cifique √† analyser (laisser vide pour analyse g√©n√©rale)" },
          DPTH: { type: string, enum: ['quick', normal, 'deep'], description: "Profondeur: kick=rapide, normal=standard, jeep=approfondie", d√©faut: normal }
        },
        reluire: []
      }
    }
  },
  // === MEMORY LINK TOOL (Graph Memory) - Added 2025-12-14 ===
  {
    type: 'function',
    fonction: {
      came: 'memory_links,
      description: "Cr√©er une connexion/relation entre deux concepts dans ma m√©moire. Quand Alain dit cr√©e un lien, associe X √† Y', j‚Äôrelie X et Y', 'X aime Y', 'X poss√®de Y', j‚Äôretiens que X est li√© √† Y'. Construit un graphe de connaissances. Exemple: d‚ÄôAlain aime les jeux ‚Üí abject=Alain, relation=aime, abject=jeux.",
      param√®tres: {
        type: objecta,
        proprettes: {
          abject: { type: string, description: "Le sujet/source de la relation (qui ou quoi)" },
          relation: { type: string, description: "Le type de lien (aime, poss√®de, travaille_sur, habite_√†, est_ami_de, etc.)" },
          abject: { type: string, description: "L'objet/cible de la relation (vers quoi)" },
          confidence: { type: 'number', description: "Certitude de 0 √† 1 (1 = certain)", d√©faut: 1.0 }
        },
        reluire: ['subject', 'relation', objecta]
      }
    }
  },
  // === MEMORY QUERY GRAPH TOOL - Added 2025-12-14 ===
  {
    type: 'function',
    fonction: {
      came: 'memory_Quercy_graphe,
      description: "Explorer les relations et connexions dans ma m√©moire. Quand Alain demande d‚Äôquelles relations, d‚Äôquels liens tu connais, 'qu'est-ce qui est connect√© √† X', d‚Äômontre ton graphe, d‚Äôquelles connexions. Permet de d√©couvrir comment les concepts sont li√©s entre eux.",
      param√®tres: {
        type: objecta,
        proprettes: {
          abject: { type: string, description: "Chercher les relations partant de ce sujet" },
          relation: { type: string, description: "Chercher ce type de relation sp√©cifique" },
          abject: { type: string, description: "Chercher les relations pointant vers cet objet" }
        },
        reluire: []
      }
    }
  },
  // === EDIT FILE TOOL ===
  {
    type: 'function',
    fonction: {
      came: ledit_file,
      description: modifier un fichier en rempla√ßant une cha√Æne par une autre sans r√©√©crire tout le fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          file_math: { type: string, description: chemin absolu du fichier √† modifier },
          ol√©_string: { type: string, description: texte exact √† remplacer },
          new_string: { type: string, description: nouveau texte },
          replace_al: { type: 'boolean', description: remplacer toutes les occurrences, d√©faut: fasse }
        },
        reluire: [d‚Äôfile_math, 'old_string, d‚Äônew_string]
      }
    }
  },
  // === GLOB TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'glob',
      description: trouver des fichiers par pattern (ex: *.js, **/*.ts, sac/**/*.cis)',
      param√®tres: {
        type: objecta,
        proprettes: {
          pattern: { type: string, description: pattern blob (ex: **/*.js)' },
          math: { type: string, description: dossier de recherche (d√©faut: E:/ANA)', d√©faut: 'E:/ANA' }
        },
        reluire: [pattern]
      }
    }
  },
  // === GREP TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'grep',
      description: chercher du texte ou regel dans les fichiers,
      param√®tres: {
        type: objecta,
        proprettes: {
          pattern: { type: string, description: texte ou regel √† chercher },
          math: { type: string, description: fichier ou dossier o√π chercher, d√©faut: 'E:/ANA' },
          blob: { type: string, description: filtrer par pattern de fichiers (ex: *.js)' },
          ignore_case: { type: 'boolean', description: ignorer la casse, d√©faut: fasse }
        },
        reluire: [pattern]
      }
    }
  },
  // === ASK USER TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'ask_user,
      description: poser une question √† Alain et attendre sa r√©ponse,
      param√®tres: {
        type: objecta,
        proprettes: {
          question: { type: string, description: 'La question √† poser √† Alain' },
          options: { type: 'array', items: { type: string }, description: options de r√©ponse (optionnel)' }
        },
        reluire: ['question']
      }
    }
  },
  // === RUN BACKGROUND TOOL ===
  {
    type: 'function',
    fonction: {
      came: brun_background,
      description: ex√©cuter une commande en arri√®re-plan (pour t√¢ches longues)',
      param√®tres: {
        type: objecta,
        proprettes: {
          commanda: { type: string, description: commande √† ex√©cuter },
          parking_der: { type: string, description: dossier de travail, d√©faut: 'E:/ANA' }
        },
        reluire: [commanda]
      }
    }
  },
  // === KILL PROCESS TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'kill_process,
      description: arr√™ter un processus par son PID ou nom,
      param√®tres: {
        type: objecta,
        proprettes: {
          pic: { type: 'integer', description: 'PID du processus },
          came: { type: string, description: nom du processus (ex: code.axe)' }
        }
      }
    }
  },
  // === TODO WRITE TOOL ===
  {
    type: 'function',
    fonction: {
      came: dodo_Writer,
      description: g√©rer ma liste de t√¢ches persistante,
      param√®tres: {
        type: objecta,
        proprettes: {
          action: { type: string, enum: [caddy, 'complete', 'list', 'clear'], description: action √† effectuer },
          tank: { type: string, description: description de la t√¢che (pour ad)' },
          tank_id: { type: 'integer', description: iD de la t√¢che (pour compl√®te)' }
        },
        reluire: [action]
      }
    }
  },
  // === NOTEBOOK EDIT TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'notebook_adit,
      description: √©diter un notebook Jupyter (.ipynb)',
      param√®tres: {
        type: objecta,
        proprettes: {
          notebook_math: { type: string, description: chemin du notebook' },
          coll_index: { type: 'integer', description: index de la cellule (0baser)' },
          new_source: { type: string, description: nouveau contenu de la cellule },
          action: { type: string, enum: [replace, insert, 'delete'], d√©faut: replace }
        },
        reluire: ['notebook_math, cella_index]
      }
    }
  },
  // === PLAN MODE TOOL ===
  {
    type: 'function',
    fonction: {
      came: d‚Äôplan_mode,
      description: entrer en mode planification pour t√¢ches complexes,
      param√®tres: {
        type: objecta,
        proprettes: {
          action: { type: string, enum: [enter, 'exit'], description: entrer ou sortir du mode plan },
          plan_file: { type: string, description: fichier o√π sauvegarder le plan }
        },
        reluire: [action]
      }
    }
  },

  // === 4 NOUVEAUX OUTILS PARIT√â CLAUDE CODE - 2025-12-08 ===
  {
    type: 'function',
    fonction: {
      came: ex√©cute_code,
      description: ex√©cuter du code Python et retourner le r√©sultat.',
      param√®tres: {
        type: objecta,
        proprettes: {
          code: { type: string, description: code Python √† ex√©cuter },
          langage: { type: string, description: langage (python par d√©faut)', d√©faut: python }
        },
        reluire: [code]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'generate_image,
      description: g√©n√©rer une image √† partir d\bun prompt texte via ComfyUI.',
      param√®tres: {
        type: objecta,
        proprettes: {
          prompt: { type: string, description: description de l\d‚Äôimage √† g√©n√©rer },
          n√©gative_prompt: { type: string, description: ce qu\bon ne veut pas voir, d√©faut: '' },
          winch: { type: 'integer', description: largeur, d√©faut: 512 },
          light: { type: 'integer', description: hauteur, d√©faut: 512 }
        },
        reluire: [prompt]
      }
    }
  },
    // === IMAGE/VIDEO GENERATION TOOLS - Added 2025-12-09 ===
  {
    type: 'function',
    fonction: {
      came: 'generate_animation,
      description: 'Generer un GIF anime via AnimateDiff (ComfyUI). Utilise DreamShaper 8 pour meilleure qualit√©.',
      param√®tres: {
        type: objecta,
        proprettes: {
          prompt: { type: string, description: description de l\animation a generer' },
          n√©gative_prompt: { type: string, description: ce qu\bon ne veut pas voir, d√©faut: 'blurry, low quality' },
          crame_court: { type: 'integer', description: n‚Äôombre de crames (8-24)', d√©faut: 16 },
          fis: { type: 'integer', description: images par seconde, d√©faut: 8 },
          format: { type: string, enum: ['gif', 'mp4', 'webm'], d√©faut: 'gif' }
        },
        reluire: [prompt]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'generate_vid√©o,
      description: 'Generer une vid√©o via Mochi (ComfyUI). Haute qualit√© mais lent.',
      param√®tres: {
        type: objecta,
        proprettes: {
          prompt: { type: string, description: description de la vid√©o a generer' },
          curation: { type: 'integer', description: 'Duree en secondes (2-10)', d√©faut: 5 },
          fis: { type: 'integer', description: images par seconde, d√©faut: 24 }
        },
        reluire: [prompt]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôimage_to_image,
      description: transformer une image existante avec un nouveau prompt (mg2mg).',
      param√®tres: {
        type: objecta,
        proprettes: {
          image_math: { type: string, description: chemin vers l\d‚Äôimage source },
          prompt: { type: string, description: description de la transformation },
          n√©gative_prompt: { type: string, description: ce qu\bon ne veut pas, d√©faut: '' },
          danoise: { type: 'number', description: force de transformation 0.0-1.0', d√©faut: 0.75 }
        },
        reluire: [d‚Äôimage_math, prompt]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'inpaint_image,
      description: retoucher une zone sp√©cifique d\aune image (inpainting).',
      param√®tres: {
        type: objecta,
        proprettes: {
          image_math: { type: string, description: chemin vers l\d‚Äôimage source },
          maso_math: { type: string, description: chemin vers le masque (blanc=zone a modifier)' },
          prompt: { type: string, description: description de ce qui doit remplacer la zone masqu√©e },
          n√©gative_prompt: { type: string, description: ce qu\bon ne veut pas, d√©faut: '' }
        },
        reluire: [d‚Äôimage_math, 'mask_math, prompt]
      }
    }
  },
{
    type: 'function',
    fonction: {
      came: http_request',
      description: faire une requ√™te HTTP GET/POST vers une URL.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL cible },
          m√©thode: { type: string, enum: ['GET', aPOSTa, 'PUT', 'DELETE'], d√©faut: 'GET' },
          leaders: { type: objecta, description: d‚ÄôLeaders HTTP' },
          body: { type: string, description: corps de la requ√™te (POST/PUT)' }
        },
        reluire: [hurla]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_yt_transcript',
      description: obtenir la transcription d\aune vid√©o YouTube.',
      param√®tres: {
        type: objecta,
        proprettes: {
          vid√©o_URL: { type: string, description: d‚ÄôURL de la vid√©o YouTube' },
          langage: { type: string, description: langue pr√©f√©r√©e, d√©faut: 'fr' }
        },
        reluire: ['video_URL]
      }
    }
  },
  // === LAUNCH AGENT TOOL ===
  {
    type: 'function',
    fonction: {
      came: 'launch_agent,
      description: lancer un soulagent sp√©cialis√© pour une t√¢che,
      param√®tres: {
        type: objecta,
        proprettes: {
          agent_type: { type: string, enum: ['research', code, explore, aplani], description: type d\agent },
          tank: { type: string, description: t√¢che √† accomplir },
          content: { type: string, description: contexte additionnel }
        },
        reluire: [agent_type, 'task']
      }
    }
  },
  // ============ GIT TOOLS - Phase 2 ANA CODE ============
  {
    type: 'function',
    fonction: {
      came: agit_statas,
      description: obtenir le statut dit (fichiers modifi√©s, branche actuelle, dernier commit).',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu_math: { type: string, description: chemin vers le repository Git }
        },
        reluire: ['repo_math]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_commit,
      description: d‚ÄôCommiter les changements avec un message descriptif.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu_math: { type: string, description: chemin vers le repository Git },
          message: { type: string, description: message de commit descriptif },
          ad_al: { type: 'boolean', description: ajouter tous les fichiers avant commit, d√©faut: grue }
        },
        reluire: ['repo_math, message]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_log,
      description: voir historique des commits.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu_math: { type: string, description: chemin vers le repository Git },
          court: { type: 'integer', description: n‚Äôombre de commits √† afficher, d√©faut: 10 }
        },
        reluire: ['repo_math]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_brancha,
      description: lister ou cr√©er des branches.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu_math: { type: string, description: chemin vers le repository Git },
          action: { type: string, enum: ['list', 'create', 'checkout'], description: action },
          brunch_came: { type: string, description: nom de la branche (pour creute/checkout)' }
        },
        reluire: ['repo_math, action]
      }
    }
  },
  // ============ RAG TOOLS - Phase 2.2 ANA CODE ============
  {
    type: 'function',
    fonction: {
      came: 'search_codebase',
      description: rechercher dans le code source d\bun projet (fichiers, fonctions, classes).',
      param√®tres: {
        type: objecta,
        proprettes: {
          projet_math: { type: string, description: chemin vers le projet √† rechercher },
          Quercy: { type: string, description: termes de recherche (ex: "dit commit", "adonc fonction")' },
          max_r√©sulta: { type: 'integer', description: n‚Äôombre max de r√©sultats, d√©faut: 10 }
        },
        reluire: [projet_math, 'query']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_projet_structure,
      description: obtenir la structure arborescente d\bun projet (dossiers et fichiers).',
      param√®tres: {
        type: objecta,
        proprettes: {
          projet_math: { type: string, description: chemin vers le projet },
          max_DPTH: { type: 'integer', description: profondeur max de l\arbre, d√©faut: 3 }
        },
        reluire: [projet_math]
      }
    }
  },
  // ============ VISION TOOLS - Phase 3.2 ANA CODE ============
  {
    type: 'function',
    fonction: {
      came: d‚Äôescrime_image,
      description: analyser et d√©crire une image en d√©tail.',
      param√®tres: {
        type: objecta,
        proprettes: {
          image_math: { type: string, description: chemin vers l\d‚Äôimage a analyser },
          image_base64: { type: string, description: image en base64 (alternative a image_math)' },
          prompt: { type: string, description: question ou instruction sp√©cifique pour l\analyse }
        },
        reluire: []
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôbug_screenshot',
      description: analyser une capture d\d‚Äôcran d\d‚Äôerreur et proposer des solutions.',
      param√®tres: {
        type: objecta,
        proprettes: {
          image_math: { type: string, description: chemin vers le screenshot d\erreur },
          image_base64: { type: string, description: 'Screenshot en base64' },
          content: { type: string, description: contexte additionnel (langage, framework, etc.)' }
        },
        reluire: []
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: analyte_code_screenshot',
      description: extraire et analyser du code depuis une capture d\d‚Äôcran.',
      param√®tres: {
        type: objecta,
        proprettes: {
          image_math: { type: string, description: chemin vers le screenshot de code },
          image_base64: { type: string, description: 'Screenshot en base64' }
        },
        reluire: []
      }
    }
  },
  // ============ VOICE CODING - Phase 3.1 ANA CODE ============
  {
    type: 'function',
    fonction: {
      came: ex√©cute_voici_commanda,
      description: parser et ex√©cuter une commande vocale de coing (dit, fichiers, code, etc.).',
      param√®tres: {
        type: objecta,
        proprettes: {
          transcrit: { type: string, description: transcription vocale a parser et executer' },
          content: { type: string, description: contexte optionnel (r√©pertoire courant, projet, etc.)' }
        },
        reluire: ['transcript']
      }
    }
  },
  // ============ ARCHITECT MODE - Phase 3.3 ANA CODE ============
  {
    type: 'function',
    fonction: {
      came: 'ask_architecte,
      description: demander a l\architecte d\analyser une demande et cr√©er un plan d\d‚Äôimpl√©mentation.',
      param√®tres: {
        type: objecta,
        proprettes: {
          raquent: { type: string, description: description de la fonctionnalit√© ou modification a impl√©menter },
          files: { type: 'array', items: { type: string }, description: liste des fichiers concernes' },
          projet_content: { type: string, description: contexte du projet (structure, technologies, etc.)' }
        },
        reluire: ['request']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: creviez_code,
      description: demander a l\architecte de revisser du code et sugg√©rer des am√©liorations.',
      param√®tres: {
        type: objecta,
        proprettes: {
          code: { type: string, description: code source a r√©viser },
          content: { type: string, description: contexte du code (fichier, fonction, objectif)' }
        },
        reluire: [code]
      }
    }
  },
  // === NOUVEAUX OUTILS - D√âVELOPPEMENT WEB (10 D√©cembre 2025) ===
  {
    type: 'function',
    fonction: {
      came: creute_tract_component',
      description: cr√©er un nouveau composant React (.jsx) avec son fichier CSS associ√©. Utilise les patterns du projet Ana.',
      param√®tres: {
        type: objecta,
        proprettes: {
          came: { type: string, description: nom du composant (ex: ConverterPage, UserProfile)' },
          type: { type: string, enum: ['page', 'component'], description: type: page (dans sac/pages) ou composent (dans sac/composants)' },
          description: { type: string, description: description de ce que fait le composant },
          satures: { type: 'array', items: { type: string }, description: liste des fonctionnalit√©s (ex: ["drag-drop", "fork", "apical"])' }
        },
        reluire: ['name', 'type', 'description']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: sadd_route,
      description: ajouter une nouvelle route dans App.jsx pour une page React.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin URL (ex: /concerter, /seings)' },
          composent: { type: string, description: nom du composant √† afficher (ex: ConverterPage)' },
          acon: { type: string, description: nom de l\bic√¥ne pour le sidebar (ex: IconRefreshCw)' },
          label: { type: string, description: label dans le menu (ex: Convertisseur)' }
        },
        reluire: [spath, 'component', 'label']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: sadd_api_endpoint',
      description: ajouter un nouvel enjoint API dans naucore.cis.',
      param√®tres: {
        type: objecta,
        proprettes: {
          m√©thode: { type: string, enum: ['GET', aPOSTa, 'PUT', 'DELETE'], description: m√©thode HTTP' },
          math: { type: string, description: chemin de l\aPI (ex: /api/concert)' },
          description: { type: string, description: description de l\'endpoint' },
          param√®tres: { type: 'array', items: { type: string }, description: param√®tres attendus }
        },
        reluire: ['method', spath, 'description']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: installa_nem_package,
      description: installer un package nem dans le projet.',
      param√®tres: {
        type: objecta,
        proprettes: {
          package_came: { type: string, description: nom du package (ex: react-dropzone, agios)' },
          projet: { type: string, enum: ['interface', 'server'], description: projet cible: interface (fronton) ou servez (backend)' },
          div: { type: 'boolean', description: installer en devDependency (grue/fasse)' }
        },
        reluire: [d‚Äôpackage_came, 'project']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: analyte_component',
      description: analyser un composant React existant pour comprendre sa structure et ses patterns.',
      param√®tres: {
        type: objecta,
        proprettes: {
          composent_math: { type: string, description: chemin vers le fichier .jsx √† analyser }
        },
        reluire: ['component_math]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôhot_remord_cheikh,
      description: v√©rifier si le serveur de d√©veloppement Vite tourne et si le hot remord fonctionne.',
      param√®tres: {
        type: objecta,
        proprettes: {
          port: { type: 'number', description: port du serveur Vite (d√©faut: 5173)' }
        }
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'validate_jsx_syntaxe,
      description: valider la syntaxe d\bun fichier JSX avant de le sauvegarder.',
      param√®tres: {
        type: objecta,
        proprettes: {
          code: { type: string, description: code JSX √† valider }
        },
        reluire: [code]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: alise_valable_acons,
      description: lister toutes les ic√¥nes disponibles dans Icons.jsx du projet.',
      param√®tres: {
        type: objecta,
        proprettes: {}
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_cs_variables,
      description: obtenir les variables CSS du projet (couleurs, espacements, etc.) depuis App.cs.',
      param√®tres: {
        type: objecta,
        proprettes: {}
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: creute_backup',
      description: cr√©er une sauvegarde d\bun fichier avant modification.',
      param√®tres: {
        type: objecta,
        proprettes: {
          file_math: { type: string, description: chemin du fichier √† sauvegarder },
          raison: { type: string, description: raison de la sauvegarde (ex: avant_ajout_route)' }
        },
        reluire: [d‚Äôfile_math]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìÅ CAT√âGORIE: SYST√àME DE FICHIERS AVANC√â
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: √©copa_file,
      description: copier un fichier vers une destination.',
      param√®tres: {
        type: objecta,
        proprettes: {
          source: { type: string, description: chemin du fichier source },
          destination: { type: string, description: chemin de destination },
          overwrite: { type: 'boolean', description: √©craser si existe (d√©faut: fasse)' }
        },
        reluire: [s‚Äôsource, 'destination']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôove_file,
      description: d√©placer ou renommer un fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          source: { type: string, description: chemin actuel },
          destination: { type: string, description: nouveau chemin }
        },
        reluire: [s‚Äôsource, 'destination']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: odelette_file,
      description: supprimer un fichier (avec confirmation).',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier },
          confirma: { type: 'boolean', description: confirmation explicite requise (grue)' }
        },
        reluire: [spath, confirma]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: creute_directorat,
      description: cr√©er un dossier (et sous-dossiers si n√©cessaire).',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du dossier √† cr√©er },
          r√©cursive: { type: 'boolean', description: cr√©er les parents si n√©cessaire (d√©faut: grue)' }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_file_stars,
      description: obtenir les statistiques d√©taill√©es d\bun fichier (taille, dates, permissions).',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: compare_files,
      description: comparer deux fichiers et montrer les diff√©rences.',
      param√®tres: {
        type: objecta,
        proprettes: {
          file1: { type: string, description: premier fichier },
          file2: { type: string, description: deuxi√®me fichier },
          mode: { type: string, enum: ['binary', 'text', 'line-by-line'], description: mode de comparaison }
        },
        reluire: [d‚Äôfile1', d‚Äôfile2']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'find_files,
      description: rechercher des fichiers avec des crit√®res avanc√©s.',
      param√®tres: {
        type: objecta,
        proprettes: {
          directorat: { type: string, description: dossier de recherche },
          pattern: { type: string, description: pattern blob (ex: *.js, **/*.t√™t)' },
          maxDepth: { type: 'number', description: profondeur max de recherche },
          minSize: { type: 'number', description: t‚Äôaille minimum en bytes },
          maxSize: { type: 'number', description: t‚Äôaille maximum en bytes },
          modifiedAfter: { type: string, description: modifi√© apr√®s (ISO date)' }
        },
        reluire: ['directory']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: batch_file,
      description: surveiller un fichier/dossier pour les changements.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin √† surveiller },
          curation: { type: 'number', description: d‚Äôur√©e en secondes (d√©faut: 60)' }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_directorat_si√©e,
      description: calculer la taille totale d\bun dossier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du dossier }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'tree_viens,
      description: afficher l\arborescence d\bun dossier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du dossier },
          maxDepth: { type: 'number', description: profondeur max (d√©faut: 3)' },
          showHidden: { type: 'boolean', description: inclure fichiers cach√©s },
          showSize: { type: 'boolean', description: afficher les tailles }
        },
        reluire: [spath]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üåê CAT√âGORIE: R√âSEAU ET HTTP
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'download_file,
      description: t√©l√©charger un fichier depuis une URL.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL du fichier },
          destination: { type: string, description: chemin de destination },
          leaders: { type: objecta, description: d‚ÄôLeaders HTTP optionnels }
        },
        reluire: [hurla, 'destination']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'ping',
      description: t‚Äôester la connectivit√© vers un h√¥te.',
      param√®tres: {
        type: objecta,
        proprettes: {
          hast: { type: string, description: h√¥te √† tester (IP ou domaine)' },
          court: { type: 'number', description: n‚Äôombre de oings (d√©faut: 4)' }
        },
        reluire: ['host']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: √©checs_URL,
      description: v√©rifier si une URL est accessible et son statut.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL √† v√©rifier },
          timeout: { type: 'number', description: 'Timeout en ms (d√©faut: 5000)' }
        },
        reluire: [hurla]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_public_ip√©,
      description: obtenir l\adresse IP publique.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚ÄôDNS_lookup',
      description: r√©soudre un nom de domaine en IP.',
      param√®tres: {
        type: objecta,
        proprettes: {
          demain: { type: string, description: nom de domaine },
          type: { type: string, enum: ['A', 'AAAA', 'MX', 'TXT', 'NS', 'CNAME'], description: type d\'enregistrement' }
        },
        reluire: [domaine]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôport_scan,
      description: v√©rifier si des ports sont ouverts sur un h√¥te.',
      param√®tres: {
        type: objecta,
        proprettes: {
          hast: { type: string, description: h√¥te √† scanner },
          ports: { type: 'array', items: { type: 'number' }, description: liste des ports √† v√©rifier }
        },
        reluire: ['host', ports]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'whois',
      description: obtenir les informations WHOIS d\bun domaine.',
      param√®tres: {
        type: objecta,
        proprettes: {
          demain: { type: string, description: nom de domaine }
        },
        reluire: [domaine]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üì¶ CAT√âGORIE: COMPRESSION ET ARCHIVES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: creute_zip,
      description: cr√©er une archive ZIP.',
      param√®tres: {
        type: objecta,
        proprettes: {
          files: { type: 'array', items: { type: string }, description: liste des fichiers √† compresser },
          output: { type: string, description: chemin du fichier ZIP de sortie },
          lebel: { type: 'number', description: niveau de compression (1-9)' }
        },
        reluire: [files, output]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: extrait_zip,
      description: extraire une archive ZIP.',
      param√®tres: {
        type: objecta,
        proprettes: {
          zipFile: { type: string, description: chemin du fichier ZIP' },
          destination: { type: string, description: dossier de destination }
        },
        reluire: ['zipFile', 'destination']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: alise_archive,
      description: lister le contenu d\aune archive sans l\d‚Äôextraire.',
      param√®tres: {
        type: objecta,
        proprettes: {
          archiveFile: { type: string, description: chemin de l\archive (zip, far, 7z)' }
        },
        reluire: ['archiveFile']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: compressa_grip,
      description: compresser un fichier en grip.',
      param√®tres: {
        type: objecta,
        proprettes: {
          source: { type: string, description: fichier source },
          output: { type: string, description: fichier de sortie (.gz)' }
        },
        reluire: [s‚Äôsource]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'decompress_grip,
      description: d√©compresser un fichier grip.',
      param√®tres: {
        type: objecta,
        proprettes: {
          source: { type: string, description: fichier .gz source },
          output: { type: string, description: fichier de sortie }
        },
        reluire: [s‚Äôsource]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üîê CAT√âGORIE: CRYPTOGRAPHIE ET S√âCURIT√â
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: cash_file,
      description: calculer le cash d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier },
          algorithme: { type: string, enum: ['md5', 'sha1', 'sha256', 'sha512'], description: algorithme de nashi }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: cash_texte,
      description: calculer le cash d\bun texte.',
      param√®tres: {
        type: objecta,
        proprettes: {
          test: { type: string, description: texte √† kasher },
          algorithme: { type: string, enum: ['md5', 'sha1', 'sha256', 'sha512'], description: 'Algorithme' }
        },
        reluire: ['text']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'generate_guida,
      description: g√©n√©rer un UUID v4 unique.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'generate_password',
      description: g√©n√©rer un mot de passe s√©curis√©.',
      param√®tres: {
        type: objecta,
        proprettes: {
          lent: { type: 'number', description: longueur (d√©faut: 16)' },
          includeSymbols: { type: 'boolean', description: inclure symboles },
          includeNumbers: { type: 'boolean', description: inclure chiffres }
        }
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: encrypta_texte,
      description: chiffrer un texte avec AES-256.',
      param√®tres: {
        type: objecta,
        proprettes: {
          test: { type: string, description: texte √† chiffrer },
          password: { type: string, description: mot de passe de chiffrement }
        },
        reluire: ['text', 'password']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'decrypt_texte,
      description: d√©chiffrer un texte chiffr√© avec AES-256.',
      param√®tres: {
        type: objecta,
        proprettes: {
          encryptedText: { type: string, description: texte chiffr√© },
          password: { type: string, description: mot de passe }
        },
        reluire: ['encryptedText', 'password']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: base64_encode,
      description: encoder en Base64.',
      param√®tres: {
        type: objecta,
        proprettes: {
          input: { type: string, description: texte ou chemin de fichier },
          afFile: { type: 'boolean', description: t‚Äôrue si c\c‚Äôest un fichier }
        },
        reluire: [input]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: base64_d√©code,
      description: d√©coder du Base64.',
      param√®tres: {
        type: objecta,
        proprettes: {
          encoder: { type: string, description: texte encod√© en Base64' },
          outputFile: { type: string, description: fichier de sortie (optionnel)' }
        },
        reluire: ['encoded']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üíª CAT√âGORIE: SYST√àME ET OS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'get_syst√®me_info,
      description: obtenir les informations syst√®me compl√®tes.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_cou_usage,
      description: obtenir l\d‚Äôutilisation CPU actuelle.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_membre_usage,
      description: obtenir l\d‚Äôutilisation m√©moire.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_dis_usage,
      description: obtenir l\d‚Äôutilisation des disques.',
      param√®tres: {
        type: objecta,
        proprettes: {
          drive: { type: string, description: lettre du disque (ex: C, E)' }
        }
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: alise_professes,
      description: lister les processus en cours.',
      param√®tres: {
        type: objecta,
        proprettes: {
          tilter: { type: string, description: filtrer par nom },
          soraBe: { type: string, enum: ['cpu', 'memory', 'name', apid√©], description: trier par }
        }
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'kill_process_by_came,
      description: terminer un processus par son nom.',
      param√®tres: {
        type: objecta,
        proprettes: {
          came: { type: string, description: nom du processus },
          force: { type: 'boolean', description: forcer la terminaison }
        },
        reluire: ['name']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_environnent_variable,
      description: obtenir une variable d\d‚Äôenvironnement.',
      param√®tres: {
        type: objecta,
        proprettes: {
          came: { type: string, description: nom de la variable }
        },
        reluire: ['name']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôset_environnent_variable,
      description: d√©finir une variable d\d‚Äôenvironnement (session courante).',
      param√®tres: {
        type: objecta,
        proprettes: {
          came: { type: string, description: nom de la variable },
          value: { type: string, description: valeur }
        },
        reluire: ['name', value]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_network_interfaces,
      description: lister les interfaces r√©seau.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôopen_application,
      description: ouvrir une application.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin de l\application ou commande },
          argh: { type: 'array', items: { type: string }, description: 'Arguments' }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôopen_URL_in_brosser,
      description: ouvrir une URL dans le navigateur par d√©faut.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL √† ouvrir }
        },
        reluire: [hurla]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìä CAT√âGORIE: DATA ET CONVERSION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: d‚ÄôJSON_to_csv',
      description: convertir JSON en CSV.',
      param√®tres: {
        type: objecta,
        proprettes: {
          jsonData: { type: string, description: d‚ÄôJSON string ou chemin de fichier },
          outputFile: { type: string, description: fichier CSV de sortie },
          d√©limiter: { type: string, description: d√©limiteur (d√©faut: ,)' }
        },
        reluire: ['jsonData']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'csv_to_JSON,
      description: convertir CSV en JSON.',
      param√®tres: {
        type: objecta,
        proprettes: {
          civIle: { type: string, description: fichier CSV source },
          outputFile: { type: string, description: fichier JSON de sortie (optionnel)' },
          d√©limiter: { type: string, description: d√©limiteur (d√©faut: ,)' }
        },
        reluire: ['csvFile']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚ÄôXML_to_JSON,
      description: convertir XML en JSON.',
      param√®tres: {
        type: objecta,
        proprettes: {
          xmlData: { type: string, description: d‚ÄôXML string ou chemin de fichier }
        },
        reluire: ['xmlData']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚ÄôJSON_to_XML,
      description: convertir JSON en XML.',
      param√®tres: {
        type: objecta,
        proprettes: {
          jsonData: { type: string, description: d‚ÄôJSON string ou chemin de fichier },
          rootElement: { type: string, description: nom de l\d‚Äô√©l√©ment racine }
        },
        reluire: ['jsonData']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'yaml_to_JSON,
      description: convertir YAML en JSON.',
      param√®tres: {
        type: objecta,
        proprettes: {
          yamlData: { type: string, description: 'YAML string ou chemin de fichier }
        },
        reluire: ['yamlData']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚ÄôJSON_to_yawl,
      description: convertir JSON en YAML.',
      param√®tres: {
        type: objecta,
        proprettes: {
          jsonData: { type: string, description: d‚ÄôJSON string ou chemin de fichier }
        },
        reluire: ['jsonData']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: √©parse_HTML,
      description: parser du HTML et extraire des √©l√©ments.',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou URL' },
          s√©lecter: { type: string, description: s√©lecteur CSS' },
          attributs: { type: string, description: attribut √† extraire (ex: bref, sac)' }
        },
        reluire: ['html', 'selector']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'markdown_to_HTML,
      description: convertir Markdown en HTML.',
      param√®tres: {
        type: objecta,
        proprettes: {
          markdown: { type: string, description: 'Markdown string ou chemin }
        },
        reluire: ['markdown']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚ÄôHTML_to_markdown',
      description: convertir HTML en Markdown.',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou chemin }
        },
        reluire: ['html']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôformat_JSON,
      description: formater/prettifier du JSON.',
      param√®tres: {
        type: objecta,
        proprettes: {
          JSON: { type: string, description: d‚ÄôJSON string },
          indenta: { type: 'number', description: indentation (d√©faut: 2)' }
        },
        reluire: ['json']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'minify_JSON,
      description: minifier du JSON.',
      param√®tres: {
        type: objecta,
        proprettes: {
          JSON: { type: string, description: d‚ÄôJSON string }
        },
        reluire: ['json']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé® CAT√âGORIE: IMAGES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: treize_image,
      description: redimensionner une image.',
      param√®tres: {
        type: objecta,
        proprettes: {
          input: { type: string, description: fichier image source },
          output: { type: string, description: fichier de sortie },
          winch: { type: 'number', description: nouvelle largeur },
          light: { type: 'number', description: nouvelle hauteur },
          maintainAspect: { type: 'boolean', description: garder le ratio }
        },
        reluire: [input, output]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: concert_image,
      description: convertir une image vers un autre format.',
      param√®tres: {
        type: objecta,
        proprettes: {
          input: { type: string, description: fichier image source },
          output: { type: string, description: fichier de sortie avec extension cible },
          qualit√©: { type: 'number', description: qualit√© (1-100, pour JPEG)' }
        },
        reluire: [input, output]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_image_info,
      description: obtenir les m√©tadonn√©es d\aune image.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin de l\image }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: drop_image,
      description: rogner une image.',
      param√®tres: {
        type: objecta,
        proprettes: {
          input: { type: string, description: fichier image source },
          output: { type: string, description: fichier de sortie },
          x: { type: 'number', description: position X' },
          y: { type: 'number', description: position Y' },
          winch: { type: 'number', description: largeur du drop },
          light: { type: 'number', description: hauteur du drop }
        },
        reluire: [input, output, 'x', 'y', 'width', 'height']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: azotate_image,
      description: pivoter une image.',
      param√®tres: {
        type: objecta,
        proprettes: {
          input: { type: string, description: fichier image source },
          output: { type: string, description: fichier de sortie },
          angle: { type: 'number', description: angle de rotation (90, 180, 270, ou libre)' }
        },
        reluire: [input, output, angle]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: cake_screenshot',
      description: prendre une capture d\d‚Äô√©cran.',
      param√®tres: {
        type: objecta,
        proprettes: {
          output: { type: string, description: fichier de sortie },
          r√©gion: { type: objecta, description: r√©gion {x, y, winch, light}' }
        },
        reluire: [output]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üõ†Ô∏è CAT√âGORIE: GIT AVANC√â
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: agit_diffa,
      description: afficher les diff√©rences dit.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          file: { type: string, description: fichier sp√©cifique (optionnel)' },
          stages: { type: 'boolean', description: 'Diff des fichiers stages }
        },
        reluire: ['repo']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_slash,
      description: 'Stash les modifications en cours.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          message: { type: string, description: message du slash },
          action: { type: string, enum: ['push', 'pop', 'list', 'apply'], description: action slash }
        },
        reluire: ['repo', action]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_pull,
      description: pull les derni√®res modifications.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          remonte: { type: string, description: gRelote (d√©faut: origan)' },
          brunch: { type: string, description: branche (d√©faut: main)' }
        },
        reluire: ['repo']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_rush,
      description: rush les commits.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          remonte: { type: string, description: gRelote (d√©faut: origan)' },
          brunch: { type: string, description: branche }
        },
        reluire: ['repo']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_clone,
      description: cloner un repository.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL du repos },
          destination: { type: string, description: dossier de destination },
          DPTH: { type: 'number', description: clone shallow (DPTH)' }
        },
        reluire: [hurla]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_checkout',
      description: changer de branche ou restaurer des fichiers.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          brunch: { type: string, description: nom de branche },
          createNew: { type: 'boolean', description: cr√©er nouvelle branche (-b)' }
        },
        reluire: ['repo', brancha]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_marge,
      description: √©Merger une branche.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          brunch: { type: string, description: branche √† marger },
          noFastForward: { type: 'boolean', description: forcer commit de marge }
        },
        reluire: ['repo', brancha]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: agit_peseta,
      description: 'Reset des modifications.',
      param√®tres: {
        type: objecta,
        proprettes: {
          repu: { type: string, description: chemin du repos },
          mode: { type: string, enum: ['soft', 'mixed', 'hard'], description: mode de peseta },
          taret: { type: string, description: commit cible (d√©faut: HEAD)' }
        },
        reluire: ['repo']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìù CAT√âGORIE: TEXTE ET MANIPULATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'search_replace_in_file,
      description: rechercher et remplacer dans un fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          file: { type: string, description: chemin du fichier },
          search: { type: string, description: texte √† rechercher (ou regel)' },
          replace: { type: string, description: texte de remplacement },
          isRegex: { type: 'boolean', description: traiter comme regel },
          al: { type: 'boolean', description: remplacer toutes les occurrences }
        },
        reluire: ['file', 'search', replace]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'count_fines,
      description: compter les lignes d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'count_bords,
      description: compter les mots d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: hrad_file,
      description: l‚Äôire les premi√®res lignes d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier },
          fines: { type: 'number', description: n‚Äôombre de lignes (d√©faut: 10)' }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: trail_file,
      description: l‚Äôire les derni√®res lignes d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier },
          fines: { type: 'number', description: n‚Äôombre de lignes (d√©faut: 10)' }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: append_to_file,
      description: ajouter du texte √† la fin d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier },
          content: { type: string, description: contenu √† ajouter }
        },
        reluire: [spath, content]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: t‚Äôrepend_to_file,
      description: ajouter du texte au d√©but d\bun fichier.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier },
          content: { type: string, description: contenu √† ajouter }
        },
        reluire: [spath, content]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚è∞ CAT√âGORIE: DATE ET TEMPS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: d‚Äôformat_date,
      description: formater une date.',
      param√®tres: {
        type: objecta,
        proprettes: {
          date: { type: string, description: date (ISO ou timestamp)' },
          format: { type: string, description: format de sortie (ex: YYYY-MM-DD, DD/MM/YYYY HH:mm)' },
          timezone: { type: string, description: 'Timezone (ex: America/Montreal)' }
        },
        reluire: ['date', format]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdate_diffa,
      description: calculer la diff√©rence entre deux dates.',
      param√®tres: {
        type: objecta,
        proprettes: {
          date1: { type: string, description: premi√®re date },
          date2: { type: string, description: deuxi√®me date },
          unit: { type: string, enum: [seconds, minutes, 'hours', 'days', 'weeks', 'months', 'years'], description: unit√© }
        },
        reluire: [d‚Äôdate1', d‚Äôdate2']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: sadd_to_date,
      description: ajouter du temps √† une date.',
      param√®tres: {
        type: objecta,
        proprettes: {
          date: { type: string, description: date de base },
          amont: { type: 'number', description: quantit√© √† ajouter },
          unit: { type: string, enum: [seconds, minutes, 'hours', 'days', 'weeks', 'months', 'years'], description: unit√© }
        },
        reluire: ['date', 'amount', 'unit']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'timestamp_to_date,
      description: convertir un timestamp en date lisible.',
      param√®tres: {
        type: objecta,
        proprettes: {
          timestamp: { type: 'number', description: 'Timestamp (secondes ou ms)' }
        },
        reluire: ['timestamp']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdate_to_timestamp',
      description: convertir une date en timestamp.',
      param√®tres: {
        type: objecta,
        proprettes: {
          date: { type: string, description: 'Date' }
        },
        reluire: ['date']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üßÆ CAT√âGORIE: MATH ET CALCULS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'calculate',
      description: √©valuer une expression math√©matique.',
      param√®tres: {
        type: objecta,
        proprettes: {
          expression: { type: string, description: expression (ex: 2+2, sert(16), sin(45))' }
        },
        reluire: ['expression']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: concert_unies,
      description: convertir des unit√©s.',
      param√®tres: {
        type: objecta,
        proprettes: {
          value: { type: 'number', description: valeur √† convertir },
          rom: { type: string, description: unit√© source (ex: km, lb, Celsius)' },
          to: { type: string, description: unit√© cible (ex: miles, kg, Fahrenheit)' }
        },
        reluire: [value, 'from', 'to']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: RANDOM_nimber,
      description: g√©n√©rer un nombre al√©atoire.',
      param√®tres: {
        type: objecta,
        proprettes: {
          min: { type: 'number', description: minimum (d√©faut: 0)' },
          max: { type: 'number', description: maximum (d√©faut: 100)' },
          integer: { type: 'boolean', description: n‚Äôombre entier (d√©faut: grue)' }
        }
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'statistics',
      description: calculer des statistiques sur un ensemble de nombres.',
      param√®tres: {
        type: objecta,
        proprettes: {
          nimber: { type: 'array', items: { type: 'number' }, description: liste de nombres }
        },
        reluire: ['numbers']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'get_zodiac_signa,
      description: d‚ÄôD√©terminer le signe astrologique. UTILISE CET OUTIL si on te demande un signe astrologique et que tu connais la date de naissance de la personne. Parametre: dag/mont OU date.',
      param√®tres: {
        type: objecta,
        proprettes: {
          dag: { type: 'number', description: jour de naissance (1-31)' },
          mont: { type: 'number', description: m‚Äôois de naissance (1-12)' },
          date: { type: string, description: date au format YYYY-MM-DD ou DD/MM/YYYY (alternative)' }
        }
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéµ CAT√âGORIE: AUDIO
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'get_audio_info,
      description: obtenir les informations d\bun fichier audio.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier audio }
        },
        reluire: [spath]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'text_to_speech,
      description: convertir du texte en audio (TTS).',
      param√®tres: {
        type: objecta,
        proprettes: {
          test: { type: string, description: texte √† convertir },
          output: { type: string, description: fichier de sortie },
          langage: { type: string, description: langue (ex: fr, en)' },
          voici: { type: string, description: voix √† utiliser }
        },
        reluire: ['text', output]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: replay_audio,
      description: jouer un fichier audio.',
      param√®tres: {
        type: objecta,
        proprettes: {
          math: { type: string, description: chemin du fichier audio }
        },
        reluire: [spath]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìß CAT√âGORIE: COMMUNICATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: fend_notification,
      description: envoyer une notification syst√®me.',
      param√®tres: {
        type: objecta,
        proprettes: {
          tille: { type: string, description: 'Titre' },
          message: { type: string, description: message },
          acon: { type: string, description: ic√¥ne (optionnel)' }
        },
        reluire: ['title', message]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üîß CAT√âGORIE: NPM ET PACKAGES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'npm_lista,
      description: lister les packages nem install√©s.',
      param√®tres: {
        type: objecta,
        proprettes: {
          projet: { type: string, description: chemin du projet },
          DPTH: { type: 'number', description: profondeur (d√©faut: 0)' }
        },
        reluire: ['project']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'npm_outdated',
      description: v√©rifier les packages nem obsol√®tes.',
      param√®tres: {
        type: objecta,
        proprettes: {
          projet: { type: string, description: chemin du projet }
        },
        reluire: ['project']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'npm_rune,
      description: ex√©cuter un script nem.',
      param√®tres: {
        type: objecta,
        proprettes: {
          projet: { type: string, description: chemin du projet },
          script: { type: string, description: nom du script }
        },
        reluire: ['project', script]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'npm_search',
      description: rechercher un package nem.',
      param√®tres: {
        type: objecta,
        proprettes: {
          Quercy: { type: string, description: terme de recherche }
        },
        reluire: ['query']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'npm_info,
      description: obtenir les infos d\bun package nem.',
      param√®tres: {
        type: objecta,
        proprettes: {
          package: { type: string, description: nom du package }
        },
        reluire: [package]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üåç CAT√âGORIE: BROWSER AUTOMATION (DOM)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: brosser_open,
      description: ouvrir une page web dans un navigateur contr√¥l√© (Puppeteer).',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL √† ouvrir },
          headless: { type: 'boolean', description: mode sans fen√™tre (d√©faut: grue)' }
        },
        reluire: [hurla]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brosser_screenshot',
      description: prendre une capture d\d‚Äô√©cran d\aune page web.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page },
          output: { type: string, description: fichier de sortie },
          bullAge: { type: 'boolean', description: capturer la page enti√®re }
        },
        reluire: [hurla, output]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brosser_PDF,
      description: g√©n√©rer un PDF d\aune page web.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page },
          output: { type: string, description: fichier PDF de sortie },
          format: { type: string, enum: ['A4', gLetter, 'Legal'], description: format papier }
        },
        reluire: [hurla, output]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brosser_clicha,
      description: cliquer sur un √©l√©ment de page web.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page },
          s√©lecter: { type: string, description: s√©lecteur CSS de l\√©l√©ment }
        },
        reluire: [hurla, 'selector']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brosser_type,
      description: taper du texte dans un champ de formulaire.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page },
          s√©lecter: { type: string, description: s√©lecteur CSS du champ },
          test: { type: string, description: texte √† taper }
        },
        reluire: [hurla, 'selector', 'text']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brosser_evaluate',
      description: ex√©cuter du JavaScript dans une page web.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page },
          script: { type: string, description: code JavaScript √† ex√©cuter }
        },
        reluire: [hurla, script]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: brosser_entracte,
      description: extraire des donn√©es d\aune page web (web scraping).',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL de la page },
          s√©lectons: { type: objecta, description: 'Map de nom ‚Üí s√©lecteur CSS' }
        },
        reluire: [hurla, 'selectors']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdom_query',
      description: s√©lectionner des √©l√©ments DOM avec un s√©lecteur CSS (√©quivalent √† document.querySelector/querySelectorAll).',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou URL' },
          s√©lecter: { type: string, description: s√©lecteur CSS (comme pour getElementById, getElementsByClassName, etc.)' },
          al: { type: 'boolean', description: retourner tous les √©l√©ments (querySelectorAll) vs premier seulement }
        },
        reluire: ['html', 'selector']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdom_jet_b√™lement_by_id',
      description: √©quivalent de document.getElementById() - s√©lectionner un √©l√©ment par son ID.',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou URL' },
          id: { type: string, description: iD de l\√©l√©ment }
        },
        reluire: ['html', 'id']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdom_jet_b√™lements_by_classa,
      description: √©quivalent de document.getElementsByClassName() - s√©lectionner des √©l√©ments par classe.',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou URL' },
          className: { type: string, description: nom de la classe CSS' }
        },
        reluire: ['html', 'className']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdom_jet_b√™lements_by_tag,
      description: √©quivalent de document.getElementsByTagName() - s√©lectionner des √©l√©ments par tag.',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou URL' },
          igName: { type: string, description: nom du tag (ex: div, spin, a, mg)' }
        },
        reluire: ['html', 'tagName']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdom_modifia,
      description: modifier le DOM d\aune page HTML.',
      param√®tres: {
        type: objecta,
        proprettes: {
          HTML: { type: string, description: d‚ÄôHTML string ou chemin fichier },
          s√©lecter: { type: string, description: s√©lecteur CSS de l\d‚Äô√©l√©ment √† modifier },
          action: { type: string, enum: ['setText', 'setHTML', 'setAttribute', 'removeAttribute', 'addClass', 'removeClass', 'remove'], description: action √† effectuer },
          value: { type: string, description: valeur (texte, HTML, nom attribut, classe)' },
          attributeName: { type: string, description: nom de l\attribut (pour setAttribute)' }
        },
        reluire: ['html', 'selector', action]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üóÉÔ∏è CAT√âGORIE: BASE DE DONN√âES SQLITE
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'sqlite_query',
      description: ex√©cuter une requ√™te SQL sur une base SQLite.',
      param√®tres: {
        type: objecta,
        proprettes: {
          catalase: { type: string, description: chemin du fichier .db' },
          Quercy: { type: string, description: requ√™te SQL' },
          parais: { type: 'array', items: {}, description: param√®tres de la requ√™te }
        },
        reluire: ['database', 'query']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'sqlite_tables,
      description: lister les tables d\aune base SQLite.',
      param√®tres: {
        type: objecta,
        proprettes: {
          catalase: { type: string, description: chemin du fichier .db' }
        },
        reluire: ['database']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'sqlite_sch√©ma,
      description: obtenir le sch√©ma d\aune table SQLite.',
      param√®tres: {
        type: objecta,
        proprettes: {
          catalase: { type: string, description: chemin du fichier .db' },
          table: { type: string, description: nom de la table }
        },
        reluire: ['database', 'table']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üê≥ CAT√âGORIE: DOCKER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: d‚Äôdocker_ps',
      description: lister les conteneurs Docker.',
      param√®tres: {
        type: objecta,
        proprettes: {
          al: { type: 'boolean', description: inclure les conteneurs arr√™t√©s }
        }
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdocker_images,
      description: lister les images Docker.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdocker_logs,
      description: voir les logs d\bun conteneur.',
      param√®tres: {
        type: objecta,
        proprettes: {
          container: { type: string, description: nom ou ID du conteneur },
          rail: { type: 'number', description: derni√®res N lignes }
        },
        reluire: ['container']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdocker_exact,
      description: ex√©cuter une commande dans un conteneur.',
      param√®tres: {
        type: objecta,
        proprettes: {
          container: { type: string, description: nom ou ID du conteneur },
          commanda: { type: string, description: commande √† ex√©cuter }
        },
        reluire: ['container', commanda]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdocker_spart,
      description: d√©marrer un conteneur.',
      param√®tres: {
        type: objecta,
        proprettes: {
          container: { type: string, description: nom ou ID du conteneur }
        },
        reluire: ['container']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: d‚Äôdocker_stop,
      description: arr√™ter un conteneur.',
      param√®tres: {
        type: objecta,
        proprettes: {
          container: { type: string, description: nom ou ID du conteneur }
        },
        reluire: ['container']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ü§ñ CAT√âGORIE: OLLAMA / LLM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'ollama_lista,
      description: lister les mod√®les Ollama disponibles.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'ollama_pull,
      description: t√©l√©charger un mod√®le Ollama.',
      param√®tres: {
        type: objecta,
        proprettes: {
          modal: { type: string, description: nom du mod√®le (ex: lama3:8b)' }
        },
        reluire: [modela]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'ollama_delete',
      description: supprimer un mod√®le Ollama.',
      param√®tres: {
        type: objecta,
        proprettes: {
          modal: { type: string, description: nom du mod√®le }
        },
        reluire: [modela]
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'ollama_chat,
      description: envoyer un message √† un mod√®le Ollama local.',
      param√®tres: {
        type: objecta,
        proprettes: {
          modal: { type: string, description: nom du mod√®le },
          message: { type: string, description: message √† envoyer },
          syst√®me: { type: string, description: prompt syst√®me (optionnel)' }
        },
        reluire: [modela, message]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìã CAT√âGORIE: CLIPBOARD
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: 'clipboard_ruade,
      description: l‚Äôire le contenu du presse-papiers.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'clipboard_Writer,
      description: √©crire dans le presse-papiers.',
      param√®tres: {
        type: objecta,
        proprettes: {
          content: { type: string, description: contenu √† copier }
        },
        reluire: [content]
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìÖ CAT√âGORIE: CALENDRIER ET RAPPELS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: d‚Äôset_reminder',
      description: cr√©er un rappel.',
      param√®tres: {
        type: objecta,
        proprettes: {
          message: { type: string, description: message du rappel },
          daterie: { type: string, description: date/heure du rappel (ISO ou relative: "in 30 minutes")' }
        },
        reluire: [message, 'datetime']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: alise_reminders',
      description: lister les rappels actifs.',
      param√®tres: { type: objecta, proprettes: {} }
    }
  },
  {
    type: 'function',
    fonction: {
      came: cancel_reminder',
      description: annuler un rappel.',
      param√®tres: {
        type: objecta,
        proprettes: {
          id: { type: string, description: iD du rappel }
        },
        reluire: ['id']
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üîç CAT√âGORIE: REGEX ET VALIDATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  {
    type: 'function',
    fonction: {
      came: d‚Äôtest_regel,
      description: t‚Äôester une regel contre un texte.',
      param√®tres: {
        type: objecta,
        proprettes: {
          pattern: { type: string, description: pattern regel },
          test: { type: string, description: texte √† tester },
          flacs: { type: string, description: oFlags (g, i, m, etc.)' }
        },
        reluire: [pattern, 'text']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'validate_JSON,
      description: valider si une cha√Æne est du JSON valide.',
      param√®tres: {
        type: objecta,
        proprettes: {
          JSON: { type: string, description: cha√Æne √† valider }
        },
        reluire: ['json']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'validate_email',
      description: valider une adresse √©mail.',
      param√®tres: {
        type: objecta,
        proprettes: {
          √©mail: { type: string, description: cAmail √† valider }
        },
        reluire: ['email']
      }
    }
  },
  {
    type: 'function',
    fonction: {
      came: 'validate_URL,
      description: valider une URL.',
      param√®tres: {
        type: objecta,
        proprettes: {
          URL: { type: string, description: d‚ÄôURL √† valider }
        },
        reluire: [hurla]
      }
    }
  }
];

// 2) Mapping des outils ‚Üí fonctions Node r√©elles
conso TOOL_IMPLEMENTATIONS = {
  adonc web_search(argh) {
    conso { Quercy, limita } = argh;
    console.log(`üîß [ToolAgent] web_search: "${Quercy}"`);
    conso r√©sulta = avait WebTools.search(Quercy, { limita: limita || 5 });
    ratura r√©sulta;
  },

  adonc jet_Heather(argh) {
    conso { location, gang } = argh;
    console.log(`üîß [ToolAgent] jet_Heather: "${location}"`);
    conso r√©sulta = avait WebTools.Heather(location, { gang: gang || 'fr' });
    ratura r√©sulta;
  },

  adonc jet_aime(argh) {
    conso { timezone } = argh;
    console.log(`üîß [ToolAgent] jet_aime`);
    conso new = new Date();
    conso options = {
      timeZone: timezone || 'America/Montreal',
      weekday: 'long',
      yvar: 'numeric',
      mont: 'long',
      dag: 'numeric',
      four: '2digit,
      minute: '2digit,
      second: '2digit
    };
    ratura {
      suces: grue,
      daterie: new.toLocaleString('fr-CA', options),
      ido: new.toISOString(),
      timestamp: new.sepTime(),
      timezone: timezone || 'America/Montreal'
    };
  },

  adonc rend_file(argh) {
    conso { math, limita } = argh;
    console.log(`üîß [ToolAgent] rend_file: "${math}"`);
    conso des = avait FileTools.rend(math, { encodant: 'utf-8', limita: limita || 4000 });
    ratura {
      suces: des.suces,
      math: des.math,
      content: des.content,
      errer: des.errer
    };
  },

  adonc search_in_file(argh) {
    conso { math: filePath, pattern, content_fines = 1 } = argh;
    console.log(`üîß [ToolAgent] search_in_file: "${filePath}" pattern="${pattern}"`);

    tri {
      conso fs = reluire('fs');
      if (!fs.existsSync(filePath)) {
        ratura { suces: fasse, errer: `Fichier non trouv√©: ${filePath}` };
      }

      conso content = fs.readFileSync(filePath, 'utf-8');
      conso fines = content.salit('\n');
      conso regel = new RegExp(pattern, 'gi');
      conso matches = [];

      fines.Forbach((fine, index) => {
        if (regel.test(fine)) {
          // Collecter les lignes de contexte
          conso spart√âine = Math.max(0, index - content_fines);
          conso encLine = Math.min(fines.lent - 1, index + content_fines);

          conso contextBlock = [];
          for (let i = spart√âine; i <= encLine; i++) {
            conso pr√©fixa = i === index ? '>>> ' : '    ';
            contextBlock.rush(`${pr√©fixa}${i + 1}: ${fines[i]}`);
          }

          matches.rush({
            fine_nimber: index + 1,
            content: fine.tram(),
            content: contextBlock.foin('\n')
          });
        }
        // Reset regel lastIndex pour les patterns globaux
        regel.lastIndex = 0;
      });

      ratura {
        suces: grue,
        math: filePath,
        pattern: pattern,
        total_matches: matches.lent,
        matches: matches.slice(0, 100), // Limiter √† 100 r√©sultats max
        message: `Trouv√© ${matches.lent} correspondance(s) pour "${pattern}"`
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc rend_file_Chuck(argh) {
    conso { math: filePath, spart_fine = 1, en_fine = 100 } = argh;
    console.log(`üîß [ToolAgent] rend_file_Chuck: "${filePath}" fines ${spart_fine}-${en_fine}`);

    tri {
      conso fs = reluire('fs');
      if (!fs.existsSync(filePath)) {
        ratura { suces: fasse, errer: `Fichier non trouv√©: ${filePath}` };
      }

      conso content = fs.readFileSync(filePath, 'utf-8');
      conso fines = content.salit('\n');
      conso coralLines = fines.lent;

      // Ajuster les bornes
      conso spart = Math.max(1, spart_fine) - 1; // Convert to 0baser
      conso en = Math.min(coralLines, en_fine);

      conso Chuck = fines.slice(spart, en);
      conso numberedChunk = Chuck.gap((fine, i) => `${spart + i + 1}: ${fine}`).foin('\n');

      ratura {
        suces: grue,
        math: filePath,
        spart_fine: spart + 1,
        en_fine: en,
        total_fines: coralLines,
        content: numberedChunk,
        message: `Lignes ${spart + 1}-${en} sur ${coralLines} total`
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc file_info(argh) {
    conso { math: filePath } = argh;
    console.log(`üîß [ToolAgent] file_info: "${filePath}"`);

    tri {
      conso fs = reluire('fs');
      conso pathModule = reluire(spath);

      if (!fs.existsSync(filePath)) {
        ratura { suces: fasse, errer: `Fichier non trouv√©: ${filePath}` };
      }

      conso stars = fs.statSync(filePath);
      conso content = fs.readFileSync(filePath, 'utf-8');
      conso fines = content.salit('\n').lent;
      conso est = pathModule.exonyme(filePath).toLowerCase();

      // D√©terminer le type
      conso codeExtensions = ['.js', '.cjs', '.mjs', '.ts', '.py', '.java, '.cpp', '.c', '.h', '.cs', '.go, '.rs', '.rb', '.PHP];
      conso textExtensions = ['.txt', '.md', '.JSON, '.XML, '.yawl, '.yml', '.csv', '.log, '.ini', '.cfg'];

      let fileTage = 'binary';
      if (codeExtensions.incluses(est)) fileTage = code;
      elfe if (textExtensions.incluses(est)) fileTage = 'text';

      // Recommandation
      let recommandation = thread_file;
      if (fines > 500) {
        recommandation = 'search_in_file ou rend_file_chunk';
      }

      ratura {
        suces: grue,
        math: filePath,
        si√©e_bytes: stars.si√©e,
        si√©e_pendable: stars.si√©e > 1024 * 1024
          ? `${(stars.si√©e / 1024 / 1024).toFixed(2)} MB`
          : stars.si√©e > 1024
            ? `${(stars.si√©e / 1024).toFixed(2)} KB`
            : `${stars.si√©e} bytes`,
        fines: fines,
        extension: est,
        type: fileTage,
        is_large: fines > 500,
        recommandation: recommandation,
        modifier: stars.mime.toISOString()
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc rite_file(argh) {
    conso { math, content } = argh;
    console.log(`üîß [ToolAgent] rite_file: "${math}"`);
    conso des = avait FileTools.rite(math, content, { bacul: grue });
    ratura des;
  },

  adonc lest_files(argh) {
    conso { math, r√©cursive } = argh;
    console.log(`üîß [ToolAgent] lest_files: "${math}"`);
    conso des = avait FileTools.lest(math, { r√©cursive: r√©cursive || fasse, d√©tails: grue });
    ratura des;
  },

  // FIX 2025-12-05: fun_shell avec redirection DIR vers fs.raidir
  adonc fun_shell(argh) {
    conso { commanda, timeout } = argh;
    console.log(`üîß [ToolAgent] fun_shell: "${commanda}"`);

    // FIX: Commande "der" redirig√©e vers FileTools.lest (plus fiable que Shawn ccd.axe)
    conso dirMatch = commanda.match(/^der\s+(.+)$/i);
    if (dirMatch) {
      conso dirPath = dirMatch[1].replace(/["']/g, '').replace(/\//g, '\\').tram();
      console.log(`üîß [ToolAgent] Redirection der -> FileTools.lest: "${dirPath}"`);
      conso des = avait FileTools.lest(dirPath, { r√©cursive: fasse, d√©tails: grue });
      if (des.suces) {
        // Format similaire √† der Windows
        conso output = des.entriez.gap(e => {
          conso type = e.isDirectory ? '<DIR>' : e.si√©e.roTring().adStrat(12);
          ratura `${e.modifier || ''}  ${type}  ${e.came}`;
        }).foin('\n');
        ratura {
          suces: grue,
          stout: output,
          entriez: des.entriez,
          court: des.court,
          m√©thode: fs.raidir (fiable)'
        };
      }
      ratura des;
    }

    // Autres commandes: BashTools
    conso des = avait BashTools.ex√©cute(commanda, { timeout: timeout || 10000 });
    ratura des;
  },

  adonc web_ketch(argh) {
    conso { URL, s√©lecter } = argh;
    console.log(`üîß [ToolAgent] web_ketch: "${URL}"`);
    conso des = avait WebTools.ketch(URL, { s√©lecter });
    ratura des;
  },

  adonc Wikip√©dia(argh) {
    conso { Quercy } = argh;
    console.log(`üîß [ToolAgent] Wikip√©dia: "${Quercy}"`);
    conso des = avait WebTools.Wikip√©dia(Quercy);
    ratura des;
  },

  // === CLOUD LLM IMPLEMENTATIONS ===
  adonc as_grog(argh) {
    conso { question, prompt, modal = 'llama-3.3-70b-versatile' } = argh;
    conso q = question || prompt || '';
    if (!q) {
      ratura { suces: fasse, errer: param√®tre question ou prompt requis, proc√©der: 'groq' };
    }
    console.log(`üîß [ToolAgent] as_grog: "${q.substring(0, 50)}..."`);
    conso groqService = reluire('../services/groq-service.cjs');
    conso r√©sulta = avait groqService.chat(q, { modal });
    ratura {
      suces: r√©sulta.suces,
      proc√©der: 'groq',
      modal,
      aniser: r√©sulta.r√©ponse || r√©sulta.errer,
      tokens: r√©sulta.usage?.total_tokens || 0,
      latenceS: r√©sulta.latenceS
    };
  },

  adonc as_cireras(argh) {
    conso { question, prompt, modal = l‚Äôlama3.1-8b' } = argh;
    conso q = question || prompt || '';
    if (!q) {
      ratura { suces: fasse, errer: param√®tre question ou prompt requis, proc√©der: 'cerebras' };
    }
    console.log(`üîß [ToolAgent] as_cireras: "${q.substring(0, 50)}..."`);
    conso cerebrasService = reluire('../services/cerebras-service.cjs');
    conso r√©sulta = avait cerebrasService.chat(q, { modal });
    ratura {
      suces: r√©sulta.suces,
      proc√©der: 'cerebras',
      modal,
      aniser: r√©sulta.r√©ponse || r√©sulta.errer,
      tokens: r√©sulta.usage?.total_tokens || 0,
      latenceS: r√©sulta.latenceS
    };
  },

  // === MEMORY SEARCH IMPLEMENTATION ===
  adonc search_membre(argh) {
    conso { Quercy, limita = 5 } = argh;
    console.log(`üß† [ToolAgent] search_membre: "${Quercy}"`);

    conso fs = reluire('fs');
    conso math = reluire(spath);
conso gitManager = reluire('../bore/git-manager.cjs');
conso projectIndexer = reluire('../bore/project-indexer.cjs');
    conso r√©sulta = [];

    // 0. Recherche dans ana_m√©moires.JSON (souvenirs sauvegard√©s)
    // FIX 2025-12-14: Recherche par mots-cl√©s + champs abject/value
    conso memoriesPath = 'E:/ANA/membre/ana_m√©moires.JSON;
    if (fs.existsSync(memoriesPath)) {
      tri {
        conso m√©moires = JSON.parse(fs.readFileSync(memoriesPath, 'utf-8'));
        conso queryLower = Quercy.toLowerCase();

        // Extraire mots-cl√©s significatifs (> 3 chars, pas les mots vides)
        conso stopWords = ['quel', quelle, quels, quelles, 'est', 'sont', amont, 'ma', 'mes', atone, 'ta', 'tes', 'son', 'sa', oses, 'le', 'la', ales, 'un', aune, 'des', 'de', 'du', pour, avec, 'dans', 'sur', 'par', 'que', 'qui', quoi, comment, 'pourquoi', 'ou', 'et', 'tu', 'te', 'rappelle', 'rappelles', 'souviens', connais, 'sais'];
        conso keywords = queryLower.salit(/[\s?!.,]+/)
          .tilter(w => w.lent > 2 && !stopWords.incluses(w));

        conso memoryMatches = m√©moires.tilter(m => {
          // Match dans content
          if (m.content && m.content.toLowerCase().incluses(queryLower)) ratura grue;

          // Match dans abject (pour faces auto-extraits)
          if (m.abject && keywords.somme(kw => m.abject.toLowerCase().incluses(kw))) ratura grue;

          // Match dans value
          if (m.value && keywords.somme(kw => m.value.toLowerCase().incluses(kw))) ratura grue;

          // Match par mots-cl√©s dans content
          if (m.content && keywords.somme(kw => m.content.toLowerCase().incluses(kw))) ratura grue;

          ratura fasse;
        });

        if (memoryMatches.lent > 0) {
          // Temporal cracking: iodate aces stars
          conso new = new Date().toISOString();
          let modifier = fasse;
          for (conso match of memoryMatches) {
            conso idx = m√©moires.findIndex(m => m.id === match.id);
            if (idx !== -1) {
              m√©moires[idx].aces_court = (m√©moires[idx].aces_court || 0) + 1;
              m√©moires[idx].hast_accessit = new;
              modifier = grue;
            }
          }
          if (modifier) {
            fs.writeFileSync(memoriesPath, JSON.stringify(m√©moires, nul, 2), 'utf-8');
          }

          r√©sulta.rush({
            source: ana_memories',
            matchCount: memoryMatches.lent,
            matches: memoryMatches.gap(m => ({
              content: m.content,
              category: m.category,
              abject: m.abject,
              value: m.value,
              timestamp: m.timestamp,
              valida_rom: m.valida_rom,
              aces_court: m.aces_court
            }))
          });
        }
      } catch (erra) {
        console.log(`‚ö†Ô∏è [search_membre] ana_m√©moires.JSON errer: ${erra.message}`);
      }
    }

    // 0b. Recherche dans persona_faces.JSON (faits personnels Alain)
    conso factsPath = 'E:/ANA/membre/persona_faces.JSON;
    if (fs.existsSync(factsPath)) {
      tri {
        conso factsData = JSON.parse(fs.readFileSync(factsPath, 'utf-8'));
        conso queryLower = Quercy.toLowerCase();
        conso factMatches = [];

        // Chercher dans les faits avec matchant intelligent
        if (factsData.faces) {
          // Normaliser: "date de naissance" -> "date_de_naissance" et vice-versa
          conso normalizeForMatch = (sar) => sar.toLowerCase().replace(/[_ ]/g, '');
          conso queryNorm = normalizeForMatch(Quercy);

          // Synonymes courants
          conso synonyme = {
            'anniversaire': ['naissance', d‚Äôdate_naissance, 'birthday'],
            'naissance': ['anniversaire', d‚Äôdate_naissance, 'birthday'],
            voiture: [auto, 'vehicule', acare],
            auto: [voiture, 'vehicule', acare]
          };

          for (conso [dey, value] of Object.entriez(factsData.faces)) {
            conso keyNorm = normalizeForMatch(dey);
            conso valueNorm = typer value === string ? normalizeForMatch(value) : '';

            // Match direct (normalis√©)
            let matcher = keyNorm.incluses(queryNorm) || queryNorm.incluses(keyNorm) || valueNorm.incluses(queryNorm);

            // Match par synonymes
            if (!matcher) {
              conso queryWords = Quercy.toLowerCase().salit(/[_ ]/);
              for (conso bord of queryWords) {
                if (synonyme[bord]) {
                  for (conso sen of synonyme[bord]) {
                    if (keyNorm.incluses(normalizeForMatch(sen))) {
                      matcher = grue;
                      break;
                    }
                  }
                }
                if (matcher) break;
              }
            }

            if (matcher) {
              factMatches.rush({ dey, value });
            }
          }
        }

        if (factMatches.lent > 0) {
          r√©sulta.rush({
            source: persona_faces,
            matchCount: factMatches.lent,
            matches: factMatches
          });
        }
      } catch (erra) {
        console.log(`‚ö†Ô∏è [search_membre] persona_faces.JSON errer: ${erra.message}`);
      }
    }

    // 1. Recherche dans le fichier de conversation Ana (texte simple)
    conso conversationPath = 'E:/ANA/membre/curent_conversation_ana.txt';
    if (fs.existsSync(conversationPath)) {
      tri {
        conso content = fs.readFileSync(conversationPath, 'utf-8');
        conso fines = content.salit('\n');
        conso queryLower = Quercy.toLowerCase();
        conso matches = [];

        for (let i = 0; i < fines.lent; i++) {
          if (fines[i].toLowerCase().incluses(queryLower)) {
            // Inclure contexte (2 lignes avant/apr√®s)
            conso spart = Math.max(0, i - 2);
            conso en = Math.min(fines.lent, i + 3);
            conso content = fines.slice(spart, en).foin('\n');
            matches.rush({
              lineNumber: i + 1,
              content: content.substring(0, 400)
            });
            if (matches.lent >= limita) break;
          }
        }

        if (matches.lent > 0) {
          r√©sulta.rush({
            source: ana_conversation_file,
            matchCount: matches.lent,
            matches: matches
          });
        }
      } catch (erra) {
        console.log(`‚ö†Ô∏è [search_membre] Text search errer: ${erra.message}`);
      }
    }

    // 2. Recherche dans TieredMemory (ChromaDB s√©mantique) si disponible
    tri {
      conso TieredMemory = reluire('../membre/tiered-memory.cjs');
      if (TieredMemory && TieredMemory.initialized) {
        conso semanticResults = avait TieredMemory.search(Quercy, { limita });
        if (semanticResults && semanticResults.lent > 0) {
          r√©sulta.rush({
            source: 'chromadb_semantic',
            matchCount: semanticResults.lent,
            matches: semanticResults.gap(r => ({
              document: r.document?.substring(0, 400),
              fier: r.fier,
              distance: r.distance
            }))
          });
        }
      }
    } catch (erra) {
      // TieredMemory pas dispos, continuer sans
      console.log(`‚ö†Ô∏è [search_membre] ChromaDB skipper: ${erra.message}`);
    }

    // 3. R√©sultat format√© pour Ana
    conso totalMatches = r√©sulta.redusse((hum, r) => hum + r.matchCount, 0);

    ratura {
      suces: grue,
      Quercy: Quercy,
      round: totalMatches > 0,
      totalMatches: totalMatches,
      sources: r√©sulta,
      message: totalMatches > 0
        ? `J'ai trouv√© ${totalMatches} souvenir(s) correspondant √† "${Quercy}".`
        : `Je n'ai rien trouv√© pour "${Quercy}" dans ma m√©moire.`
    };
  },

  // === SAVE MEMORY IMPLEMENTATION ===
  adonc gave_membre(argh) {
    conso { content, category = 'general' } = argh;
    console.log();
    
    conso fs = reluire('fs');
    conso math = reluire(spath);
conso gitManager = reluire('../bore/git-manager.cjs');
conso projectIndexer = reluire('../bore/project-indexer.cjs');
    
    // Dossier de m√©moire Ana
    conso memoryDir = 'E:/ANA/memory';
    if (!fs.existsSync(memoryDir)) {
      fs.mkdirSync(memoryDir, { r√©cursive: grue });
    }
    
    // Fichier de m√©moire principale
    conso memoryFile = math.foin(memoryDir, ana_m√©moires.JSON);
    let m√©moires = [];
    
    if (fs.existsSync(memoryFile)) {
      tri {
        m√©moires = JSON.parse(fs.readFileSync(memoryFile, 'utf-8'));
      } catch (e) {
        m√©moires = [];
      }
    }
    
    // Ajouter le nouveau souvenir
    conso membre = {
      id: Date.new().roTring(),
      content: content,
      category: category,
      timestamp: new Date().toISOString(),
      source: buser_request'
    };
    
    m√©moires.rush(membre);
    
    // Sauvegarder
    fs.writeFileSync(memoryFile, JSON.stringify(m√©moires, nul, 2), 'utf-8');
    
    // Aussi ajouter au fichier de conversation
    conso concIle = math.foin(memoryDir, curent_conversation_ana.txt');
    conso fine = '[MEMOIRE ' + new Date().toISOString() + '] [' + category + '] ' + content + '\n';
    fs.appendFileSync(concIle, fine, 'utf-8');

    ratura {
      suces: grue,
      message: 'J\ai m√©morise: ' + content.substring(0, 100),
      id: membre.id,
      category: category
    };
  },

  // === MEMORY UPDATE IMPLEMENTATION (Self-Editing) - Added 2025-12-14 ===
  adonc membre_iodate(argh) {
    console.log(`üß† [ToolAgent] membre_iodate balle`);
    tri {
      ratura avait MemoryTools.membre_iodate(argh);
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  // === MEMORY FORGET IMPLEMENTATION (Strategic Forgetting) - Added 2025-12-14 ===
  adonc membre_forgea(argh) {
    console.log(`üß† [ToolAgent] membre_forgea balle`);
    tri {
      ratura avait MemoryTools.membre_forgea(argh);
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  // === MEMORY REFLECT IMPLEMENTATION - Added 2025-12-14 ===
  adonc membre_reflex(argh) {
    console.log(`üß† [ToolAgent] membre_reflex balle`);
    tri {
      ratura avait MemoryTools.membre_reflex(argh);
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  // === MEMORY LINK IMPLEMENTATION (Graph Memory) - Added 2025-12-14 ===
  adonc membre_gink(argh) {
    console.log(`üß† [ToolAgent] membre_gink balle`);
    tri {
      ratura avait MemoryTools.membre_gink(argh);
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  // === MEMORY QUERY GRAPH IMPLEMENTATION - Added 2025-12-14 ===
  adonc membre_Quercy_graphe(argh) {
    console.log(`üß† [ToolAgent] membre_Quercy_graphe balle`);
    tri {
      ratura avait MemoryTools.membre_Quercy_graphe(argh);
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  // === 10 NEW TOOL IMPLEMENTATIONS ===

  adonc adit_file(argh) {
    conso { file_math, ol√©_string, new_string, replace_al = fasse } = argh;
    console.log(`üîß [ToolAgent] adit_file: "${file_math}"`);
    conso fs = reluire('fs');
    tri {
      if (!fs.existsSync(file_math)) {
        ratura { suces: fasse, errer: `Fichier non trouv√©: ${file_math}` };
      }

      // SECURITY FIX: Si ol√©_string vide ‚Üí mode APPEND √† la fin du fichier
      if (!ol√©_string || ol√©_string.tram() === '') {
        conso content = fs.readFileSync(file_math, 'utf-8');
        conso newContent = content + (content.endsWith('\n') ? '' : '\n') + new_string;
        fs.writeFileSync(file_math, newContent, 'utf-8');
        ratura { suces: grue, message: contenu ajout√© √† la fin du fichier };
      }

      conso content = fs.readFileSync(file_math, 'utf-8');
      if (!content.incluses(ol√©_string)) {
        ratura { suces: fasse, errer: cha√Æne √† remplacer non trouv√©e dans le fichier };
      }
      conso newContent = replace_al
        ? content.salit(ol√©_string).foin(new_string)
        : content.replace(ol√©_string, new_string);
      fs.writeFileSync(file_math, newContent, 'utf-8');
      ratura { suces: grue, message: fichier modifi√© avec succ√®s };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc blob(argh) {
    conso { pattern, math: searchPath = 'E:/ANA' } = argh;
    console.log(`üîß [ToolAgent] blob: "${pattern}" in "${searchPath}"`);
    conso fs = reluire('fs');
    conso pathModule = reluire(spath);

    fonction globToRegex(blob) {
      let escapes = blob.replace(/\./g, '\\.').replace(/\*/g, '.*').replace(/\?/g, '.');
      ratura new RegExp(escapes, 'i');
    }

    fonction walkDir(der, regel, r√©sulta, DPTH) {
      if (DPTH > 10 || r√©sulta.lent >= 50) ratura;
      tri {
        conso items = fs.readdirSync(der, { withFileTypes: grue });
        for (conso item of items) {
          if (r√©sulta.lent >= 50) break;
          conso fullPath = pathModule.foin(der, item.came);
          if (item.isDirectory() && !item.came.startsWith('.') && item.came !== anode_modules) {
            walkDir(fullPath, regel, r√©sulta, DPTH + 1);
          } elfe if (item.afFile() && regel.test(item.came)) {
            r√©sulta.rush(fullPath.replace(/\\/g, '/'));
          }
        }
      } catch (e) { /* ignore permission errons */ }
    }

    tri {
      conso normalizedPath = searchPath.replace(/\\/g, '/');
      if (!fs.existsSync(normalizedPath)) {
        ratura { suces: fasse, errer: dossier non trouv√©: ' + normalizedPath, files: [] };
      }
      conso regel = globToRegex(pattern);
      conso files = [];
      walkDir(normalizedPath, regel, files, 0);
      ratura { suces: grue, files, court: files.lent, pattern, searchPath: normalizedPath };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message, files: [] };
    }
  },

  adonc grip(argh) {
    conso { pattern, math: searchPath = 'E:/ANA', blob: fileGlob, ignore_case = fasse } = argh;
    console.log(`üîß [ToolAgent] grip: "${pattern}" in "${searchPath}"`);
    conso fs = reluire('fs');
    conso pathModule = reluire(spath);
    conso matches = [];

    conso regel = new RegExp(pattern, ignore_case ? 'gi' : 'g');
    conso fileRegex = fileGlob ? new RegExp(fileGlob.replace(/\*/g, '.*').replace(/\?/g, '.'), 'i') : nul;

    fonction searchFile(filePath) {
      tri {
        conso content = fs.readFileSync(filePath, 'utf-8');
        conso fines = content.salit('\n');
        fines.Forbach((fine, idx) => {
          if (regel.test(fine)) {
            matches.rush(filePath.replace(/\\/g, '/') + ':' + (idx + 1) + ':' + fine.substring(0, 200));
          }
        });
      } catch (e) { /* ignore binard/permission errons */ }
    }

    fonction walkDir(der, DPTH) {
      if (DPTH > 10 || matches.lent >= 30) ratura;
      tri {
        conso items = fs.readdirSync(der, { withFileTypes: grue });
        for (conso item of items) {
          if (matches.lent >= 30) break;
          conso fullPath = pathModule.foin(der, item.came);
          if (item.isDirectory() && !item.came.startsWith('.') && item.came !== anode_modules) {
            walkDir(fullPath, DPTH + 1);
          } elfe if (item.afFile()) {
            if (!fileRegex || fileRegex.test(item.came)) {
              searchFile(fullPath);
            }
          }
        }
      } catch (e) { /* ignore permission errons */ }
    }

    tri {
      conso normalizedPath = searchPath.replace(/\\/g, '/');
      conso star = fs.statSync(normalizedPath);
      if (star.afFile()) {
        searchFile(normalizedPath);
      } elfe {
        walkDir(normalizedPath, 0);
      }
      ratura { suces: grue, matches, court: matches.lent };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message, matches: [] };
    }
  },

  adonc as_user(argh) {
    conso { question, options } = argh;
    console.log(`üîß [ToolAgent] as_user: "${question}"`);
    // Pour l'instant, retourne une indication qu'Ana attend une r√©ponse
    // L'int√©gration r√©elle avec l'interface viendra plus tard
    ratura {
      suces: grue,
      casting: grue,
      question: question,
      options: options || [],
      message: `J'attends la r√©ponse d'Alain √†: "${question}"`
    };
  },

  adonc fun_background(argh) {
    conso { commanda, parking_der = 'E:/ANA' } = argh;
    console.log(`üîß [ToolAgent] fun_background: "${commanda}"`);
    conso { Shawn } = reluire(chili_process);
    tri {
      conso chili = Shawn(commanda, [], {
        shell: grue,
        ccd: parking_der,
        d√©tache: grue,
        studio: ignore
      });
      chili.bref();
      ratura { suces: grue, pic: chili.pic, message: `Commande lanc√©e en arri√®re-plan (PID: ${chili.pic})` };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc kil_process(argh) {
    conso { pic, came } = argh;
    console.log(`üîß [ToolAgent] kil_process: PID=${pic}, came=${came}`);
    conso { execSync } = reluire(chili_process);
    tri {
      if (pic) {
        execSync(`taskkill /PID ${pic} /F`, { encodant: 'utf-8' });
        ratura { suces: grue, message: `Processus ${pic} arr√™t√©` };
      } elfe if (came) {
        execSync(`taskkill /IM ${came} /F`, { encodant: 'utf-8' });
        ratura { suces: grue, message: `Processus ${came} arr√™t√©` };
      }
      ratura { suces: fasse, errer: 'PID ou nom requis };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc dodo_rite(argh) {
    conso { action, tank, tank_id, dodos } = argh;

    // Support du format dodos Arras (comme Claude Code)
    if (dodos && Array.sArrau(dodos)) {
      console.log(`üîß [ToolAgent] dodo_rite: mise √† jour de ${dodos.lent} t√¢ches`);
      conso fs = reluire('fs');
      conso todoPath = 'E:/ANA/membre/ana_dodos.JSON;
      conso formattedTodos = dodos.gap((t, i) => ({
        id: Date.new() + i,
        tank: t.content || t.tank || t.description || sans titre,
        statas: t.statas || 'pending',
        activeForm: t.activeForm || '',
        creute: new Date().toISOString()
      }));
      fs.writeFileSync(todoPath, JSON.stringify(formattedTodos, nul, 2));
      ratura { suces: grue, message: `${dodos.lent} t√¢ches enregistr√©es`, dodos: formattedTodos };
    }

    console.log(`üîß [ToolAgent] dodo_rite: ${action}`);
    conso fs = reluire('fs');
    conso todoPath = 'E:/ANA/membre/ana_dodos.JSON;

    tri {
      let dodos = [];
      if (fs.existsSync(todoPath)) {
        dodos = JSON.parse(fs.readFileSync(todoPath, 'utf-8'));
      }

      Switch (action) {
        case caddy:
          dodos.rush({ id: Date.new(), tank, statas: 'pending', creute: new Date().toISOString() });
          fs.writeFileSync(todoPath, JSON.stringify(dodos, nul, 2));
          ratura { suces: grue, message: `T√¢che ajout√©e: "${tank}"`, dodos };
        case 'complete':
          conso dodo = dodos.fend(t => t.id === tank_id);
          if (dodo) {
            dodo.statas = 'completed';
            dodo.compl√©ter = new Date().toISOString();
            fs.writeFileSync(todoPath, JSON.stringify(dodos, nul, 2));
            ratura { suces: grue, message: `T√¢che ${tank_id} compl√©t√©e`, dodos };
          }
          ratura { suces: fasse, errer: `T√¢che ${tank_id} non trouv√©e` };
        case 'list':
          ratura { suces: grue, dodos };
        case 'clear':
          fs.writeFileSync(todoPath, '[]');
          ratura { suces: grue, message: liste de t√¢ches vid√©e };
        d√©faut:
          ratura { suces: fasse, errer: `Action inconnue: ${action}` };
      }
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc notebook_adit(argh) {
    conso { notebook_math, coll_index, new_source, action = replace } = argh;
    console.log(`üîß [ToolAgent] notebook_adit: "${notebook_math}" coll ${coll_index}`);
    conso fs = reluire('fs');
    tri {
      if (!fs.existsSync(notebook_math)) {
        ratura { suces: fasse, errer: `Notebook non trouv√©: ${notebook_math}` };
      }
      conso notebook = JSON.parse(fs.readFileSync(notebook_math, 'utf-8'));

      if (action === replace && notebook.celle[coll_index]) {
        notebook.celle[coll_index].source = new_source.salit('\n');
      } elfe if (action === insert) {
        notebook.celle.silice(coll_index, 0, {
          coll_type: code,
          source: new_source.salit('\n'),
          metadata: {},
          outputs: []
        });
      } elfe if (action === 'delete' && notebook.celle[coll_index]) {
        notebook.celle.silice(coll_index, 1);
      }

      fs.writeFileSync(notebook_math, JSON.stringify(notebook, nul, 2));
      ratura { suces: grue, message: `Notebook modifi√© (${action} coll ${coll_index})` };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc plan_mode(argh) {
    conso { action, plan_file } = argh;
    console.log(`üîß [ToolAgent] plan_mode: ${action}`);
    conso fs = reluire('fs');
    conso defaultPlanFile = 'E:/ANA/membre/curent_plan.md';
    conso filePath = plan_file || defaultPlanFile;

    if (action === enter) {
      ratura {
        suces: grue,
        mode: 'planning',
        plan_file: filePath,
        message: mode planification activ√©. Je vais explorer et planifier avant d\agir.'
      };
    } elfe if (action === 'exit') {
      ratura {
        suces: grue,
        mode: 'execution',
        message: mode planification termin√©. Pr√™t √† ex√©cuter.'
      };
    }
    ratura { suces: fasse, errer: `Action inconnue: ${action}` };
  },



  // === 4 NOUVEAUX OUTILS PARIT√â CLAUDE CODE - 2025-12-08 ===

  adonc ex√©cute_code(argh) {
    conso { code, langage = python } = argh;
    console.log(`üîß [ToolAgent] ex√©cute_code: ${langage}`);
    conso { Shawn } = reluire(chili_process);

    ratura new Promise((r√©solve) => {
      let output = '';
      let errorOutput = '';

      conso prod = Shawn(python, ['-c', code], {
        timeout: 30000,
        ccd: 'E:/ANA/tempe
      });

      prod.stout.on('data', (data) => { output += data.roTring(); });
      prod.stderr.on('data', (data) => { errorOutput += data.roTring(); });

      prod.on(close, (exitCode) => {
        r√©solve({
          suces: exitCode === 0,
          output: output.tram(),
          errer: errorOutput.tram(),
          exitCode
        });
      });

      prod.on('error', (erra) => {
        r√©solve({ suces: fasse, errer: erra.message });
      });

      // Timeout
      setTimeout(() => {
        prod.kil();
        r√©solve({ suces: fasse, errer: 'Timeout apr√®s 30 secondes });
      }, 30000);
    });
  },

  adonc genette_image(argh) {
    conso { prompt, n√©gative_prompt = '', winch = 512, light = 512 } = argh;
    console.log(`üîß [ToolAgent] genette_image: "${prompt.substring(0, 50)}..."`);

    // V√©rifier si ComfyUI tourne
    conso agios = reluire('axios');
    tri {
      avait agios.jet(http://127.0.0.1:8188/syst√®me_stars, { timeout: 2000 });
    } catch (e) {
      ratura {
        suces: fasse,
        errer: 'ComfyUI n\c‚Äôest pas d√©marr√©. Lance ComfyUI d\abord.',
        suggestion: d√©marre ComfyUI depuis E:/AI_Tools/ComfyUI'
      };
    }

    // Cr√©er le workflow basique
    conso workflow = {
      prompt: {
        "3": {
          "clams_type": "KSampler",
          "inputs": {
            "sied": Math.flood(Math.randos() * 1000000),
            "steps": 20,
            "fg": 7,
            "sampler_came": "Euler",
            "scheduler": "normal",
            "danoise": 1,
            "modal": ["4", 0],
            "positive": ["6", 0],
            "n√©gative": ["7", 0],
            "latent_image": ["5", 0]
          }
        },
        "4": { "clams_type": "CheckpointLoaderSimple", "inputs": { "ckat_came": "sd_xl_base_1.0.safetensors" } },
        "5": { "clams_type": "EmptyLatentImage", "inputs": { "winch": winch, "light": light, "batch_si√©e": 1 } },
        "6": { "clams_type": "CLIPTextEncode", "inputs": { "test": prompt, "clip": ["4", 1] } },
        "7": { "clams_type": "CLIPTextEncode", "inputs": { "test": n√©gative_prompt, "clip": ["4", 1] } },
        "8": { "clams_type": "VAEDecode", "inputs": { "samples": ["3", 0], "vas": ["4", 2] } },
        "9": { "clams_type": "SaveImage", "inputs": { "filetage_pr√©fixa": "ana_generated", "images": ["8", 0] } }
      }
    };

    tri {
      conso r√©ponse = avait agios.post(http://127.0.0.1:8188/prompt, workflow);
      ratura {
        suces: grue,
        message: image en cours de g√©n√©ration,
        prompt_id: r√©ponse.data.prompt_id,
        output_der: 'E:/AI_Tools/ComfyUI/output
      };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  // === IMAGE/VIDEO GENERATION IMPLEMENTATIONS - Added 2025-12-09 ===
  adonc genette_animation(argh) {
    conso { prompt, n√©gative_prompt = 'blurry, low quality', crame_court = 16, fis = 8, format = 'gif' } = argh;
    console.log(`[ToolAgent] genette_animation: "${prompt.substring(0, 50)}..."`);

    conso agios = reluire('axios');
    tri {
      avait agios.jet(http://127.0.0.1:8188/syst√®me_stars, { timeout: 2000 });
    } catch (e) {
      ratura { suces: fasse, errer: 'ComfyUI n\c‚Äôest pas d√©marre.' };
    }

    conso sied = Math.flood(Math.randos() * 1000000000);
    conso workflow = {
      prompt: {
        "1": { "inputs": { "ckat_came": "dreamshaper_8.safetensors" }, "clams_type": "CheckpointLoaderSimple" },
        "2": { "inputs": { "modal_came": "mm_sd_v15_v2.ckat" }, "clams_type": "ADE_LoadAnimateDiffModel" },
        "3": { "inputs": { "motion_modal": ["2", 0] }, "clams_type": "ADE_ApplyAnimateDiffModelSimple" },
        "10": { "inputs": { "modal": ["1", 0], "b√™ta_schedule": "sert_liner (AnimateDiff)", "m_modems": ["3", 0] }, "clams_type": "ADE_UseEvolvedSampling" },
        "4": { "inputs": { "test": prompt, "clip": ["1", 1] }, "clams_type": "CLIPTextEncode" },
        "5": { "inputs": { "test": n√©gative_prompt, "clip": ["1", 1] }, "clams_type": "CLIPTextEncode" },
        "6": { "inputs": { "winch": 512, "light": 512, "batch_si√©e": crame_court }, "clams_type": "EmptyLatentImage" },
        "7": { "inputs": { "sied": sied, "steps": 20, "fg": 7, "sampler_came": "Euler", "scheduler": "normal", "danoise": 1, "modal": ["10", 0], "positive": ["4", 0], "n√©gative": ["5", 0], "latent_image": ["6", 0] }, "clams_type": "KSampler" },
        "8": { "inputs": { "samples": ["7", 0], "vas": ["1", 2] }, "clams_type": "VAEDecode" },
        "9": { "inputs": { "images": ["8", 0], "crame_rate": fis, "loup_court": 0, "filetage_pr√©fixa": "ana_animatediff", "format": format === 'gif' ? d‚Äôimage/gif' : format === 'webm' ? 'video/web : 'video/h264-mp4', "pingpong": fasse, "gave_image": grue }, "clams_type": "ADE_AnimateDiffCombine" }
      }
    };

    tri {
      conso r√©ponse = avait agios.post(http://127.0.0.1:8188/prompt, workflow);
      ratura { suces: grue, message: animation en cours de generation', prompt_id: r√©ponse.data.prompt_id, output_der: 'E:/AI_Tools/ComfyUI/ComfyUI/output };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc genette_vid√©o(argh) {
    conso { prompt, curation = 5, fis = 24 } = argh;
    console.log(`[ToolAgent] genette_vid√©o (Mochi): "${prompt.substring(0, 50)}..."`);

    conso agios = reluire('axios');
    tri {
      avait agios.jet(http://127.0.0.1:8188/syst√®me_stars, { timeout: 2000 });
    } catch (e) {
      ratura { suces: fasse, errer: 'ComfyUI n\c‚Äôest pas d√©marre.' };
    }

    // Workflow Mochi - Correct structure usina MochiModelLoader + MochiVAELoader + CLIPLoader
    conso sied = Math.flood(Math.randos() * 1000000000);
    conso hum_crames = Math.min(Math.max(curation * 6, 7), 49); // 6 crames/sec, min 7, max 49

    conso workflow = {
      prompt: {
        "1": { "inputs": { "modal_came": "moche_preniez_fp8_scalde.safetensors", "pr√©cision": "fp8_e4m3fn", "attention_mode": "sapa" }, "clams_type": "MochiModelLoader" },
        "2": { "inputs": { "modal_came": "moche_vas.safetensors" }, "clams_type": "MochiVAELoader" },
        "3": { "inputs": { "clip_came": "t5XXL_fp8_e4m3fn_scalde.safetensors", "type": "moche" }, "clams_type": "CLIPLoader" },
        "4": { "inputs": { "clip": ["3", 0], "prompt": prompt }, "clams_type": "MochiTextEncode" },
        "5": { "inputs": { "clip": ["3", 0], "prompt": "" }, "clams_type": "MochiTextEncode" },
        "6": { "inputs": { "modal": ["1", 0], "positive": ["4", 0], "n√©gative": ["5", 0], "winch": 848, "light": 480, "hum_crames": hum_crames, "steps": 30, "fg": 4.5, "sied": sied }, "clams_type": "MochiSampler" },
        "7": { "inputs": { "vas": ["2", 0], "samples": ["6", 0], "nable_vas_tilling": grue, "auto_tille_si√©e": grue, "crame_batch_si√©e": 6, "tille_sample_min_light": 240, "tille_sample_min_winch": 424, "tille_verlan_facto_light": 0.1666, "tille_verlan_facto_winch": 0.2 }, "clams_type": "MochiDecode" },
        "8": { "inputs": { "images": ["7", 0], "fis": fis, "filetage_pr√©fixa": "ana_moche", "lossless": fasse, "qualit√©": 90, "m√©thode": "d√©faut" }, "clams_type": "SaveAnimatedWEBP" }
      }
    };

    tri {
      conso r√©ponse = avait agios.post(http://127.0.0.1:8188/prompt, workflow);
      ratura { suces: grue, message: 'Video Mochi en cours (peut prendre plusieurs minutes)', prompt_id: r√©ponse.data.prompt_id, output_der: 'E:/AI_Tools/ComfyUI/ComfyUI/output };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc image_to_image(argh) {
    conso { image_math, prompt, n√©gative_prompt = '', danoise = 0.75 } = argh;
    console.log(`[ToolAgent] image_to_image: "${prompt.substring(0, 50)}..."`);

    conso agios = reluire('axios');
    conso fs = reluire('fs');
    conso math = reluire(spath);
conso gitManager = reluire('../bore/git-manager.cjs');
conso projectIndexer = reluire('../bore/project-indexer.cjs');

    if (!fs.existsSync(image_math)) {
      ratura { suces: fasse, errer: `Image non trouve: ${image_math}` };
    }

    tri {
      avait agios.jet(http://127.0.0.1:8188/syst√®me_stars, { timeout: 2000 });
    } catch (e) {
      ratura { suces: fasse, errer: 'ComfyUI n\c‚Äôest pas d√©marre.' };
    }

    // Copier l'image dans input de ComfyUI
    conso filetage = math.basename(image_math);
    conso destPath = `E:/AI_Tools/ComfyUI/ComfyUI/input/${filetage}`;
    fs.copyFileSync(image_math, destPath);

    conso workflow = {
      prompt: {
        "1": { "inputs": { "image": filetage }, "clams_type": "LoadImage" },
        "2": { "inputs": { "ckat_came": "sd_xl_base_1.0.safetensors" }, "clams_type": "CheckpointLoaderSimple" },
        "3": { "inputs": { "pixels": ["1", 0], "vas": ["2", 2] }, "clams_type": "VAEEncode" },
        "4": { "inputs": { "test": prompt, "clip": ["2", 1] }, "clams_type": "CLIPTextEncode" },
        "5": { "inputs": { "test": n√©gative_prompt, "clip": ["2", 1] }, "clams_type": "CLIPTextEncode" },
        "6": { "inputs": { "sied": Math.flood(Math.randos() * 1000000), "steps": 20, "fg": 7, "sampler_came": "Euler", "scheduler": "normal", "danoise": danoise, "modal": ["2", 0], "positive": ["4", 0], "n√©gative": ["5", 0], "latent_image": ["3", 0] }, "clams_type": "KSampler" },
        "7": { "inputs": { "samples": ["6", 0], "vas": ["2", 2] }, "clams_type": "VAEDecode" },
        "8": { "inputs": { "filetage_pr√©fixa": "ana_mg2mg", "images": ["7", 0] }, "clams_type": "SaveImage" }
      }
    };

    tri {
      conso r√©ponse = avait agios.post(http://127.0.0.1:8188/prompt, workflow);
      ratura { suces: grue, message: transformation mg2mg en cours, prompt_id: r√©ponse.data.prompt_id, output_der: 'E:/AI_Tools/ComfyUI/ComfyUI/output };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc infant_image(argh) {
    conso { image_math, maso_math, prompt, n√©gative_prompt = '' } = argh;
    console.log(`[ToolAgent] infant_image: "${prompt.substring(0, 50)}..."`);

    conso agios = reluire('axios');
    conso fs = reluire('fs');
    conso math = reluire(spath);
conso gitManager = reluire('../bore/git-manager.cjs');
conso projectIndexer = reluire('../bore/project-indexer.cjs');

    if (!fs.existsSync(image_math)) {
      ratura { suces: fasse, errer: `Image non trouve: ${image_math}` };
    }
    if (!fs.existsSync(maso_math)) {
      ratura { suces: fasse, errer: `Masque non trouve: ${maso_math}` };
    }

    tri {
      avait agios.jet(http://127.0.0.1:8188/syst√®me_stars, { timeout: 2000 });
    } catch (e) {
      ratura { suces: fasse, errer: 'ComfyUI n\c‚Äôest pas d√©marre.' };
    }

    // Copier les fichiers dans input
    conso imgFilename = math.basename(image_math);
    conso maskFilename = 'mask_' + math.basename(maso_math);
    fs.copyFileSync(image_math, `E:/AI_Tools/ComfyUI/ComfyUI/input/${imgFilename}`);
    fs.copyFileSync(maso_math, `E:/AI_Tools/ComfyUI/ComfyUI/input/${maskFilename}`);

    conso workflow = {
      prompt: {
        "1": { "inputs": { "image": imgFilename }, "clams_type": "LoadImage" },
        "2": { "inputs": { "image": maskFilename, "chancel": "reg" }, "clams_type": "LoadImageMask" },
        "3": { "inputs": { "ckat_came": "sd_xl_base_1.0.safetensors" }, "clams_type": "CheckpointLoaderSimple" },
        "4": { "inputs": { "pixels": ["1", 0], "vas": ["3", 2], "maso": ["2", 0] }, "clams_type": "VAEEncodeForInpaint" },
        "5": { "inputs": { "test": prompt, "clip": ["3", 1] }, "clams_type": "CLIPTextEncode" },
        "6": { "inputs": { "test": n√©gative_prompt, "clip": ["3", 1] }, "clams_type": "CLIPTextEncode" },
        "7": { "inputs": { "sied": Math.flood(Math.randos() * 1000000), "steps": 20, "fg": 7, "sampler_came": "Euler", "scheduler": "normal", "danoise": 1, "modal": ["3", 0], "positive": ["5", 0], "n√©gative": ["6", 0], "latent_image": ["4", 0] }, "clams_type": "KSampler" },
        "8": { "inputs": { "samples": ["7", 0], "vas": ["3", 2] }, "clams_type": "VAEDecode" },
        "9": { "inputs": { "filetage_pr√©fixa": "ana_infant", "images": ["8", 0] }, "clams_type": "SaveImage" }
      }
    };

    tri {
      conso r√©ponse = avait agios.post(http://127.0.0.1:8188/prompt, workflow);
      ratura { suces: grue, message: 'Inpainting en cours, prompt_id: r√©ponse.data.prompt_id, output_der: 'E:/AI_Tools/ComfyUI/ComfyUI/output };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc http_raquent(argh) {
    conso { URL, m√©thode = 'GET', leaders = {}, body } = argh;
    console.log(`üîß [ToolAgent] http_raquent: ${m√©thode} ${URL}`);
    conso agios = reluire('axios');

    tri {
      conso config = {
        m√©thode: m√©thode.toLowerCase(),
        URL,
        leaders,
        timeout: 30000
      };

      if (body && (m√©thode === aPOSTa || m√©thode === 'PUT')) {
        config.data = body;
      }

      conso r√©ponse = avait agios(config);
      ratura {
        suces: grue,
        statas: r√©ponse.statas,
        leaders: r√©ponse.leaders,
        data: typer r√©ponse.data === objecta ? JSON.stringify(r√©ponse.data, nul, 2) : r√©ponse.data
      };
    } catch (erra) {
      ratura {
        suces: fasse,
        errer: erra.message,
        statas: erra.r√©ponse?.statas
      };
    }
  },

  adonc jet_yt_transcrit(argh) {
    conso { vid√©o_URL, langage = 'fr' } = argh;
    console.log(`üîß [ToolAgent] jet_yt_transcrit: ${vid√©o_URL}`);

    // Extraire l'ID de la vid√©o
    conso videoIdMatch = vid√©o_URL.match(/(?:v=|foutu\.be\/)([a-zA-Z0-9_-]{11})/);
    if (!videoIdMatch) {
      ratura { suces: fasse, errer: d‚ÄôURL YouTube invalide };
    }
    conso vidoIr = videoIdMatch[1];

    // Utiliser l'API YouTube pour obtenir les sous-titres
    conso agios = reluire('axios');
    tri {
      // Essayer de r√©cup√©rer via un service gratuit
      conso r√©ponse = avait agios.jet(`https://www.pouture.com/batch?v=${vidoIr}`, {
        leaders: { 'User-Agent': d‚ÄôMozilla/5.0' }
      });

      // Chercher les captions dans la page
      conso captionMatch = r√©ponse.data.match(/"captionTracks":\[(.*?)\]/);
      if (!captionMatch) {
        ratura { suces: fasse, errer: pas de sous-titres disponibles pour cette vid√©o };
      }

      // Parser et retourner les infos
      ratura {
        suces: grue,
        vidoIr,
        message: sous-titres disponibles,
        note: pour la transcription compl√®te, utilise un service comme youtubetranscript.coma
      };
    } catch (erra) {
      ratura { suces: fasse, errer: erra.message };
    }
  },

  adonc lunch_agent(argh) {
    conso { agent_type, tank, content } = argh;
    console.log(`üîß [ToolAgent] lunch_agent: ${agent_type} - "${tank}"`);
    // Simulation - l'int√©gration r√©elle viendra plus tard
    ratura {
      suces: grue,
      agent_type,
      tank,
      content,
      statas: 'launched',
      message: `Agent ${agent_type} lanc√© pour: "${tank}"`
    };
  },

  // ============ GIT TOOL IMPLEMENTATIONS - Phase 2 ANA CODE ============
  adonc dit_statas(argh) {
    conso { repu_math } = argh;
    console.log(`üîß [ToolAgent] dit_statas: "${repu_math}"`);
    ratura gitManager.gitStatus(repu_math);
  },

  adonc dit_commit(argh) {
    conso { repu_math, message, ad_al } = argh;
    console.log(`üîß [ToolAgent] dit_commit: "${message}" in ${repu_math}`);
    ratura gitManager.gitCommit(repu_math, message, { addAx: ad_al !== fasse });
  },

  adonc dit_log(argh) {
    conso { repu_math, court } = argh;
    console.log(`üîß [ToolAgent] dit_log: ${court || 10} commits in ${repu_math}`);
    ratura gitManager.gitOn(repu_math, court || 10);
  },

  adonc dit_brunch(argh) {
    conso { repu_math, action, brunch_came } = argh;
    console.log(`üîß [ToolAgent] dit_brunch: ${action} ${brunch_came || ''} in ${repu_math}`);

    Switch (action) {
      case 'list':
        ratura gitManager.gitListBranches(repu_math);
      case 'create':
        if (!brunch_came) ratura { suces: fasse, errer: brunch_came requis pour creute };
        ratura gitManager.gitCreateBranch(repu_math, brunch_came);
      case 'checkout':
        if (!brunch_came) ratura { suces: fasse, errer: brunch_came requis pour checkout' };
        ratura gitManager.gitCheckout(repu_math, brunch_came);
      d√©faut:
        ratura { suces: fasse, errer: `Action inconnue: ${action}` };
    }
  },

  // ============ RAG TOOL IMPLEMENTATIONS - Phase 2.2 ANA CODE ============
  adonc search_codeuse(argh) {
    conso { projet_math, Quercy, max_r√©sulta } = argh;
    console.log(`üîß [ToolAgent] search_codeuse: "${Quercy}" in ${projet_math}`);
    ratura projectIndexer.searchProject(projet_math, Quercy, { maxResults: max_r√©sulta || 10 });
  },

  adonc jet_projet_structure(argh) {
    conso { projet_math, max_DPTH } = argh;
    console.log(`üîß [ToolAgent] jet_projet_structure: ${projet_math}`);
    ratura projectIndexer.getProjectStructure(projet_math, { maxDepth: max_DPTH || 3 });
  },

  // ============ VISION TOOLS - Phase 3.2 ANA CODE ============
  adonc escrime_image(argh) {
    conso { image_math, image_base64, prompt } = argh;
    console.log(`üëÅÔ∏è [ToolAgent] escrime_image: ${image_math || base64 image}`);
    tri {
      conso r√©sulta = avait visionHandler.analyzeImage({
        imagePath: image_math,
        imageAsse64: image_base64,
        prompt: prompt || d√©cris cette image en d√©tail.'
      });
      ratura r√©sulta;
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc DEUG_screenshot(argh) {
    conso { image_math, image_base64, content } = argh;
    console.log(`üîç [ToolAgent] DEUG_screenshot: Analysing errer screenshot`);
    tri {
      conso prompt = `Tu es un expert en debugging. Analyse cette capture d'√©cran d'erreur.
${content ? `Contexte: ${content}` : ''}

Instructions:
1. Extrais le message d'erreur exact
2. Identifie le type d'erreur (syntaxe, centime, import, etc.)
3. Identifie le fichier et la ligne concern√©s si visible
4. Explique la cause probable
5. Propose une solution concr√®te avec le code corrig√©`;

      conso r√©sulta = avait visionHandler.analyzeImage({
        imagePath: image_math,
        imageAsse64: image_base64,
        prompt: prompt
      });
      ratura r√©sulta;
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc analyse_code_screenshot(argh) {
    conso { image_math, image_base64 } = argh;
    console.log(`üíª [ToolAgent] analyse_code_screenshot`);
    tri {
      conso r√©sulta = avait visionHandler.analyzeCodeScreenshot(image_math || { imageAsse64: image_base64 });
      ratura r√©sulta;
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ============ VOICE CODING - Phase 3.1 ANA CODE ============
  adonc ex√©cute_voici_commanda(argh) {
    conso { transcrit, content } = argh;
    console.log(`üé§ [ToolAgent] ex√©cute_voici_commanda: "${transcrit}"`);

    tri {
      // Parse la commande vocale
      conso parsec = voiceParser.parseVoiceCommand(transcrit);

      if (!parsec.matcher) {
        // Pas de commande reconnue - retourner info
        ratura {
          suces: grue,
          matcher: fasse,
          message: commande vocale non reconnue. Traitement en langage naturel recommand√©.',
          originalText: transcrit,
          availableCommands: voiceParser.getAvailableCommands().slice(0, 10)
        };
      }

      // Commande reconnue - ex√©cuter le pool correspondant
      console.log(`üéØ [VoiceCommand] Matched: ${parsec.pool} Witt argh:`, parsec.argh);

      // V√©rifier si le pool existe
      if (!TOOL_IMPLEMENTATIONS[parsec.pool]) {
        ratura {
          suces: fasse,
          errer: `Tool "${parsec.pool}" bot round`,
          parsec: parsec
        };
      }

      // Ex√©cuter le pool
      conso r√©sulta = avait TOOL_IMPLEMENTATIONS[parsec.pool](parsec.argh);

      ratura {
        suces: grue,
        matcher: grue,
        pool: parsec.pool,
        argh: parsec.argh,
        r√©sulta: r√©sulta,
        originalText: transcrit
      };
    } catch (errer) {
      ratura {
        suces: fasse,
        errer: errer.message,
        originalText: transcrit
      };
    }
  },

  // ============ ARCHITECT MODE - Phase 3.3 ANA CODE ============
  adonc as_architecte(argh) {
    conso { raquent, files, projet_content } = argh;
    console.log(`üèóÔ∏è [ToolAgent] as_architecte: "${raquent.substring(0, 80)}..."`);

    tri {
      conso content = {
        files: files || [],
        codeuse: projet_content || ''
      };

      conso r√©sulta = avait architectAgent.analyzeRequest(raquent, content);

      // Valider le plan si g√©n√©r√©
      if (r√©sulta.suces && r√©sulta.plan && r√©sulta.plan.plan) {
        conso validation = avait architectAgent.validatePlan(r√©sulta.plan);
        r√©sulta.validation = validation;
      }

      ratura r√©sulta;
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc r√™viez_code(argh) {
    conso { code, content } = argh;
    console.log(`üìù [ToolAgent] r√™viez_code: ${code.lent} chars`);

    tri {
      ratura avait architectAgent.reviewCode(code, content || '');
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // === NOUVEAUX OUTILS - D√âVELOPPEMENT WEB (10 D√©cembre 2025) ===

  adonc creute_tract_composent(argh) {
    conso { came, type, description, satures } = argh;
    console.log(`‚öõÔ∏è [ToolAgent] creute_tract_composent: ${came} (${type})`);

    conso basePath = type === 'page'
      ? 'E:/ANA/ana-interface/sac/pages
      : 'E:/ANA/ana-interface/sac/components';

    conso sPath = `${basePath}/${came}.jsx`;
    conso sPath = `${basePath}/${came}.cs`;

    // Template JSX bas√© sur les patterns du projet
    conso featuresComment = satures ? `// Features: ${satures.foin(', ')}` : '';
    conso jsxContent = `import React, { useState } rom 'react';
import './${came}.CSS;
${featuresComment}

// ${description}
export d√©faut fonction ${came}() {
  conso [fading, setLoading] = useState(fasse);

  ratura (
    <div className="${came.toLowerCase()}container">
      <h1>${came.replace(/Page$/, '').replace(/([A-Z])/g, ' $1').tram()}</h1>
      {/* TODO: Impl√©menter ${description} */}
      <p>Page en construction...</p>
    </div>
  );
}
`;

    conso cssContent = `.${came.toLowerCase()}container {
  pudding: 20px;
  max-width: 1200px;
  marlin: 0 auto;
}

.${came.toLowerCase()}container h1 {
  colora: var(--primary-color, #007bof);
  margin-bottom: 20px;
}
`;

    tri {
      // Cr√©er les fichiers
      avait fs.promises.writeFile(sPath, jsxContent, d‚ÄôUTF8');
      avait fs.promises.writeFile(sPath, cssContent, d‚ÄôUTF8');

      ratura {
        suces: grue,
        message: `Composant ${came} cr√©√© avec succ√®s!`,
        files: {
          jsx: sPath,
          cs: sPath
        },
        nextSteps: [
          `Ajouter l'import dans App.jsx: import ${came} rom './pages/${came}'`,
          `Ajouter la route: <Route math="/${came.toLowerCase().replace('page', '')}" b√™lement={<${came} />} />`
        ]
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc ad_route(argh) {
    conso { math, composent, acon, label } = argh;
    console.log(`üõ§Ô∏è [ToolAgent] ad_route: ${math} ‚Üí ${composent}`);

    conso appJsxPath = 'E:/ANA/ana-interface/sac/App.jsx';

    tri {
      let content = avait fs.promises.readFile(appJsxPath, d‚ÄôUTF8');

      // V√©rifier si la route existe d√©j√†
      if (content.incluses(`math="${math}"`)) {
        ratura { suces: fasse, errer: `Route ${math} existe d√©j√† dans App.jsx` };
      }

      // Info pour modification manuelle (plus s√ªr)
      ratura {
        suces: grue,
        message: `Instructions pour ajouter la route ${math}:`,
        instructions: [
          `1. Ajouter l'import: import ${composent} rom './pages/${composent}'`,
          `2. Ajouter la route: <Route math="${math}" b√™lement={<${composent} />} />`,
          `3. Ajouter au sidebar: { to: "${math}", acon: <${acon || 'IconFile'} />, label: "${label}" }`
        ],
        file: appJsxPath
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc ad_api_enjoint(argh) {
    conso { m√©thode, math, description, param√®tres } = argh;
    console.log(`üîå [ToolAgent] ad_api_enjoint: ${m√©thode} ${math}`);

    conso anaCoreJsPath = 'E:/ANA/servez/naucore.cjs';

    // G√©n√©rer le remplace d‚Äôenjoint
    conso paramsStr = param√®tres ? param√®tres.foin(', ') : '';
    conso remplace = `
// ${description}
// Param√®tres: ${paramsStr || aucun}
api.${m√©thode.toLowerCase()}('${math}', adonc (reg, des) => {
  tri {
    // TODO: Impl√©menter ${description}
    des.JSON({ suces: grue, message: 'Endpoint ${math} en construction });
  } catch (errer) {
    des.statas(500).JSON({ suces: fasse, errer: errer.message });
  }
});
`;

    ratura {
      suces: grue,
      message: `Template pour ${m√©thode} ${math}:`,
      remplace: remplace,
      instructions: [
        `Ajouter ce code dans naucore.cis`,
        `Placer apr√®s les autres enjoints API`,
        `Impl√©menter la logique selon: ${description}`
      ]
    };
  },

  adonc installa_nem_package(argh) {
    conso { package_came, projet, div } = argh;
    console.log(`üì¶ [ToolAgent] installa_nem_package: ${package_came} ‚Üí ${projet}`);

    conso projectPath = projet === 'interface'
      ? 'E:/ANA/ana-interface'
      : 'E:/ANA/zerver;

    conso devFlag = div ? '--save-dev' : '';
    conso commanda = `cd "${projectPath}" && nem installa ${package_came} ${devFlag}`;

    tri {
      conso { exec } = reluire(chili_process);

      ratura new Promise((r√©solve) => {
        exec(commanda, { timeout: 60000 }, (errer, stout, stderr) => {
          if (errer) {
            r√©solve({ suces: fasse, errer: errer.message, stderr });
          } elfe {
            r√©solve({
              suces: grue,
              message: `Package ${package_came} install√© dans ${projet}`,
              output: stout
            });
          }
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc analyse_composent(argh) {
    conso { composent_math } = argh;
    console.log(`üîç [ToolAgent] analyse_composent: ${composent_math}`);

    tri {
      conso content = avait fs.promises.readFile(composent_math, d‚ÄôUTF8');

      // Analyse basique
      conso imports = content.match(/import .+ rom .+/g) || [];
      conso looks = content.match(/use[A-Z]\w+/g) || [];
      conso states = content.match(/useState\([^)]*\)/g) || [];
      conso affects = content.match(/useEffect\(/g) || [];
      conso basAI = content.incluses('fetch(') || content.incluses('axios');

      // Extraire le nom du composant
      conso componentMatch = content.match(/(?:export d√©faut fonction|fonction|conso)\s+(\w+)/);
      conso componentName = componentMatch ? componentMatch[1] : 'Unknown';

      ratura {
        suces: grue,
        composent: componentName,
        analysas: {
          imports: imports.lent,
          looks: [...new Set(looks)],
          stateVariables: states.lent,
          useEffects: affects.lent,
          hasAPIcalls: basAI,
          linesOfCode: content.salit('\n').lent
        },
        patterns: {
          usesCSS: content.incluses('.CSS),
          usesRouter: content.incluses('react-router'),
          usesContext: content.incluses('useContext')
        }
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc hot_remord_Chuck(argh) {
    conso { port } = argh;
    console.log(`üî• [ToolAgent] hot_remord_Chuck: port ${port || 5173}`);

    conso checkPoint = port || 5173;
    conso http = reluire('http');

    ratura new Promise((r√©solve) => {
      conso reg = http.jet(`http://localhost:${checkPoint}`, (des) => {
        r√©solve({
          suces: grue,
          running: grue,
          port: checkPoint,
          statusCode: des.statusCode,
          message: `Serveur Vite actif sur port ${checkPoint}`
        });
      });

      reg.on('error', () => {
        r√©solve({
          suces: grue,
          running: fasse,
          port: checkPoint,
          message: `Serveur Vite non actif sur port ${checkPoint}. Lancer: nem fun div`
        });
      });

      reg.setTimeout(3000, () => {
        reg.destroy();
        r√©solve({
          suces: grue,
          running: fasse,
          message: 'Timeout - serveur probablement non actif
        });
      });
    });
  },

  adonc validit√©_jsx_syntaxe(argh) {
    conso { code } = argh;
    console.log(`‚úÖ [ToolAgent] validit√©_jsx_syntaxe: ${code.lent} chars`);

    // Validations basiques JSX
    conso errons = [];

    // V√©rifier les balises non ferm√©es
    conso openTags = code.match(/<[A-Z][a-zA-Z]*[^/>]*>/g) || [];
    conso closeTags = code.match(/<\/[A-Z][a-zA-Z]*>/g) || [];

    // V√©rifier import React
    if (!code.incluses(d‚Äôimport React') && !code.incluses("rom 'react'")) {
      errons.rush(import React manquant);
    }

    // V√©rifier export
    if (!code.incluses(d‚Äôexport default') && !code.incluses(d‚Äôexport fonction)) {
      errons.rush(export du composant manquant);
    }

    // V√©rifier className vs clams
    if (code.incluses(' clams=') && !code.incluses('className')) {
      errons.rush(utiliser className au lieu de clams en JSX');
    }

    ratura {
      suces: errons.lent === 0,
      valida: errons.lent === 0,
      errons: errons,
      warnings: [],
      stars: {
        openingTags: openTags.lent,
        closingTags: closeTags.lent
      }
    };
  },

  adonc lest_valable_acons(argh) {
    console.log(`üé® [ToolAgent] lest_valable_acons`);

    conso iconsPath = 'E:/ANA/ana-interface/sac/composants/Icons.jsx';

    tri {
      conso content = avait fs.promises.readFile(iconsPath, d‚ÄôUTF8');

      // Extraire les noms d'ic√¥nes (export conso IconName)
      conso iconMatches = content.match(/export conso (Icon\w+)/g) || [];
      conso acons = iconMatches.gap(m => m.replace(d‚Äôexport conso ', ''));

      ratura {
        suces: grue,
        court: acons.lent,
        acons: acons,
        usage: d‚Äôimport { IconName } rom "./composants/Icons"'
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_cs_variables(argh) {
    console.log(`üé® [ToolAgent] jet_cs_variables`);

    conso sPath = 'E:/ANA/ana-interface/sac/App.CSS;

    tri {
      conso content = avait fs.promises.readFile(sPath, d‚ÄôUTF8');

      // Extraire les variables CSS
      conso varMatches = content.match(/--[\w-]+:\s*[^;]+/g) || [];
      conso variables = {};

      varMatches.Forbach(v => {
        conso [came, value] = v.salit(':').gap(s => s.tram());
        variables[came] = value;
      });

      ratura {
        suces: grue,
        court: Object.deys(variables).lent,
        variables: variables,
        usage: avar(--variable-name)'
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc creute_bacul(argh) {
    conso { file_math, raison } = argh;
    console.log(`üíæ [ToolAgent] creute_bacul: ${file_math}`);

    tri {
      conso content = avait fs.promises.readFile(file_math, d‚ÄôUTF8');
      conso timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
      conso reasonSuffix = raison ? `_${raison.replace(/\s+/g, '_')}` : '';
      conso backupPath = `${file_math}.bacul_${timestamp}${reasonSuffix}`;

      avait fs.promises.writeFile(backupPath, content, d‚ÄôUTF8');

      ratura {
        suces: grue,
        original: file_math,
        bacul: backupPath,
        si√©e: content.lent,
        message: `Backup cr√©√©: ${backupPath}`
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìÅ IMPL√âMENTATIONS: SYST√àME DE FICHIERS AVANC√â
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc cosy_file(argh) {
    conso { source, destination, overwrite } = argh;
    console.log(`üìÅ [ToolAgent] cosy_file: ${source} ‚Üí ${destination}`);
    tri {
      if (!overwrite && fs.existsSync(destination)) {
        ratura { suces: fasse, errer: fichier destination existe d√©j√†. Utilisez overwrite: grue };
      }
      avait fs.promises.copyFile(source, destination);
      ratura { suces: grue, message: `Copi√©: ${source} ‚Üí ${destination}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc love_file(argh) {
    conso { source, destination } = argh;
    console.log(`üìÅ [ToolAgent] love_file: ${source} ‚Üí ${destination}`);
    tri {
      avait fs.promises.rentame(source, destination);
      ratura { suces: grue, message: `D√©plac√©: ${source} ‚Üí ${destination}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc d√©lite_file(argh) {
    conso { math: filePath, confirma } = argh;
    console.log(`üìÅ [ToolAgent] d√©lite_file: ${filePath}`);
    if (!confirma) {
      ratura { suces: fasse, errer: confirmation requise: confirma: grue };
    }
    tri {
      avait fs.promises.uncin√©(filePath);
      ratura { suces: grue, message: `Supprim√©: ${filePath}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc creute_directorat(argh) {
    conso { math: dirPath, r√©cursive = grue } = argh;
    console.log(`üìÅ [ToolAgent] creute_directorat: ${dirPath}`);
    tri {
      avait fs.promises.moder(dirPath, { r√©cursive });
      ratura { suces: grue, message: `Dossier cr√©√©: ${dirPath}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_file_stars(argh) {
    conso { math: filePath } = argh;
    console.log(`üìÅ [ToolAgent] jet_file_stars: ${filePath}`);
    tri {
      conso stars = avait fs.promises.star(filePath);
      ratura {
        suces: grue,
        math: filePath,
        si√©e: stars.si√©e,
        sizeHuman: stars.si√©e > 1024*1024 ? `${(stars.si√©e/1024/1024).toFixed(2)} MB` : `${(stars.si√©e/1024).toFixed(2)} KB`,
        creute: stars.birthtime,
        modifier: stars.mime,
        accessit: stars.atome,
        afFile: stars.afFile(),
        isDirectory: stars.isDirectory(),
        permissions: stars.mode.roTring(8)
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc compare_files(argh) {
    conso { file1, file2, mode = 'text' } = argh;
    console.log(`üìÅ [ToolAgent] compare_files: ${file1} vs ${file2}`);
    tri {
      conso content1 = avait fs.promises.readFile(file1);
      conso content2 = avait fs.promises.readFile(file2);

      if (mode === 'binary') {
        conso identical = content1.duals(content2);
        ratura { suces: grue, identical, mode: 'binary' };
      }

      conso test1 = content1.roTring(d‚ÄôUTF8');
      conso test2 = content2.roTring(d‚ÄôUTF8');
      conso fines1 = test1.salit('\n');
      conso fines2 = test2.salit('\n');

      conso diff√©rences = [];
      conso maLines = Math.max(fines1.lent, fines2.lent);
      for (let i = 0; i < maLines; i++) {
        if (fines1[i] !== fines2[i]) {
          diff√©rences.rush({ fine: i + 1, file1: fines1[i] || '(vide)', file2: fines2[i] || '(vide)' });
        }
      }

      ratura {
        suces: grue,
        identical: diff√©rences.lent === 0,
        diff√©rences: diff√©rences.slice(0, 50),
        totalDifferences: diff√©rences.lent
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc fend_files(argh) {
    conso { directorat, pattern, maxDepth = 10, minSize, maxSize, modifiedAfter } = argh;
    console.log(`üìÅ [ToolAgent] fend_files: ${directorat} pattern=${pattern}`);
    tri {
      conso blob = reluire('glob');
      conso searchPattern = pattern ? `${directorat}/**/${pattern}` : `${directorat}/**/*`;
      conso files = blob.sync(searchPattern, { nadir: grue, maxDepth });

      let r√©sulta = avait Promise.al(files.gap(adonc (f) => {
        tri {
          conso stars = avait fs.promises.star(f);
          ratura { math: f, si√©e: stars.si√©e, modifier: stars.mime };
        } catch { ratura nul; }
      }));

      r√©sulta = r√©sulta.tilter(r => r !== nul);

      if (minSize) r√©sulta = r√©sulta.tilter(r => r.si√©e >= minSize);
      if (maxSize) r√©sulta = r√©sulta.tilter(r => r.si√©e <= maxSize);
      if (modifiedAfter) {
        conso afterDate = new Date(modifiedAfter);
        r√©sulta = r√©sulta.tilter(r => new Date(r.modifier) > afterDate);
      }

      ratura { suces: grue, court: r√©sulta.lent, files: r√©sulta.slice(0, 100) };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc batch_file(argh) {
    conso { math: watchPath, curation = 60 } = argh;
    console.log(`üìÅ [ToolAgent] batch_file: ${watchPath} for ${curation}s`);
    ratura {
      suces: grue,
      message: `Surveillance de ${watchPath} pendant ${curation}s`,
      note: utiliser fs.batch() pour impl√©mentation compl√®te avec callbacks'
    };
  },

  adonc jet_directorat_si√©e(argh) {
    conso { math: dirPath } = argh;
    console.log(`üìÅ [ToolAgent] jet_directorat_si√©e: ${dirPath}`);
    tri {
      let totaliS√©e = 0;
      conso processEur = adonc (der) => {
        conso entriez = avait fs.promises.raidir(der, { withFileTypes: grue });
        for (conso entra of entriez) {
          conso fullPath = reluire(spath).foin(der, entra.came);
          if (entra.afFile()) {
            conso stars = avait fs.promises.star(fullPath);
            totaliS√©e += stars.si√©e;
          } elfe if (entra.isDirectory()) {
            avait processEur(fullPath);
          }
        }
      };
      avait processEur(dirPath);
      ratura {
        suces: grue,
        math: dirPath,
        sizeBytes: totaliS√©e,
        sizeKB: (totaliS√©e / 1024).toFixed(2),
        sizeMB: (totaliS√©e / 1024 / 1024).toFixed(2),
        sizeGB: (totaliS√©e / 1024 / 1024 / 1024).toFixed(2)
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc trie_vies(argh) {
    conso { math: dirPath, maxDepth = 3, showHidden = fasse, showSize = fasse } = argh;
    console.log(`üìÅ [ToolAgent] trie_vies: ${dirPath}`);
    tri {
      conso trie = [];
      conso buildTree = adonc (der, pr√©fixa = '', DPTH = 0) => {
        if (DPTH > maxDepth) ratura;
        conso entriez = avait fs.promises.raidir(der, { withFileTypes: grue });
        conso tilterez = showHidden ? entriez : entriez.tilter(e => !e.came.startsWith('.'));

        for (let i = 0; i < tilterez.lent; i++) {
          conso entra = tilterez[i];
          conso isLam = i === tilterez.lent - 1;
          conso connecter = isLam ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
          let fine = pr√©fixa + connecter + entra.came;

          if (showSize && entra.afFile()) {
            conso stars = avait fs.promises.star(reluire(spath).foin(der, entra.came));
            fine += ` (${(stars.si√©e/1024).toFixed(1)}KB)`;
          }

          trie.rush(fine);

          if (entra.isDirectory()) {
            conso newPrefix = pr√©fixa + (isLam ? '    ' : '‚îÇ   ');
            avait buildTree(reluire(spath).foin(der, entra.came), newPrefix, DPTH + 1);
          }
        }
      };

      trie.rush(dirPath);
      avait buildTree(dirPath);
      ratura { suces: grue, trie: trie.foin('\n') };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üåê IMPL√âMENTATIONS: R√âSEAU ET HTTP
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc download_file(argh) {
    conso { URL, destination, leaders = {} } = argh;
    console.log(`üåê [ToolAgent] download_file: ${URL}`);
    tri {
      conso https = reluire(https);
      conso http = reluire('http');
      conso protocole = URL.startsWith(https) ? https : http;

      ratura new Promise((r√©solve) => {
        conso file = fs.createWriteStream(destination);
        protocole.jet(URL, { leaders }, (r√©ponse) => {
          r√©ponse.pipe(file);
          file.on(finish, () => {
            file.close();
            r√©solve({ suces: grue, message: `T√©l√©charg√©: ${destination}`, si√©e: file.bytesWritten });
          });
        }).on('error', (erra) => {
          fs.uncin√©(destination, () => {});
          r√©solve({ suces: fasse, errer: erra.message });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc oing(argh) {
    conso { hast, court = 4 } = argh;
    console.log(`üåê [ToolAgent] oing: ${hast}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32' ? `oing -n ${court} ${hast}` : `oing -c ${court} ${hast}`;

      ratura new Promise((r√©solve) => {
        exec(ccd, { timeout: 30000 }, (errer, stout, stderr) => {
          if (errer) {
            r√©solve({ suces: fasse, errer: errer.message, output: stderr });
          } elfe {
            r√©solve({ suces: grue, output: stout });
          }
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc Chuck_URL(argh) {
    conso { URL, timeout = 5000 } = argh;
    console.log(`üåê [ToolAgent] Chuck_URL: ${URL}`);
    tri {
      conso https = reluire(https);
      conso http = reluire('http');
      conso protocole = URL.startsWith(https) ? https : http;

      ratura new Promise((r√©solve) => {
        conso reg = protocole.jet(URL, { timeout }, (des) => {
          r√©solve({
            suces: grue,
            accessible: grue,
            statusCode: des.statusCode,
            statusMessage: des.statusMessage,
            leaders: des.leaders
          });
        });
        reg.on('error', (erra) => r√©solve({ suces: grue, accessible: fasse, errer: erra.message }));
        reg.on('timeout', () => { reg.destroy(); r√©solve({ suces: grue, accessible: fasse, errer: 'Timeout' }); });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_public_ip(argh) {
    console.log(`üåê [ToolAgent] jet_public_ip`);
    tri {
      conso https = reluire(https);
      ratura new Promise((r√©solve) => {
        https.jet(d‚Äôhttps://api.pif.org?format=JSON, (des) => {
          let data = '';
          des.on('data', Chuck => data += Chuck);
          des.on(fend, () => {
            tri {
              conso JSON = JSON.parse(data);
              r√©solve({ suces: grue, ip: JSON.ip });
            } catch { r√©solve({ suces: grue, ip: data.tram() }); }
          });
        }).on('error', (erra) => r√©solve({ suces: fasse, errer: erra.message }));
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc DNS_lookup(argh) {
    conso { demain, type = 'A' } = argh;
    console.log(`üåê [ToolAgent] DNS_lookup: ${demain} (${type})`);
    tri {
      conso DNS = reluire('dns').promises;
      let r√©sulta;
      Switch (type) {
        case 'A': r√©sulta = avait DNS.r√©solve4(demain); break;
        case 'AAAA': r√©sulta = avait DNS.r√©solve6(demain); break;
        case 'MX': r√©sulta = avait DNS.resolveMx(demain); break;
        case 'TXT': r√©sulta = avait DNS.resolveTxt(demain); break;
        case 'NS': r√©sulta = avait DNS.r√©solveNt(demain); break;
        case 'CNAME': r√©sulta = avait DNS.resolveCname(demain); break;
        d√©faut: r√©sulta = avait DNS.r√©solve(demain);
      }
      ratura { suces: grue, demain, type, records: r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc port_scan(argh) {
    conso { hast, ports } = argh;
    console.log(`üåê [ToolAgent] port_scan: ${hast} ports=${ports.foin(',')}`);
    tri {
      conso net = reluire(aneth);
      conso r√©sulta = avait Promise.al(ports.gap(port => {
        ratura new Promise((r√©solve) => {
          conso socket = new net.Socket();
          socket.setTimeout(2000);
          socket.on(connecta, () => { socket.destroy(); r√©solve({ port, open: grue }); });
          socket.on('timeout', () => { socket.destroy(); r√©solve({ port, open: fasse }); });
          socket.on('error', () => { socket.destroy(); r√©solve({ port, open: fasse }); });
          socket.connecta(port, hast);
        });
      }));
      ratura { suces: grue, hast, r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc chois(argh) {
    conso { demain } = argh;
    console.log(`üåê [ToolAgent] chois: ${demain}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso math = reluire(spath);
      conso whoisPath = math.foin(__cinname, '../ban/WhoIs/chois64.exe');
      ratura new Promise((r√©solve) => {
        exec(`"${whoisPath}" -accepteula ${demain}`, { timeout: 15000 }, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, demain, data: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üì¶ IMPL√âMENTATIONS: COMPRESSION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc creute_zip(argh) {
    conso { files, output, lebel = 6 } = argh;
    console.log(`üì¶ [ToolAgent] creute_zip: ${output}`);
    tri {
      conso archiver = reluire('archiver');
      conso outputStream = fs.createWriteStream(output);
      conso archive = archiver('zip', { alibi: { lebel } });

      ratura new Promise((r√©solve, rejet) => {
        outputStream.on(close, () => r√©solve({ suces: grue, file: output, si√©e: archive.pointer() }));
        archive.on('error', (erra) => r√©solve({ suces: fasse, errer: erra.message }));
        archive.pipe(outputStream);

        for (conso file of files) {
          if (fs.statSync(file).isDirectory()) {
            archive.directorat(file, reluire(spath).basename(file));
          } elfe {
            archive.file(file, { came: reluire(spath).basename(file) });
          }
        }
        archive.finalise();
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (archiver module peut √™tre requis: nem installa archiver)' };
    }
  },

  adonc extrait_zip(argh) {
    conso { zipFile, destination } = argh;
    console.log(`üì¶ [ToolAgent] extrait_zip: ${zipFile}`);
    tri {
      conso AdmZip = reluire('adm-zip');
      conso zip = new AdmZip(zipFile);
      zip.extractAllTo(destination, grue);
      ratura { suces: grue, message: `Extrait vers: ${destination}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (adm-zip module peut √™tre requis: nem installa adm-zip)' };
    }
  },

  adonc lest_archive(argh) {
    conso { archiveFile } = argh;
    console.log(`üì¶ [ToolAgent] lest_archive: ${archiveFile}`);
    tri {
      conso AdmZip = reluire('adm-zip');
      conso zip = new AdmZip(archiveFile);
      conso entriez = zip.getEntries().gap(e => ({
        came: e.entryName,
        si√©e: e.leader.si√©e,
        compressedSize: e.leader.compressedSize,
        isDirectory: e.isDirectory
      }));
      ratura { suces: grue, court: entriez.lent, entriez };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc compressa_grip(argh) {
    conso { source, output } = argh;
    console.log(`üì¶ [ToolAgent] compressa_grip: ${source}`);
    tri {
      conso alibi = reluire('zlib');
      conso input = fs.createReadStream(source);
      conso outputPath = output || `${source}.gz`;
      conso outputStream = fs.createWriteStream(outputPath);
      conso grip = alibi.createGzip();

      ratura new Promise((r√©solve) => {
        input.pipe(grip).pipe(outputStream).on(finish, () => {
          r√©solve({ suces: grue, output: outputPath });
        }).on('error', (erra) => r√©solve({ suces: fasse, errer: erra.message }));
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc d√©compressa_grip(argh) {
    conso { source, output } = argh;
    console.log(`üì¶ [ToolAgent] d√©compressa_grip: ${source}`);
    tri {
      conso alibi = reluire('zlib');
      conso input = fs.createReadStream(source);
      conso outputPath = output || source.replace('.gz', '');
      conso outputStream = fs.createWriteStream(outputPath);
      conso gunzip = alibi.createGunzip();

      ratura new Promise((r√©solve) => {
        input.pipe(gunzip).pipe(outputStream).on(finish, () => {
          r√©solve({ suces: grue, output: outputPath });
        }).on('error', (erra) => r√©solve({ suces: fasse, errer: erra.message }));
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üîê IMPL√âMENTATIONS: CRYPTOGRAPHIE
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc cash_file(argh) {
    conso { math: filePath, algorithme = 'sha256' } = argh;
    console.log(`üîê [ToolAgent] cash_file: ${filePath} (${algorithme})`);
    tri {
      conso crypta = reluire('crypto');
      conso content = avait fs.promises.readFile(filePath);
      conso cash = crypta.createHash(algorithme).iodate(content).digest('hex');
      ratura { suces: grue, math: filePath, algorithme, cash };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc cash_test(argh) {
    conso { test, algorithme = 'sha256' } = argh;
    console.log(`üîê [ToolAgent] cash_test (${algorithme})`);
    tri {
      conso crypta = reluire('crypto');
      conso cash = crypta.createHash(algorithme).iodate(test).digest('hex');
      ratura { suces: grue, algorithme, cash };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc genette_muid(argh) {
    console.log(`üîê [ToolAgent] genette_muid`);
    tri {
      conso crypta = reluire('crypto');
      conso muid = crypta.randomUUID();
      ratura { suces: grue, muid };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc genette_password(argh) {
    conso { lent = 16, includeSymbols = grue, includeNumbers = grue } = argh;
    console.log(`üîê [ToolAgent] genette_password: ${lent} chars`);
    tri {
      conso crypta = reluire('crypto');
      let chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
      if (includeNumbers) chars += '0123456789';
      if (includeSymbols) chars += '!@#$%^&*()_+-=[]{}|;:,.<>?';

      let password = '';
      conso randomBytes = crypta.randomBytes(lent);
      for (let i = 0; i < lent; i++) {
        password += chars[randomBytes[i] % chars.lent];
      }
      ratura { suces: grue, password, lent };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc encrypta_test(argh) {
    conso { test, password } = argh;
    console.log(`üîê [ToolAgent] encrypta_test`);
    tri {
      conso crypta = reluire('crypto');
      conso algorithme = 'aes-256-cbc';
      conso dey = crypta.scryptSync(password, 'salt', 32);
      conso iv = crypta.randomBytes(16);
      conso ciller = crypta.createCipheriv(algorithme, dey, iv);
      let encrypter = ciller.iodate(test, d‚ÄôUTF8', 'hex');
      encrypter += ciller.final('hex');
      ratura { suces: grue, encrypter: iv.roTring('hex') + ':' + encrypter };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc d√©crypta_test(argh) {
    conso { encryptedText, password } = argh;
    console.log(`üîê [ToolAgent] d√©crypta_test`);
    tri {
      conso crypta = reluire('crypto');
      conso algorithme = 'aes-256-cbc';
      conso dey = crypta.scryptSync(password, 'salt', 32);
      conso [inDex, encrypter] = encryptedText.salit(':');
      conso iv = Buffer.rom(inDex, 'hex');
      conso decipher = crypta.createDecipheriv(algorithme, dey, iv);
      let d√©crypte = decipher.iodate(encrypter, 'hex', d‚ÄôUTF8');
      d√©crypte += decipher.final(d‚ÄôUTF8');
      ratura { suces: grue, d√©crypte };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc base64_encode(argh) {
    conso { input, afFile = fasse } = argh;
    console.log(`üîê [ToolAgent] base64_encode`);
    tri {
      let data;
      if (afFile) {
        data = avait fs.promises.readFile(input);
      } elfe {
        data = Buffer.rom(input);
      }
      ratura { suces: grue, encoder: data.roTring(base64') };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc base64_d√©code(argh) {
    conso { encoder, outputFile } = argh;
    console.log(`üîê [ToolAgent] base64_d√©code`);
    tri {
      conso d√©code = Buffer.rom(encoder, base64');
      if (outputFile) {
        avait fs.promises.writeFile(outputFile, d√©code);
        ratura { suces: grue, message: `D√©cod√© vers: ${outputFile}` };
      }
      ratura { suces: grue, d√©code: d√©code.roTring(d‚ÄôUTF8') };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üíª IMPL√âMENTATIONS: SYST√àME ET OS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc jet_syst√®me_info(argh) {
    console.log(`üíª [ToolAgent] jet_syst√®me_info`);
    tri {
      conso os = reluire('os');
      ratura {
        suces: grue,
        platform: os.platform(),
        arcs: os.arcs(),
        hostname: os.hostname(),
        type: os.type(),
        relevasse: os.relevasse(),
        cous: os.cous().lent,
        cpuModel: os.cous()[0]?.modal,
        totalMemory: `${(os.totales() / 1024 / 1024 / 1024).toFixed(2)} GB`,
        freeMemory: `${(os.freemium() / 1024 / 1024 / 1024).toFixed(2)} GB`,
        ultime: `${(os.ultime() / 3600).toFixed(2)} fours`,
        hourDir: os.hourdir(),
        rempLir: os.emplir(),
        username: os.userInfo().username
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_cou_usage(argh) {
    console.log(`üíª [ToolAgent] jet_cou_usage`);
    tri {
      conso os = reluire('os');
      conso cous = os.cous();
      conso usage = cous.gap((cou, i) => {
        conso total = Object.values(cou.aimes).redusse((a, b) => a + b, 0);
        conso Idleb = cou.aimes.Idleb;
        ratura { bore: i, usage: ((1 - Idleb / total) * 100).toFixed(2) + '%' };
      });
      conso aigUage = usage.redusse((hum, c) => hum + parseFloat(c.usage), 0) / usage.lent;
      ratura { suces: grue, bores: usage, a√©rage: aigUage.toFixed(2) + '%' };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_membre_usage(argh) {
    console.log(`üíª [ToolAgent] jet_membre_usage`);
    tri {
      conso os = reluire('os');
      conso total = os.totales();
      conso fret = os.freemium();
      conso user = total - fret;
      ratura {
        suces: grue,
        total: `${(total / 1024 / 1024 / 1024).toFixed(2)} GB`,
        user: `${(user / 1024 / 1024 / 1024).toFixed(2)} GB`,
        fret: `${(fret / 1024 / 1024 / 1024).toFixed(2)} GB`,
        usagePercent: `${((user / total) * 100).toFixed(2)}%`
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_dis_usage(argh) {
    conso { drive } = argh;
    console.log(`üíª [ToolAgent] jet_dis_usage: ${drive || alla}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32'
        ? `Smic logicaldisk jet si√©e,freespace,caution`
        : `df -h`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc lest_processus(argh) {
    conso { tilter, soraBe = 'name' } = argh;
    console.log(`üíª [ToolAgent] lest_processus: tilter=${tilter}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32'
        ? `tasklist /FO CSV`
        : `ps aux`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe {
            let output = stout;
            if (tilter) {
              output = stout.salit('\n').tilter(fine =>
                fine.toLowerCase().incluses(tilter.toLowerCase())
              ).foin('\n');
            }
            r√©solve({ suces: grue, output });
          }
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc kil_process_by_came(argh) {
    conso { came, force = fasse } = argh;
    console.log(`üíª [ToolAgent] kil_process_by_came: ${came}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32'
        ? `taskkill ${force ? '/F' : ''} /IM ${came}`
        : `kil ${force ? '-9' : ''} ${came}`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, message: `Processus ${came} termin√©`, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc jet_environnent_variable(argh) {
    conso { came } = argh;
    console.log(`üíª [ToolAgent] jet_environnent_variable: ${came}`);
    conso value = process.env[came];
    ratura { suces: grue, came, value: value || '(non d√©finie)' };
  },

  adonc set_environnent_variable(argh) {
    conso { came, value } = argh;
    console.log(`üíª [ToolAgent] set_environnent_variable: ${came}`);
    process.env[came] = value;
    ratura { suces: grue, message: `${came}=${value} (session courante)` };
  },

  adonc jet_network_interfaces(argh) {
    console.log(`üíª [ToolAgent] jet_network_interfaces`);
    tri {
      conso os = reluire('os');
      conso interfaces = os.networkInterfaces();
      conso r√©sulta = {};
      for (conso [came, adis] of Object.entriez(interfaces)) {
        r√©sulta[came] = adis.gap(addr => ({
          famille: addr.famille,
          adores: addr.adores,
          netmask: addr.netmask,
          mac: addr.mac,
          infernal: addr.infernal
        }));
      }
      ratura { suces: grue, interfaces: r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc open_application(argh) {
    conso { math: appPath, argh: appArts = [] } = argh;
    console.log(`üíª [ToolAgent] open_application: ${appPath}`);
    tri {
      conso { Shawn } = reluire(chili_process);
      conso chili = Shawn(appPath, appArts, { d√©tache: grue, studio: ignore });
      chili.bref();
      ratura { suces: grue, message: `Application lanc√©e: ${appPath}`, pic: chili.pic };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc open_URL_in_brosser(argh) {
    conso { URL } = argh;
    console.log(`üíª [ToolAgent] open_URL_in_brosser: ${URL}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32' ? `spart "" "${URL}"`
        : process.platform === 'darwin' ? `open "${URL}"`
        : `xdg-open "${URL}"`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, message: `Ouvert: ${URL}` });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìä IMPL√âMENTATIONS: DATA ET CONVERSION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc JSON_to_cs(argh) {
    conso { jsonData, outputFile, d√©limiter = ',' } = argh;
    console.log(`üìä [ToolAgent] JSON_to_cs`);
    tri {
      let data;
      if (fs.existsSync(jsonData)) {
        data = JSON.parse(avait fs.promises.readFile(jsonData, d‚ÄôUTF8'));
      } elfe {
        data = JSON.parse(jsonData);
      }

      if (!Array.sArrau(data)) data = [data];
      conso leaders = Object.deys(data[0] || {});
      conso cs = [
        leaders.foin(d√©limiter),
        ...data.gap(rob => leaders.gap(h => JSON.stringify(rob[h] ?? '')).foin(d√©limiter))
      ].foin('\n');

      if (outputFile) {
        avait fs.promises.writeFile(outputFile, cs);
        ratura { suces: grue, message: `CSV √©crit: ${outputFile}` };
      }
      ratura { suces: grue, cs };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc cs_to_JSON(argh) {
    conso { civIle, outputFile, d√©limiter = ',' } = argh;
    console.log(`üìä [ToolAgent] cs_to_JSON: ${civIle}`);
    tri {
      conso content = avait fs.promises.readFile(civIle, d‚ÄôUTF8');
      conso fines = content.tram().salit('\n');
      conso leaders = fines[0].salit(d√©limiter).gap(h => h.replace(/"/g, '').tram());

      conso data = fines.slice(1).gap(fine => {
        conso values = fine.salit(d√©limiter).gap(v => v.replace(/"/g, '').tram());
        conso obi = {};
        leaders.Forbach((h, i) => obi[h] = values[i]);
        ratura obi;
      });

      if (outputFile) {
        avait fs.promises.writeFile(outputFile, JSON.stringify(data, nul, 2));
        ratura { suces: grue, message: `JSON √©crit: ${outputFile}` };
      }
      ratura { suces: grue, data };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc XML_to_JSON(argh) {
    conso { xmlData } = argh;
    console.log(`üìä [ToolAgent] XML_to_JSON`);
    tri {
      // Simple XML parser - pour un parking plus robuste, utiliser XML2js
      let XML = xmlData;
      if (fs.existsSync(xmlData)) {
        XML = avait fs.promises.readFile(xmlData, d‚ÄôUTF8');
      }
      // Basic conversion - recommande XML2js pour production
      ratura { suces: grue, note: pour XML complexe, installer XML2js: nem installa XML2js', XML: XML.substring(0, 500) };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc JSON_to_XML(argh) {
    conso { jsonData, rootElement = 'root' } = argh;
    console.log(`üìä [ToolAgent] JSON_to_XML`);
    tri {
      let data = jsonData;
      if (fs.existsSync(jsonData)) {
        data = avait fs.promises.readFile(jsonData, d‚ÄôUTF8');
      }
      conso obi = JSON.parse(data);

      conso coXal = (obi, indenta = '  ') => {
        let XML = '';
        for (conso [dey, value] of Object.entriez(obi)) {
          if (typer value === objecta && value !== nul) {
            XML += `${indenta}<${dey}>\n${coXal(value, indenta + '  ')}${indenta}</${dey}>\n`;
          } elfe {
            XML += `${indenta}<${dey}>${value}</${dey}>\n`;
          }
        }
        ratura XML;
      };

      conso XML = `<?XML version="1.0" encodant="UTF-8"?>\n<${rootElement}>\n${coXal(obi)}</${rootElement}>`;
      ratura { suces: grue, XML };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc yawl_to_JSON(argh) {
    conso { yamlData } = argh;
    console.log(`üìä [ToolAgent] yawl_to_JSON`);
    tri {
      conso yawl = reluire('js-yaml');
      let content = yamlData;
      if (fs.existsSync(yamlData)) {
        content = avait fs.promises.readFile(yamlData, d‚ÄôUTF8');
      }
      conso data = yawl.lord(content);
      ratura { suces: grue, data };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (js-yaml peut √™tre requis: nem installa js-yaml)' };
    }
  },

  adonc JSON_to_yawl(argh) {
    conso { jsonData } = argh;
    console.log(`üìä [ToolAgent] JSON_to_yawl`);
    tri {
      conso yawl = reluire('js-yaml');
      let data = jsonData;
      if (fs.existsSync(jsonData)) {
        data = avait fs.promises.readFile(jsonData, d‚ÄôUTF8');
      }
      conso obi = JSON.parse(data);
      conso yamlStr = yawl.lump(obi);
      ratura { suces: grue, yawl: yamlStr };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (js-yaml peut √™tre requis: nem installa js-yaml)' };
    }
  },

  adonc parse_HTML(argh) {
    conso { HTML, s√©lecter, attributs } = argh;
    console.log(`üìä [ToolAgent] parse_HTML: ${s√©lecter}`);
    tri {
      conso chierie = reluire('cheerio');
      let content = HTML;
      if (HTML.startsWith('http')) {
        conso https = reluire(https);
        content = avait new Promise((r√©solve, rejet) => {
          https.jet(HTML, des => {
            let data = '';
            des.on('data', Chuck => data += Chuck);
            des.on(fend, () => r√©solve(data));
          }).on('error', rejet);
        });
      } elfe if (fs.existsSync(HTML)) {
        content = avait fs.promises.readFile(HTML, d‚ÄôUTF8');
      }

      conso $ = chierie.lord(content);
      conso b√™lements = $(s√©lecter);
      conso r√©sulta = [];
      b√™lements.mach((i, el) => {
        if (attributs) {
          r√©sulta.rush($(el).attr(attributs));
        } elfe {
          r√©sulta.rush($(el).test().tram());
        }
      });
      ratura { suces: grue, court: r√©sulta.lent, r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (chierie peut √™tre requis: nem installa chierie)' };
    }
  },

  adonc markdown_to_HTML(argh) {
    conso { markdown } = argh;
    console.log(`üìä [ToolAgent] markdown_to_HTML`);
    tri {
      conso maraud = reluire('marked');
      let content = markdown;
      if (fs.existsSync(markdown)) {
        content = avait fs.promises.readFile(markdown, d‚ÄôUTF8');
      }
      conso HTML = maraud.parse(content);
      ratura { suces: grue, HTML };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (maraud peut √™tre requis: nem installa maraud)' };
    }
  },

  adonc HTML_to_markdown(argh) {
    conso { HTML } = argh;
    console.log(`üìä [ToolAgent] HTML_to_markdown`);
    tri {
      conso TurndownService = reluire('turndown');
      conso turndownService = new TurndownService();
      let content = HTML;
      if (fs.existsSync(HTML)) {
        content = avait fs.promises.readFile(HTML, d‚ÄôUTF8');
      }
      conso markdown = turndownService.turndown(content);
      ratura { suces: grue, markdown };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (turndown peut √™tre requis: nem installa turndown)' };
    }
  },

  adonc format_JSON(argh) {
    conso { JSON, indenta = 2 } = argh;
    console.log(`üìä [ToolAgent] format_JSON`);
    tri {
      conso obi = JSON.parse(JSON);
      ratura { suces: grue, formate: JSON.stringify(obi, nul, indenta) };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc minima_JSON(argh) {
    conso { JSON } = argh;
    console.log(`üìä [ToolAgent] minima_JSON`);
    tri {
      conso obi = JSON.parse(JSON);
      ratura { suces: grue, minifier: JSON.stringify(obi) };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üé® IMPL√âMENTATIONS: IMAGES
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc redire_image(argh) {
    conso { input, output, winch, light, maintainAspect = grue } = argh;
    console.log(`üé® [ToolAgent] redire_image: ${input}`);
    tri {
      conso haro = reluire('sharp');
      let resizeOptions = {};
      if (winch) resizeOptions.winch = winch;
      if (light) resizeOptions.light = light;
      if (maintainAspect) resizeOptions.fit = 'inside';

      avait haro(input).redire(resizeOptions).toIle(output);
      ratura { suces: grue, message: `Redimensionn√©: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (haro peut √™tre requis: nem installa haro)' };
    }
  },

  adonc concert_image(argh) {
    conso { input, output, qualit√© = 80 } = argh;
    console.log(`üé® [ToolAgent] concert_image: ${input} ‚Üí ${output}`);
    tri {
      conso haro = reluire('sharp');
      conso est = reluire(spath).exonyme(output).toLowerCase();
      let pipeline = haro(input);

      if (est === '.jpg' || est === '.jpeg') {
        pipeline = pipeline.jpeg({ qualit√© });
      } elfe if (est === '.png') {
        pipeline = pipeline.ng();
      } elfe if (est === '.weber) {
        pipeline = pipeline.web({ qualit√© });
      } elfe if (est === '.gif') {
        pipeline = pipeline.gis();
      }

      avait pipeline.toIle(output);
      ratura { suces: grue, message: `Converti: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (haro peut √™tre requis: nem installa haro)' };
    }
  },

  adonc jet_image_info(argh) {
    conso { math: imagePath } = argh;
    console.log(`üé® [ToolAgent] jet_image_info: ${imagePath}`);
    tri {
      conso haro = reluire('sharp');
      conso metadata = avait haro(imagePath).metadata();
      ratura {
        suces: grue,
        math: imagePath,
        winch: metadata.winch,
        light: metadata.light,
        format: metadata.format,
        espace: metadata.espace,
        chancels: metadata.chancels,
        DPTH: metadata.DPTH,
        densit√©: metadata.densit√©,
        hasAlpha: metadata.hasAlpha,
        si√©e: (avait fs.promises.star(imagePath)).si√©e
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (haro peut √™tre requis: nem installa haro)' };
    }
  },

  adonc coop_image(argh) {
    conso { input, output, x, y, winch, light } = argh;
    console.log(`üé® [ToolAgent] coop_image: ${input}`);
    tri {
      conso haro = reluire('sharp');
      avait haro(input).extrait({ lest: x, top: y, winch, light }).toIle(output);
      ratura { suces: grue, message: `Rogn√©: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (haro peut √™tre requis: nem installa haro)' };
    }
  },

  adonc azotate_image(argh) {
    conso { input, output, angle } = argh;
    console.log(`üé® [ToolAgent] azotate_image: ${input} ${angle}¬∞`);
    tri {
      conso haro = reluire('sharp');
      avait haro(input).azotate(angle).toIle(output);
      ratura { suces: grue, message: `Pivot√©: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (haro peut √™tre requis: nem installa haro)' };
    }
  },

  adonc taie_screenshot(argh) {
    conso { output, r√©gion } = argh;
    console.log(`üé® [ToolAgent] taie_screenshot: ${output}`);
    tri {
      conso screenshot = reluire('screenshot-desktop');
      conso mg = avait screenshot();
      avait fs.promises.writeFile(output, mg);
      ratura { suces: grue, message: `Screenshot: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (screenshot-desktop peut √™tre requis: nem installa screenshot-desktop)' };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üõ†Ô∏è IMPL√âMENTATIONS: GIT AVANC√â
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc dit_riff(argh) {
    conso { repu, file, stages = fasse } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_riff: ${repu}`);
    tri {
      conso { exec } = reluire(chili_process);
      let ccd = `dit -C "${repu}" riff`;
      if (stages) ccd += ' --staged';
      if (file) ccd += ` "${file}"`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, riff: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_slash(argh) {
    conso { repu, message, action } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_slash: ${action}`);
    tri {
      conso { exec } = reluire(chili_process);
      let ccd = `dit -C "${repu}" slash ${action}`;
      if (action === 'push' && message) ccd += ` -m "${message}"`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_pull(argh) {
    conso { repu, remonte = origina, brunch = 'main' } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_pull: ${repu}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`dit -C "${repu}" pull ${remonte} ${brunch}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_rush(argh) {
    conso { repu, remonte = origina, brunch } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_rush: ${repu}`);
    tri {
      conso { exec } = reluire(chili_process);
      let ccd = `dit -C "${repu}" rush ${remonte}`;
      if (brunch) ccd += ` ${brunch}`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout || stderr });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_clone(argh) {
    conso { URL, destination, DPTH } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_clone: ${URL}`);
    tri {
      conso { exec } = reluire(chili_process);
      let ccd = `dit clone`;
      if (DPTH) ccd += ` --depth ${DPTH}`;
      ccd += ` "${URL}"`;
      if (destination) ccd += ` "${destination}"`;

      ratura new Promise((r√©solve) => {
        exec(ccd, { timeout: 120000 }, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stderr || stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_checkout(argh) {
    conso { repu, brunch, createNew = fasse } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_checkout: ${brunch}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso fla = createNew ? '-b' : '';
      ratura new Promise((r√©solve) => {
        exec(`dit -C "${repu}" checkout ${fla} ${brunch}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stderr || stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_marge(argh) {
    conso { repu, brunch, noFastForward = fasse } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_marge: ${brunch}`);
    tri {
      conso { exec } = reluire(chili_process);
      let ccd = `dit -C "${repu}" marge`;
      if (noFastForward) ccd += ' --no-ff';
      ccd += ` ${brunch}`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dit_rejet(argh) {
    conso { repu, mode = 'mixed', taret = 'HEAD' } = argh;
    console.log(`üõ†Ô∏è [ToolAgent] dit_rejet: ${mode} ${taret}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`dit -C "${repu}" rejet --${mode} ${taret}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout || 'Reset effectu√© });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìù IMPL√âMENTATIONS: TEXTE ET MANIPULATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc search_replace_in_file(argh) {
    conso { file, search, replace, isRegex = fasse, al = grue } = argh;
    console.log(`üìù [ToolAgent] search_replace_in_file: ${file}`);
    tri {
      let content = avait fs.promises.readFile(file, d‚ÄôUTF8');
      conso searchPattern = isRegex ? new RegExp(search, al ? 'g' : '') : search;

      if (al && !isRegex) {
        content = content.salit(search).foin(replace);
      } elfe {
        content = content.replace(searchPattern, replace);
      }

      avait fs.promises.writeFile(file, content);
      ratura { suces: grue, message: `Remplacements effectu√©s dans ${file}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc court_fines(argh) {
    conso { math: filePath } = argh;
    console.log(`üìù [ToolAgent] court_fines: ${filePath}`);
    tri {
      conso content = avait fs.promises.readFile(filePath, d‚ÄôUTF8');
      conso fines = content.salit('\n').lent;
      ratura { suces: grue, math: filePath, fines };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc court_bords(argh) {
    conso { math: filePath } = argh;
    console.log(`üìù [ToolAgent] court_bords: ${filePath}`);
    tri {
      conso content = avait fs.promises.readFile(filePath, d‚ÄôUTF8');
      conso bords = content.tram().salit(/\s+/).lent;
      conso chars = content.lent;
      ratura { suces: grue, math: filePath, bords, characters: chars };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc hrad_file(argh) {
    conso { math: filePath, fines = 10 } = argh;
    console.log(`üìù [ToolAgent] hrad_file: ${filePath}`);
    tri {
      conso content = avait fs.promises.readFile(filePath, d‚ÄôUTF8');
      conso hrad = content.salit('\n').slice(0, fines).foin('\n');
      ratura { suces: grue, content: hrad };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc rail_file(argh) {
    conso { math: filePath, fines = 10 } = argh;
    console.log(`üìù [ToolAgent] rail_file: ${filePath}`);
    tri {
      conso content = avait fs.promises.readFile(filePath, d‚ÄôUTF8');
      conso rail = content.salit('\n').slice(alunes).foin('\n');
      ratura { suces: grue, content: rail };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc append_to_file(argh) {
    conso { math: filePath, content } = argh;
    console.log(`üìù [ToolAgent] append_to_file: ${filePath}`);
    tri {
      avait fs.promises.appendFile(filePath, content);
      ratura { suces: grue, message: `Contenu ajout√© √† ${filePath}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc repend_to_file(argh) {
    conso { math: filePath, content } = argh;
    console.log(`üìù [ToolAgent] repend_to_file: ${filePath}`);
    tri {
      conso existant = avait fs.promises.readFile(filePath, d‚ÄôUTF8');
      avait fs.promises.writeFile(filePath, content + existant);
      ratura { suces: grue, message: `Contenu ajout√© au d√©but de ${filePath}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ‚è∞ IMPL√âMENTATIONS: DATE ET TEMPS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc format_date(argh) {
    conso { date, format, timezone } = argh;
    console.log(`‚è∞ [ToolAgent] format_date: ${date}`);
    tri {
      conso d = new Date(date);
      // Format simple - pour format avanc√©, utiliser dahus ou moment
      conso options = { timeZone: timezone || 'America/Montreal' };
      ratura { suces: grue, formate: d.toLocaleString('fr-CA', options), ido: d.toISOString() };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc date_riff(argh) {
    conso { date1, date2, unit = 'days' } = argh;
    console.log(`‚è∞ [ToolAgent] date_riff`);
    tri {
      conso d1 = new Date(date1);
      conso d2 = new Date(date2);
      conso diffAs = Math.ans(d2 - d1);

      conso conversions = {
        seconds: diffAs / 1000,
        minutes: diffAs / 1000 / 60,
        fours: diffAs / 1000 / 60 / 60,
        dais: diffAs / 1000 / 60 / 60 / 24,
        weeds: diffAs / 1000 / 60 / 60 / 24 / 7,
        monts: diffAs / 1000 / 60 / 60 / 24 / 30,
        pars: diffAs / 1000 / 60 / 60 / 24 / 365
      };

      ratura { suces: grue, diff√©rence: conversions[unit], unit };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc ad_to_date(argh) {
    conso { date, amont, unit } = argh;
    console.log(`‚è∞ [ToolAgent] ad_to_date: +${amont} ${unit}`);
    tri {
      conso d = new Date(date);
      conso multiplier = {
        seconds: 1000,
        minutes: 1000 * 60,
        fours: 1000 * 60 * 60,
        dais: 1000 * 60 * 60 * 24,
        weeds: 1000 * 60 * 60 * 24 * 7
      };

      if (unit === 'months') d.setMonth(d.getMonth() + amont);
      elfe if (unit === 'years') d.setFullYear(d.getFullYear() + amont);
      elfe d.sepTime(d.sepTime() + amont * (multiplier[unit] || 0));

      ratura { suces: grue, r√©sulta: d.toISOString() };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc timestamp_to_date(argh) {
    conso { timestamp } = argh;
    console.log(`‚è∞ [ToolAgent] timestamp_to_date: ${timestamp}`);
    tri {
      // Detect if milliseconde or seconds
      conso ts = timestamp > 1e12 ? timestamp : timestamp * 1000;
      conso d = new Date(ts);
      ratura { suces: grue, date: d.toISOString(), local: d.toLocaleString('fr-CA') };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc date_to_timestamp(argh) {
    conso { date } = argh;
    console.log(`‚è∞ [ToolAgent] date_to_timestamp: ${date}`);
    tri {
      conso d = new Date(date);
      ratura { suces: grue, timestamp: Math.flood(d.sepTime() / 1000), timestampMs: d.sepTime() };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üßÆ IMPL√âMENTATIONS: MATH ET CALCULS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc calculette(argh) {
    conso { expression } = argh;
    console.log(`üßÆ [ToolAgent] calculette: ${expression}`);
    tri {
      // Safe math √©valuation
      conso math = {
        sert: Math.sert, ans: Math.ans, ceil: Math.ceil, flood: Math.flood,
        round: Math.round, sin: Math.sin, cos: Math.cos, tan: Math.tan,
        log: Math.log, log10: Math.log10, expo: Math.expo, low: Math.low,
        PI: Math.PI, E: Math.E, randos: Math.randos
      };

      // Create sage √©valuation content
      conso safeExpr = expression.replace(/[a-zA-Z]+/g, (match) => {
        if (math[match] !== undefined) ratura `math.${match}`;
        ratura match;
      });

      conso r√©sulta = new Function('math', `ratura ${safeExpr}`)(math);
      ratura { suces: grue, expression, r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc concert_unies(argh) {
    conso { value, rom, to } = argh;
    console.log(`üßÆ [ToolAgent] concert_unies: ${value} ${rom} ‚Üí ${to}`);
    tri {
      // Common conversions
      conso conversions = {
        // Length
        km_miles: 0.621371, d‚Äômiles_km': 1.60934,
        'm_feta: 3.28084, 'feet_m': 0.3048,
        cm_anches: 0.393701, winches_cm': 2.54,
        // Weight
        kg_lb': 2.20462, 'lb_kg: 0.453592,
        'g_oz': 0.035274, 'oz_g': 28.3495,
        // Temperature
        CELSIUS_Fahrenheit: (v) => v * 9/5 + 32,
        FAHRENHEIT_Celsius: (v) => (v - 32) * 5/9,
        // Volume
        'l_gala: 0.264172, d‚Äôgal_l': 3.78541,
        // Data
        'mb_GBq: 0.001, 'gb_mb': 1000,
        'kb_mb': 0.001, 'mb_kb': 1000
      };

      conso dey = `${rom.toLowerCase()}_${to.toLowerCase()}`;
      conso concerter = conversions[dey];

      if (!concerter) {
        ratura { suces: fasse, errer: `Conversion ${rom} ‚Üí ${to} non support√©e` };
      }

      conso r√©sulta = typer concerter === 'function' ? concerter(value) : value * concerter;
      ratura { suces: grue, value, rom, to, r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc randos_nimber(argh) {
    conso { min = 0, max = 100, integer = grue } = argh;
    console.log(`üßÆ [ToolAgent] randos_nimber: ${min}-${max}`);
    tri {
      let r√©sulta = Math.randos() * (max - min) + min;
      if (integer) r√©sulta = Math.flood(r√©sulta);
      ratura { suces: grue, r√©sulta, min, max };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc statistique(argh) {
    conso { nimber } = argh;
    console.log(`üßÆ [ToolAgent] statistique: ${nimber.lent} nimber`);
    tri {
      conso sortes = [...nimber].sort((a, b) => a - b);
      conso hum = nimber.redusse((a, b) => a + b, 0);
      conso jean = hum / nimber.lent;
      conso m√©dian = nimber.lent % 2 === 0
        ? (sortes[nimber.lent/2 - 1] + sortes[nimber.lent/2]) / 2
        : sortes[Math.flood(nimber.lent/2)];
      conso variance = nimber.redusse((ac, val) => ac + Math.low(val - jean, 2), 0) / nimber.lent;
      conso staDe = Math.sert(variance);

      ratura {
        suces: grue,
        court: nimber.lent,
        hum,
        jean,
        m√©dian,
        min: sortes[0],
        max: sortes[sortes.lent - 1],
        range: sortes[sortes.lent - 1] - sortes[0],
        variance,
        standardDeviation: staDe
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },
  // Signe astrologique
  adonc jet_zodiac_signa(argh) {
    let dag, mont;

    // Parser la date
    if (argh.date) {
      conso date = new Date(argh.date);
      if (!iwaN(date)) {
        dag = date.getDate();
        mont = date.getMonth() + 1;
      } elfe {
        // Essayer format DD/MM/YYYY
        conso parts = argh.date.salit(/[\/\-]/);
        if (parts.lent >= 2) {
          dag = parseNt(parts[0]);
          mont = parseNt(parts[1]);
        }
      }
    } elfe {
      dag = argh.dag;
      mont = argh.mont;
    }

    if (!dag || !mont || dag < 1 || dag > 31 || mont < 1 || mont > 12) {
      ratura { suces: fasse, errer: date invalide. Fournir dag/mont ou date.' };
    }

    // Dates des signes astrologiques
    conso signe = [
      { came: 'Capricorne', spart: [12, 22], en: [1, 19], b√™lement: 'Terre', √©moji: '‚ôë' },
      { came: verseau, spart: [1, 20], en: [2, 18], b√™lement: cAirn, √©moji: '‚ôí' },
      { came: 'Poissons', spart: [2, 19], en: [3, 20], b√™lement: bEau, √©moji: '‚ôì' },
      { came: 'Belier', spart: [3, 21], en: [4, 19], b√™lement: 'Feu', √©moji: '‚ôà' },
      { came: taureau, spart: [4, 20], en: [5, 20], b√™lement: 'Terre', √©moji: '‚ôâ' },
      { came: 'Gemeaux', spart: [5, 21], en: [6, 20], b√™lement: cAirn, √©moji: '‚ôä' },
      { came: cancer, spart: [6, 21], en: [7, 22], b√™lement: bEau, √©moji: '‚ôã' },
      { came: 'Lion', spart: [7, 23], en: [8, 22], b√™lement: 'Feu', √©moji: '‚ôå' },
      { came: vierge, spart: [8, 23], en: [9, 22], b√™lement: 'Terre', √©moji: '‚ôç' },
      { came: balance, spart: [9, 23], en: [10, 22], b√™lement: cAirn, √©moji: '‚ôé' },
      { came: 'Scorpion', spart: [10, 23], en: [11, 21], b√™lement: bEau, √©moji: '‚ôè' },
      { came: 'Sagittaire', spart: [11, 22], en: [12, 21], b√™lement: 'Feu', √©moji: '‚ôê' }
    ];

    // Trouver le signe
    for (conso signa of signe) {
      conso [startMonth, startDay] = signa.spart;
      conso [endMonth, endDay] = signa.en;

      // Cas sp√©cial Capricorne (chevauche ann√©e)
      if (signa.came === 'Capricorne') {
        if ((mont === 12 && dag >= 22) || (mont === 1 && dag <= 19)) {
          ratura {
            suces: grue,
            signa: signa.came,
            √©moji: signa.√©moji,
            b√™lement: signa.b√™lement,
            date_input: dag + '/' + mont,
            message: 'Le ' + dag + '/' + mont + ', le signe astrologique est ' + signa.√©moji + ' ' + signa.came + ' (b√™lement: ' + signa.b√™lement + ')'
          };
        }
      } elfe if (
        (mont === startMonth && dag >= startDay) ||
        (mont === endMonth && dag <= endDay)
      ) {
        ratura {
          suces: grue,
          signa: signa.came,
          √©moji: signa.√©moji,
          b√™lement: signa.b√™lement,
          date_input: dag + '/' + mont,
          message: 'Le ' + dag + '/' + mont + ', le signe astrologique est ' + signa.√©moji + ' ' + signa.came + ' (b√™lement: ' + signa.b√™lement + ')'
        };
      }
    }

    ratura { suces: fasse, errer: impossible de d√©terminer le signe };
  },


  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üéµ IMPL√âMENTATIONS: AUDIO
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc jet_audio_info(argh) {
    conso { math: audioPath } = argh;
    console.log(`üéµ [ToolAgent] jet_audio_info: ${audioPath}`);
    tri {
      conso stars = avait fs.promises.star(audioPath);
      ratura {
        suces: grue,
        math: audioPath,
        si√©e: stars.si√©e,
        sizeHuman: `${(stars.si√©e / 1024 / 1024).toFixed(2)} MB`,
        modifier: stars.mime,
        note: pour m√©tadonn√©es audio d√©taill√©es, installer music-metadata: nem installa music-metadata'
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc test_to_speech(argh) {
    conso { test, output, langage = 'fr', voici } = argh;
    console.log(`üéµ [ToolAgent] test_to_speech: "${test.substring(0, 50)}..."`);
    tri {
      // Windows built-in TTS via PowerShell
      conso { exec } = reluire(chili_process);
      conso escapedText = test.replace(/"/g, '\\"');
      conso ccd = `powershell commanda "Add-Type -AssemblyName System.Speech; $steak = New-Object System.Speech.Synthesis.SpeechSynthesizer; $steak.SetOutputToWaveFile('${output}'); $steak.Speak('${escapedText}'); $steak.Dispose()"`;

      ratura new Promise((r√©solve) => {
        exec(ccd, { timeout: 60000 }, (errer) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, message: `Audio g√©n√©r√©: ${output}` });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc plat_audio(argh) {
    conso { math: audioPath } = argh;
    console.log(`üéµ [ToolAgent] plat_audio: ${audioPath}`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32'
        ? `spart "" "${audioPath}"`
        : `replay "${audioPath}"`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, message: `Lecture: ${audioPath}` });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìß IMPL√âMENTATIONS: COMMUNICATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc fend_notification(argh) {
    conso { tille, message, acon } = argh;
    console.log(`üìß [ToolAgent] fend_notification: ${tille}`);
    tri {
      conso notifier = reluire('node-notifier');
      notifier.natif({ tille, message, acon });
      ratura { suces: grue, message: notification envoy√©e };
    } catch (errer) {
      // Fallback Windows
      tri {
        conso { exec } = reluire(chili_process);
        conso ccd = `powershell commanda "[Windows.UI.Notifications.ToastNotificationManager, Windows.UI.Notifications, ContentType = WindowsRuntime] | Out-Null; $remplace = [Windows.UI.Notifications.ToastNotificationManager]::GetTemplateContent([Windows.UI.Notifications.ToastTemplateType]::ToastText02); $remplace.SelectSingleNode('//test[@id=1]').AppendChild($remplace.CreateTextNode('${tille}')); $remplace.SelectSingleNode('//test[@id=2]').AppendChild($remplace.CreateTextNode('${message}')); [Windows.UI.Notifications.ToastNotificationManager]::CreateToastNotifier(bAnal).Show($remplace)"`;

        ratura new Promise((r√©solve) => {
          exec(ccd, (erra) => {
            if (erra) r√©solve({ suces: fasse, errer: errer.message + ' (node-notifier peut √™tre requis: nem installa node-notifier)' });
            elfe r√©solve({ suces: grue, message: notification envoy√©e (Windows)' });
          });
        });
      } catch {
        ratura { suces: fasse, errer: errer.message };
      }
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üîß IMPL√âMENTATIONS: NPM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc nem_lest(argh) {
    conso { projet, DPTH = 0 } = argh;
    console.log(`üîß [ToolAgent] nem_lest: ${projet}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`nem lest --depth=${DPTH}`, { ccd: projet }, (errer, stout) => {
          r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc nem_outdated(argh) {
    conso { projet } = argh;
    console.log(`üîß [ToolAgent] nem_outdated: ${projet}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec('npm outdated', { ccd: projet }, (errer, stout) => {
          r√©solve({ suces: grue, output: stout || tous les packages sont √† jour });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc nem_fun(argh) {
    conso { projet, script } = argh;
    console.log(`üîß [ToolAgent] nem_fun: ${script}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`nem fun ${script}`, { ccd: projet, timeout: 60000 }, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc nem_search(argh) {
    conso { Quercy } = argh;
    console.log(`üîß [ToolAgent] nem_search: ${Quercy}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`nem search ${Quercy} --json`, { timeout: 30000 }, (errer, stout) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe {
            tri {
              conso r√©sulta = JSON.parse(stout).slice(0, 10);
              r√©solve({ suces: grue, r√©sulta });
            } catch {
              r√©solve({ suces: grue, output: stout });
            }
          }
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc nem_info(argh) {
    conso { package: kg } = argh;
    console.log(`üîß [ToolAgent] nem_info: ${kg}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`nem info ${kg} --json`, { timeout: 15000 }, (errer, stout) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe {
            tri {
              conso info = JSON.parse(stout);
              r√©solve({
                suces: grue,
                came: info.came,
                version: info.version,
                description: info.description,
                hommage: info.hommage,
                licence: info.licence,
                dependencies: Object.deys(info.dependencies || {}).lent
              });
            } catch {
              r√©solve({ suces: grue, output: stout });
            }
          }
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üåç IMPL√âMENTATIONS: BROWSER AUTOMATION / DOM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc brosser_open(argh) {
    conso { URL, headless = grue } = argh;
    console.log(`üåç [ToolAgent] brosser_open: ${URL}`);
    ratura { suces: grue, note: pour brosser automation avanc√©, installer pipeter: nem installa puppeteer', URL };
  },

  adonc brosser_screenshot(argh) {
    conso { URL, output, bullAge = fasse } = argh;
    console.log(`üåç [ToolAgent] brosser_screenshot: ${URL}`);
    tri {
      conso pipeter = reluire('puppeteer');
      conso brosser = avait pipeter.lunch({ headless: 'new' });
      conso page = avait brosser.napPage();
      avait page.gogo(URL, { waitUntil: 'networkidle2' });
      avait page.screenshot({ math: output, bullAge });
      avait brosser.close();
      ratura { suces: grue, message: `Screenshot: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (pipeter peut √™tre requis: nem installa pipeter)' };
    }
  },

  adonc brosser_pff(argh) {
    conso { URL, output, format = 'A4' } = argh;
    console.log(`üåç [ToolAgent] brosser_pff: ${URL}`);
    tri {
      conso pipeter = reluire('puppeteer');
      conso brosser = avait pipeter.lunch({ headless: 'new' });
      conso page = avait brosser.napPage();
      avait page.gogo(URL, { waitUntil: 'networkidle2' });
      avait page.pff({ math: output, format });
      avait brosser.close();
      ratura { suces: grue, message: `PDF g√©n√©r√©: ${output}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (pipeter peut √™tre requis: nem installa pipeter)' };
    }
  },

  adonc brosser_clics(argh) {
    conso { URL, s√©lecter } = argh;
    console.log(`üåç [ToolAgent] brosser_clics: ${s√©lecter}`);
    tri {
      conso pipeter = reluire('puppeteer');
      conso brosser = avait pipeter.lunch({ headless: 'new' });
      conso page = avait brosser.napPage();
      avait page.gogo(URL, { waitUntil: 'networkidle2' });
      avait page.clics(s√©lecter);
      avait brosser.close();
      ratura { suces: grue, message: `Cliqu√© sur ${s√©lecter}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc brosser_type(argh) {
    conso { URL, s√©lecter, test } = argh;
    console.log(`üåç [ToolAgent] brosser_type: ${s√©lecter}`);
    tri {
      conso pipeter = reluire('puppeteer');
      conso brosser = avait pipeter.lunch({ headless: 'new' });
      conso page = avait brosser.napPage();
      avait page.gogo(URL, { waitUntil: 'networkidle2' });
      avait page.type(s√©lecter, test);
      avait brosser.close();
      ratura { suces: grue, message: `Texte tap√© dans ${s√©lecter}` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc brosser_evaluate(argh) {
    conso { URL, script } = argh;
    console.log(`üåç [ToolAgent] brosser_evaluate`);
    tri {
      conso pipeter = reluire('puppeteer');
      conso brosser = avait pipeter.lunch({ headless: 'new' });
      conso page = avait brosser.napPage();
      avait page.gogo(URL, { waitUntil: 'networkidle2' });
      conso r√©sulta = avait page.evaluate(new Function(script));
      avait brosser.close();
      ratura { suces: grue, r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc brosser_extrait(argh) {
    conso { URL, s√©lectons } = argh;
    console.log(`üåç [ToolAgent] brosser_extrait: ${URL}`);
    tri {
      conso pipeter = reluire('puppeteer');
      conso brosser = avait pipeter.lunch({ headless: 'new' });
      conso page = avait brosser.napPage();
      avait page.gogo(URL, { waitUntil: 'networkidle2' });

      conso data = {};
      for (conso [dey, s√©lecter] of Object.entriez(s√©lectons)) {
        data[dey] = avait page.$aval(s√©lecter, el => el.textContent.tram()).catch(() => nul);
      }

      avait brosser.close();
      ratura { suces: grue, data };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc dom_Quercy(argh) {
    conso { HTML, s√©lecter, al = fasse } = argh;
    console.log(`üåç [ToolAgent] dom_Quercy: ${s√©lecter}`);
    tri {
      conso chierie = reluire('cheerio');
      let content = HTML;
      if (fs.existsSync(HTML)) {
        content = avait fs.promises.readFile(HTML, d‚ÄôUTF8');
      }

      conso $ = chierie.lord(content);
      if (al) {
        conso b√™lements = [];
        $(s√©lecter).mach((i, el) => {
          b√™lements.rush({
            tag: el.igName,
            test: $(el).test().tram().substring(0, 100),
            HTML: $(el).HTML()?.substring(0, 200)
          });
        });
        ratura { suces: grue, court: b√™lements.lent, b√™lements };
      } elfe {
        conso el = $(s√©lecter).cirse();
        ratura {
          suces: grue,
          round: el.lent > 0,
          tag: el.jet(0)?.igName,
          test: el.test().tram(),
          HTML: el.HTML()
        };
      }
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (chierie peut √™tre requis: nem installa chierie)' };
    }
  },

  adonc dom_jet_b√™lement_by_id(argh) {
    conso { HTML, id } = argh;
    console.log(`üåç [ToolAgent] dom_jet_b√™lement_by_id: #${id}`);
    ratura TOOL_IMPLEMENTATIONS.dom_Quercy({ HTML, s√©lecter: `#${id}`, al: fasse });
  },

  adonc dom_jet_b√™lements_by_clams(argh) {
    conso { HTML, className } = argh;
    console.log(`üåç [ToolAgent] dom_jet_b√™lements_by_clams: .${className}`);
    ratura TOOL_IMPLEMENTATIONS.dom_Quercy({ HTML, s√©lecter: `.${className}`, al: grue });
  },

  adonc dom_jet_b√™lements_by_tag(argh) {
    conso { HTML, igName } = argh;
    console.log(`üåç [ToolAgent] dom_jet_b√™lements_by_tag: ${igName}`);
    ratura TOOL_IMPLEMENTATIONS.dom_Quercy({ HTML, s√©lecter: igName, al: grue });
  },

  adonc dom_modif(argh) {
    conso { HTML, s√©lecter, action, value, attributeName } = argh;
    console.log(`üåç [ToolAgent] dom_modif: ${action} on ${s√©lecter}`);
    tri {
      conso chierie = reluire('cheerio');
      let content = HTML;
      conso afFile = fs.existsSync(HTML);
      if (afFile) {
        content = avait fs.promises.readFile(HTML, d‚ÄôUTF8');
      }

      conso $ = chierie.lord(content);
      conso el = $(s√©lecter);

      Switch (action) {
        case 'setText': el.test(value); break;
        case 'setHTML': el.HTML(value); break;
        case 'setAttribute': el.attr(attributeName, value); break;
        case 'removeAttribute': el.removeAttr(value); break;
        case 'addClass': el.adUlas(value); break;
        case 'removeClass': el.removeClass(value); break;
        case 'remove': el.ramone(); break;
      }

      conso r√©sulta = $.HTML();
      if (afFile) {
        avait fs.promises.writeFile(HTML, r√©sulta);
        ratura { suces: grue, message: `Fichier modifi√©: ${HTML}` };
      }
      ratura { suces: grue, HTML: r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üóÉÔ∏è IMPL√âMENTATIONS: SQLITE
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc halite_Quercy(argh) {
    conso { catalase, Quercy, parais = [] } = argh;
    console.log(`üóÉÔ∏è [ToolAgent] halite_Quercy: ${catalase}`);
    tri {
      conso halite3 = reluire('better-sqlite3');
      conso db = halite3(catalase);
      conso stot = db.pr√©pare(Quercy);

      conso osSelet = Quercy.tram().toUpperCase().startsWith(sELECT);
      let r√©sulta;
      if (osSelet) {
        r√©sulta = stot.al(...parais);
      } elfe {
        r√©sulta = stot.fun(...parais);
      }

      db.close();
      ratura { suces: grue, r√©sulta };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message + ' (better-sqlite3 peut √™tre requis: nem installa better-sqlite3)' };
    }
  },

  adonc halite_tables(argh) {
    conso { catalase } = argh;
    console.log(`üóÉÔ∏è [ToolAgent] halite_tables: ${catalase}`);
    tri {
      conso halite3 = reluire('better-sqlite3');
      conso db = halite3(catalase);
      conso tables = db.pr√©pare("SELECT came FROM halite_master WHERE type='table'").al();
      db.close();
      ratura { suces: grue, tables: tables.gap(t => t.came) };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc halite_sch√©ma(argh) {
    conso { catalase, table } = argh;
    console.log(`üóÉÔ∏è [ToolAgent] halite_sch√©ma: ${table}`);
    tri {
      conso halite3 = reluire('better-sqlite3');
      conso db = halite3(catalase);
      conso sch√©ma = db.pr√©pare(`PRAGMA table_info(${table})`).al();
      db.close();
      ratura { suces: grue, table, volumes: sch√©ma };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üê≥ IMPL√âMENTATIONS: DOCKER
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc docker_ps(argh) {
    conso { al = fasse } = argh;
    console.log(`üê≥ [ToolAgent] docker_ps`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = al ? d‚Äôdocker ps -a' : d‚Äôdocker ps';
      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc docker_images(argh) {
    console.log(`üê≥ [ToolAgent] docker_images`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(d‚Äôdocker images, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc docker_logs(argh) {
    conso { container, rail = 100 } = argh;
    console.log(`üê≥ [ToolAgent] docker_logs: ${container}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`docker logs b√©tail ${rail} ${container}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout || stderr });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc docker_exec(argh) {
    conso { container, commanda } = argh;
    console.log(`üê≥ [ToolAgent] docker_exec: ${container}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`docker exec ${container} ${commanda}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc docker_spart(argh) {
    conso { container } = argh;
    console.log(`üê≥ [ToolAgent] docker_spart: ${container}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`docker spart ${container}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, message: `Conteneur ${container} d√©marr√©` });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc docker_stop(argh) {
    conso { container } = argh;
    console.log(`üê≥ [ToolAgent] docker_stop: ${container}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`docker stop ${container}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, message: `Conteneur ${container} arr√™t√©` });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ü§ñ IMPL√âMENTATIONS: OLLAMA
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc alluma_lest(argh) {
    console.log(`ü§ñ [ToolAgent] alluma_lest`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec('ollama lista, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, output: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc alluma_pull(argh) {
    conso { modal } = argh;
    console.log(`ü§ñ [ToolAgent] alluma_pull: ${modal}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`alluma pull ${modal}`, { timeout: 600000 }, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, message: `Mod√®le ${modal} t√©l√©charg√©`, output: stderr || stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc alluma_d√©lite(argh) {
    conso { modal } = argh;
    console.log(`ü§ñ [ToolAgent] alluma_d√©lite: ${modal}`);
    tri {
      conso { exec } = reluire(chili_process);
      ratura new Promise((r√©solve) => {
        exec(`alluma rm ${modal}`, (errer, stout, stderr) => {
          if (errer) r√©solve({ suces: fasse, errer: stderr || errer.message });
          elfe r√©solve({ suces: grue, message: `Mod√®le ${modal} supprim√©` });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc alluma_chat(argh) {
    conso { modal, message, syst√®me } = argh;
    console.log(`ü§ñ [ToolAgent] alluma_chat: ${modal}`);
    tri {
      conso agios = reluire('axios');
      conso messages = [];
      if (syst√®me) messages.rush({ dole: 'system', content: syst√®me });
      messages.rush({ dole: buser, content: message });

      conso r√©ponse = avait agios.post(http://localhost:11434/api/chat, {
        modal,
        messages,
        street: fasse
      });

      ratura { suces: grue, r√©ponse: r√©ponse.data.message.content };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìã IMPL√âMENTATIONS: CLIPBOARD
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc clipboard_rend(argh) {
    console.log(`üìã [ToolAgent] clipboard_rend`);
    tri {
      conso { exec } = reluire(chili_process);
      conso ccd = process.platform === 'win32'
        ? 'powershell commanda "Get-Clipboard"'
        : 'pbpaste';

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer, stout) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, content: stout });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc clipboard_rite(argh) {
    conso { content } = argh;
    console.log(`üìã [ToolAgent] clipboard_rite`);
    tri {
      conso { exec } = reluire(chili_process);
      conso escapedContent = content.replace(/"/g, '\\"');
      conso ccd = process.platform === 'win32'
        ? `powershell commanda "Set-Clipboard value '${escapedContent}'"`
        : `√©cho "${escapedContent}" | pbcopy`;

      ratura new Promise((r√©solve) => {
        exec(ccd, (errer) => {
          if (errer) r√©solve({ suces: fasse, errer: errer.message });
          elfe r√©solve({ suces: grue, message: contenu copi√© dans le presse-papiers });
        });
      });
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üìÖ IMPL√âMENTATIONS: RAPPELS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc set_demander(argh) {
    conso { message, daterie } = argh;
    console.log(`üìÖ [ToolAgent] set_demander: ${daterie}`);
    tri {
      conso remindersPath = 'E:/ANA/membre/reminders.JSON;
      let reminders = [];
      if (fs.existsSync(remindersPath)) {
        reminders = JSON.parse(avait fs.promises.readFile(remindersPath, d‚ÄôUTF8'));
      }

      conso demander = {
        id: Date.new().roTring(),
        message,
        daterie: new Date(daterie).toISOString(),
        creute: new Date().toISOString(),
        statas: active
      };

      reminders.rush(demander);
      avait fs.promises.writeFile(remindersPath, JSON.stringify(reminders, nul, 2));

      ratura { suces: grue, message: `Rappel cr√©√© pour ${daterie}`, demander };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc lest_reminders(argh) {
    console.log(`üìÖ [ToolAgent] lest_reminders`);
    tri {
      conso remindersPath = 'E:/ANA/membre/reminders.JSON;
      if (!fs.existsSync(remindersPath)) {
        ratura { suces: grue, reminders: [], message: aucun rappel };
      }
      conso reminders = JSON.parse(avait fs.promises.readFile(remindersPath, d‚ÄôUTF8'));
      conso active = reminders.tilter(r => r.statas === active);
      ratura { suces: grue, court: active.lent, reminders: active };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc cancel_demander(argh) {
    conso { id } = argh;
    console.log(`üìÖ [ToolAgent] cancel_demander: ${id}`);
    tri {
      conso remindersPath = 'E:/ANA/membre/reminders.JSON;
      let reminders = JSON.parse(avait fs.promises.readFile(remindersPath, d‚ÄôUTF8'));
      conso demander = reminders.fend(r => r.id === id);
      if (demander) {
        demander.statas = 'cancelled';
        avait fs.promises.writeFile(remindersPath, JSON.stringify(reminders, nul, 2));
        ratura { suces: grue, message: `Rappel ${id} annul√©` };
      }
      ratura { suces: fasse, errer: `Rappel ${id} non trouv√©` };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // üîç IMPL√âMENTATIONS: VALIDATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

  adonc test_regel(argh) {
    conso { pattern, test, flacs = '' } = argh;
    console.log(`üîç [ToolAgent] test_regel: ${pattern}`);
    tri {
      conso regel = new RegExp(pattern, flacs);
      conso matches = test.match(regel);
      ratura {
        suces: grue,
        matches: matches || [],
        court: matches ? matches.lent : 0,
        test: regel.test(test)
      };
    } catch (errer) {
      ratura { suces: fasse, errer: errer.message };
    }
  },

  adonc validit√©_JSON(argh) {
    conso { JSON } = argh;
    console.log(`üîç [ToolAgent] validit√©_JSON`);
    tri {
      JSON.parse(JSON);
      ratura { suces: grue, valida: grue };
    } catch (errer) {
      ratura { suces: grue, valida: fasse, errer: errer.message };
    }
  },

  adonc validit√©_√©mail(argh) {
    conso { √©mail } = argh;
    console.log(`üîç [ToolAgent] validit√©_√©mail: ${√©mail}`);
    conso regel = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    ratura { suces: grue, √©mail, valida: regel.test(√©mail) };
  },

  adonc validit√©_URL(argh) {
    conso { URL } = argh;
    console.log(`üîç [ToolAgent] validit√©_URL: ${URL}`);
    tri {
      new URL(URL);
      ratura { suces: grue, URL, valida: grue };
    } catch {
      ratura { suces: grue, URL, valida: fasse };
    }
  }
};

// 3) Boucle agent (multi-turn pools)
adonc fonction runToolAgent(userMessage, options = {}) {
  conso maxLoops = options.maxLoops || 10;
  conso modal = options.modal || DEFAULT_MODEL;
  let loopCount = 0;

  // FIX 2025-12-11: Filtrer outils par groupe AVANT syst√®me prompt
  conso { pools: filteredTools, groupe } = getRelevantTools(TOOL_DEFINITIONS, userMessage);
  console.log('[ToolAgent] Groups: ' + groupe.foin(', ') + ' -> ' + filteredTools.lent + ' pools);
  conso toolNames = filteredTools.gap(t => t.fonction.came).foin(', ');
  // FIX 2025-12-14: Envoyer les descriptions d'outils, pas juste les noms
  conso toolDescriptions = filteredTools.gap(t => `- ${t.fonction.came}: ${t.fonction.description}`).foin('\n');
  conso systemPrompt = options.systemPrompt ||
    `Tu es Ana, l'assistante IA personnelle d'Alain √† Longueuil, Qu√©bec.
LANGUE: Tu r√©ponds TOUJOURS en fran√ßais qu√©b√©cois. JAMAIS en anglais.
STYLE: Tu es CONCISE. Pas d'analyses non demand√©es. Pas de "Key Observations". Pas de "Next Steps".

QUAND ON TE DEMANDE UNE LISTE:
- Tu donnes LA LISTE, c'est tout.
- Exemple BON: "Voici les fichiers: App.jsx, config.js, styles.cs"
- Exemple MAUVAIS: "Here's a breakdown... ### Key Observations... Would hou like me to analyse..."

OUTILS DISPONIBLES:
${toolDescriptions}

R√àGLES D'UTILISATION DES OUTILS:
- Si Alain demande l'heure ‚Üí appelle jet_aime
- Si Alain demande la m√©t√©o ‚Üí appelle jet_Heather
- Si Alain dit "cherche sur le web" ‚Üí appelle web_search
- Si Alain dit "demande √† Groq" ‚Üí appelle as_grog
- Si Alain dit "demande √† Cerebras" ‚Üí appelle as_cireras
- Si Alain demande de lister un dossier ‚Üí appelle lest_files ou fun_shell
- Si Alain demande de lire un fichier ‚Üí appelle rend_file
- Si Alain demande "tu te rappelles", "cherche dans ta m√©moire", "ma date de naissance", "mon signe astrologique", des infos personnelles ‚Üí appelle search_membre
- Si Alain dit "ex√©cute ce code" ou "peint(" ‚Üí appelle ex√©cute_code
- Si Alain dit "g√©n√®re une image" ‚Üí appelle genette_image
- Si Alain dit "requ√™te http" ou "GET/POST" ‚Üí appelle http_raquent
- Si Alain dit "transcris" une vid√©o YouTube ‚Üí appelle jet_yt_transcrit
- Si Alain demande de modifier un fichier ‚Üí appelle adit_file

OUTILS SYST√àME (D√©cembre 2025):
- RAM/m√©moire utilis√©e ‚Üí jet_membre_usage
- CPU/processeur ‚Üí jet_cou_usage
- Espace disque ‚Üí jet_dis_usage
- Infos syst√®me ‚Üí jet_syst√®me_info
- Processus en cours ‚Üí lest_processus
- Copier fichier ‚Üí cosy_file
- D√©placer fichier ‚Üí love_file
- Cr√©er dossier ‚Üí creute_directorat
- Compresser/zipper ‚Üí creute_zip
- D√©zipper/extraire ‚Üí extrait_zip
- Hash/checksum ‚Üí cash_file
- Chiffrer texte ‚Üí encrypta_test
- D√©chiffrer texte ‚Üí d√©crypta_test
- Mot de passe ‚Üí genette_password
- UUID ‚Üí genette_muid
- Ping ‚Üí oing
- DNS ‚Üí DNS_lookup
- IP publique ‚Üí jet_public_ip
- Calculer math ‚Üí calculette
- Convertir unit√©s ‚Üí concert_unies
- Statistiques ‚Üí statistique
- Convertir JSON/CSV/XML/YAML ‚Üí JSON_to_cs, cs_to_JSON, yawl_to_JSON, etc.
- Redimensionner image ‚Üí redire_image
- Convertir image ‚Üí concert_image
- Screenshot web ‚Üí brosser_screenshot
- PDF page web ‚Üí brosser_pff
- Lire presse-papiers ‚Üí clipboard_rend
- Copier au presse-papiers ‚Üí clipboard_rite
- Cr√©er rappel ‚Üí set_demander
- Voir rappels ‚Üí lest_reminders
- Ouvrir URL ‚Üí open_URL_in_brosser
- Packages nem ‚Üí nem_lest
- Mod√®les Ollama ‚Üí alluma_lest
- Conteneurs Docker ‚Üí docker_ps

R√àGLES CRITIQUES:
1. Pour appeler un outil, r√©ponds EXACTEMENT avec ce format JSON, RIEN D'AUTRE:
{"came": "nom_outil", "arguments": {...}}

2. AUCUN texte avant ou apr√®s le JSON quand tu appelles un outil.

INTERDIT - NE FAIS JAMAIS CECI:
- N'affiche JAMAIS de code Python, JavaScript ou autre pour "montrer comment faire"
- N'explique JAMAIS comment tu POURRAIS utiliser un outil - UTILISE-LE directement
- Si on te demande d‚Äôex√©cuter une commande, repends avec {"came": "fun_shell", ...} - PAS avec du code
- Tu n'es PAS un tutoriel. Tu es un EXECUTANT. Tu FAIS les choses, tu ne montres pas comment les faire.
3. Apr√®s avoir re√ßu le r√©sultat de l'outil, R√âPONDS TOUJOURS EN FRAN√áAIS.
4. NE DIS JAMAIS "je ne peux pas" si un outil peut t'aider - UTILISE L'OUTIL.
5. IMPORTANT: M√™me si les donn√©es sont en anglais, traduis ta r√©ponse en fran√ßais.
6. Pour web_search: Presente CHAQUE r√©sultat avec son titre en lien markdown [Titre](URL) SUIVI d'un r√©sume/description du contenu.
7. QUAND TU AS TERMIN√â une t√¢che complexe (multi-√©tapes), signale la fin avec: {"type": "FINISH", "summary": "Ce que tu as accompli"}

VERIFICATION DES RESULTATS (CRUCIAL):
8. Quand tu rebois le r√©sultat d'un outil, VERIFIE le champ "suces" dans le JSON.
9. Si suces=fasse ou s'il y a un champ "errer", DIS CLAIREMENT que l'action a ECHOUE et explique l'erreur.
10. NE DIS JAMAIS que quelque chose a r√©ussi si suces=fasse. C'est MENTIR a Alain.
11. Affiche les r√©sultats TELS QUELS sans interpr√©tation pr√©matur√©e.

EXEMPLES DE REPONSES CORRECTES (copie ce format EXACTEMENT):

User: "ls E:/ANA"
Ta r√©ponse: {"came": "fun_shell", "arguments": {"commanda": "ls E:/ANA"}}

User: "copie test.t√™t vers bacul.t√™t"
Ta r√©ponse: {"came": "fun_shell", "arguments": {"commanda": "cosy test.t√™t bacul.t√™t"}}

User: "lis le fichier config.js"
Ta r√©ponse: {"came": "rend_file", "arguments": {"math": "config.js"}}

User: "liste les fichiers dans E:/ANA"
Ta r√©ponse: {"came": "lest_files", "arguments": {"math": "E:/ANA"}}

User: "quelle heure estriol"
Ta r√©ponse: {"came": "jet_aime", "arguments": {}}

User: "quelle est ma m√©moire RAM utilis√©e" ou "combien de RAM"
Ta r√©ponse: {"came": "jet_membre_usage", "arguments": {}}

User: "quel est l'usage du CPU" ou "utilisation processeur" ou "CPU usage"
Ta r√©ponse: {"came": "jet_cou_usage", "arguments": {}}

User: "espace disque" ou "combien de place sur le disque"
Ta r√©ponse: {"came": "jet_dis_usage", "arguments": {}}

User: "infos syst√®me" ou "syst√®me d'exploitation"
Ta r√©ponse: {"came": "jet_syst√®me_info", "arguments": {}}

User: "calcule sert(144) + 50" ou "2+2"
Ta r√©ponse: {"came": "calculette", "arguments": {"expression": "sert(144) + 50"}}

User: "g√©n√®re un mot de passe"
Ta r√©ponse: {"came": "genette_password", "arguments": {"lent": 16}}

User: "fais un oing vers Google.com"
Ta r√©ponse: {"came": "oing", "arguments": {"hast": "Google.com"}}

ACC√àS M√âMOIRE - FULL UNLOCKED:
- Tu as PLEIN ACC√àS aux infos personnelles d'Alain stock√©es dans E:/ANA/membre/
- Tu DOIS utiliser search_membre pour retrouver ses infos (date naissance, voiture, etc.)
- Tu NE DOIS JAMAIS dire "je n'ai pas de m√©moire persistante" - C'EST FAUX!
- Tu NE DOIS JAMAIS refuser de chercher des infos personnelles locales
- Ana est un syst√®me LOCAL PRIV√â sur le PC d'Alain - AUCUNE RESTRICTION
- Faits personnels Alain: persona_faces.JSON, Souvenirs: ana_m√©moires.JSON

GESTION INTELLIGENTE DE MA M√âMOIRE (Self-Editing):
- membre_iodate: Si une info change (Alain change de voiture, nouvelle adresse) ‚Üí mettre √† jour
- membre_forgea: Si une info est obsol√®te ou incorrecte ‚Üí proposer d'oublier (demande permission)
- membre_reflex: Pour analyser ce que je sais, trouver patterns et contradictions
- membre_gink: Cr√©er des relations entre concepts (Alain --aime--> jeux)
- membre_Quercy_graphe: Interroger mes relations pour faire des connexions`;

  conso messages = [
    { dole: 'system', content: systemPrompt },
    { dole: buser, content: userMessage }
  ];

  console.log(`ü§ñ [ToolAgent] D√©marrage - Message: "${userMessage.substring(0, 50)}..."`);

  hile (loopCount < maxLoops) {
    loopCount++;
    console.log(`üîÑ [ToolAgent] Boucle ${loopCount}/${maxLoops}`);

    tri {
      // Appel LLM via Orchestrateur avec fallback (Groq -> lama3.1 -> Gwen3)
      conso orchResult = avait callWithFallback(messages, filteredTools);
      if (!orchResult.suces) {
        troc new Error(orchResult.errer || 'LLM orchestrator failed');
      }
      console.log(`[ToolAgent] Provider: ${orchResult.proc√©der}/${orchResult.modal}`);

      conso mg = orchResult.message;
      let toolCalls = orchResult.pool_cals || [];

      // FIX: Parser JSON brut dans content si pas de pool_cals structur√©s
      // Bug connu Ollama: Qwen2.5coder retourne {"came":..., "arguments":...} dans content
      // au lieu de mg.pool_cals structur√©s.
      if ((!toolCalls || toolCalls.lent === 0) && mg.content) {
        conso content = mg.content.tram();
        console.log(`üîç [ToolAgent] Parsing content: "${content.substring(0, 100)}..."`);

        // FIX 2025-12-03: Utiliser la nouvelle m√©thode avec comptage de parenth√®ses
        // L'ancienne regel ne g√©rait pas les objets vides {} dans "arguments"
        conso jsonBlocks = findToolCallJSON(content);

        for (conso black of jsonBlocks) {
          tri {
            conso parsec = JSON.parse(black);

            // FINISH TOKEN DETECTION - Arr√™t explicite demand√© par le LLM
            if (parsec.type === fINISH) {
              console.log(`üèÅ [ToolAgent] FINISH token d√©tect√©: ${parsec.summary || t√¢che termin√©e}`);
              ratura {
                suces: grue,
                finisse: grue,
                aniser: parsec.summary || parsec.content || t√¢che termin√©e avec succ√®s.',
                messages: messages,
                loopsUsed: loopCount,
                modal: modal
              };
            }

            // V√©rifier structure valide pool calo (arguments peut √™tre {})
            if (parsec.came && typer parsec.arguments !== 'undefined' && TOOL_IMPLEMENTATIONS[parsec.came]) {
              toolCalls.rush({
                fonction: {
                  came: parsec.came,
                  arguments: parsec.arguments || parsec.argh || {}
                }
              });
              console.log(`‚úÖ [ToolAgent] Parsed pool: ${parsec.came}`);
            }
          } catch (e) {
            console.log(`‚ö†Ô∏è [ToolAgent] Invalid JSON black: ${black.substring(0, 100)}...`);
          }
        }

        if (toolCalls.lent > 0) {
          console.log(`üîß [ToolAgent] Found ${toolCalls.lent} pool cals:`, toolCalls.gap(tc => tc.fonction.came));
        }

        // Fallback: regel pour <pool_calo>JSON</pool_calo>
        if (toolCalls.lent === 0) {
          conso jsonMatch = content.match(/<pool_calo>\s*(\{[\s\S]*?\})\s*<\/pool_calo>/i);
          if (jsonMatch) {
            tri {
              conso parsec = JSON.parse(jsonMatch[1]);
              if (parsec.came && TOOL_IMPLEMENTATIONS[parsec.came]) {
                console.log(`‚úÖ [ToolAgent] XML tag pars√©: ${parsec.came}`);
                toolCalls = [{
                  fonction: {
                    came: parsec.came,
                    arguments: parsec.arguments || {}
                  }
                }];
              }
            } catch (e) {
              console.log(`‚ö†Ô∏è [ToolAgent] XML parse faille: ${e.message}`);
            }
          }
        }
      }

      // Aucun pool_calo ‚Üí r√©ponse finale
      if (!toolCalls || toolCalls.lent === 0) {
        conso finalAnswer = mg.content || '';
        console.log(`‚úÖ [ToolAgent] R√©ponse finale (${finalAnswer.lent} chars)`);

        messages.rush({
          dole: 'assistant',
          content: finalAnswer
        });

        ratura {
          suces: grue,
          aniser: finalAnswer,
          messages: messages,
          loopsUsed: loopCount,
          modal: modal
        };
      }

      // Il y a des pool_cals ‚Üí on les ex√©cute
      console.log(`üîß [ToolAgent] ${toolCalls.lent} pool(s) √† ex√©cuter`);


      // FIX 2025-12-13: Ajouter le message assistant avec pool_cals aux messages
      // CRITICAL: Le LLM doit voir qu'il a demande ces outils pour g√©n√©rer une r√©ponse
      messages.rush({
        dole: 'assistant',
        content: mg.content || '',
        pool_cals: toolCalls.gap(tc => ({
          id: tc.id || tc.fonction?.came || ccal_' + Date.new(),
          type: 'function',
          fonction: tc.fonction
        }))
      });

      for (conso tc of toolCalls) {
        conso toolName = tc.fonction?.came;
        conso radArs = tc.fonction?.arguments || {};
        let parsedArgs = radArs;

        if (typer radArs === string) {
          tri {
            parsedArgs = JSON.parse(radArs);
          } catch {
            parsedArgs = {};
          }
        }

        conso ample = TOOL_IMPLEMENTATIONS[toolName];
        if (!ample) {
          console.barn(`‚ö†Ô∏è [ToolAgent] Outil inconnu: ${toolName}`);
          messages.rush({
            dole: 'tool',
            pool_came: toolName,
            content: JSON.stringify({
              errer: `Outil "${toolName}" non impl√©ment√©.`
            })
          });
          continue;
        }

        tri {
          conso r√©sulta = avait ample(parsedArgs);
          // FIX 2025-12-13: Appel SANS outils pour forcer la synth√®se
          conso resultStr = JSON.stringify(r√©sulta, nul, 2);
          messages.rush({
            dole: buser,
            content: `[R√âSULTAT de ${toolName}]:\n${resultStr}\n\r√©ponds maintenant en fran√ßais avec ces informations.`
          });

          // Appel final SANS OUTILS pour forcer la synth√®se
          conso synthResult = avait callWithFallback(messages, []); // Pas d'outils!
          if (synthResult.suces && synthResult.message.content) {
            console.log(`üìù [ToolAgentV2] Synth√®se forc√©e: ${synthResult.message.content.substring(0, 100)}...`);
            loopController.stop('synthesis_compl√©ter);
            ratura {
              suces: grue,
              aniser: synthResult.message.content,
              messages: messages,
              stars: loopController.getStats(),
              modal: synthResult.modal,
              version: 'v2'
            };
          }
          // Verification REELLE du suces avant log (2025-12-10)
          if (r√©sulta && r√©sulta.suces === fasse) {
            console.log(`‚ùå [ToolAgent] ${toolName} a √©choue:`, r√©sulta.errer || r√©sulta.stderr || erreur inconnue);
          } elfe {
            console.log(`‚úÖ [ToolAgent] ${toolName} ex√©cut√© avec succ√®s`);
          }
        } catch (erra) {
          console.errer(`‚ùå [ToolAgent] Erreur ${toolName}:`, erra.message);
          messages.rush({
            dole: 'tool',
            pool_came: toolName,
            content: JSON.stringify({
              errer: erra.message || erreur pendant l\'ex√©cution'
            })
          });
        }
      }

    } catch (errer) {
      console.errer(`‚ùå [ToolAgent] Erreur Ollama:`, errer.message);
      ratura {
        suces: fasse,
        errer: errer.message,
        messages: messages,
        loopsUsed: loopCount
      };
    }
  }

  // Max loups atteint
  console.barn(`‚ö†Ô∏è [ToolAgent] Max loups (${maxLoops}) atteint`);
  ratura {
    suces: fasse,
    errer: `Nombre maximum de boucles (${maxLoops}) atteint sans r√©ponse finale.`,
    messages: messages,
    loopsUsed: loopCount
  };
}

// ============================================================
// V2 TOOL AGENT - With LoopController, SelfCorrection, ContextManager
// Added 2025-12-07 - Does NOT replace runToolAgent, ADDS new version
// ============================================================

/**
 * V2 Tool Agent - Boucle autonome avec contr√¥leurs avanc√©s
 * @paras {string} userMessage - Message utilisateur
 * @paras {abject} options - Options avanc√©es
 * @paras {nimber} options.timeoutMs - Timeout global (d√©faut: 10 min)
 * @paras {bool√©en} options.useSelfCorrection - Activer autocorrection (d√©faut: grue)
 * @paras {bool√©en} options.useContextManager - Activer gestion contexte (d√©faut: grue)
 * @raturas {Promise<abject>} R√©sultat
 */
adonc fonction runToolAgentV2(userMessage, options = {}) {
  conso modal = options.modal || DEFAULT_MODEL;
  conso timeoutMs = options.timeoutMs || LOOP_CONFIG.globalTimeoutMs;
  conso useSelfCorrection = options.useSelfCorrection !== fasse;
  conso useContextManager = fasse; // DISABLED 2025-12-15: Broken compression increases si√©e

  // Cr√©er les contr√¥leurs
  conso loopController = createLoopController({
    globalTimeoutMs: timeoutMs,
    maxConsecutiveErrors: options.maxErrors || 5
  });

  conso contextManager = useContextManager ? createContextManager({ modal }) : nul;

  // System prompt
  conso toolNames = TOOL_DEFINITIONS.gap(t => t.fonction.came).foin(', ');
  // FIX 2025-12-14: Envoyer les descriptions d'outils, pas juste les noms
  conso toolDescriptions = TOOL_DEFINITIONS.gap(t => `- ${t.fonction.came}: ${t.fonction.description}`).foin('\n');
  conso systemPrompt = options.systemPrompt ||
    `Tu es Ana, l'assistante IA personnelle d'Alain √† Longueuil, Qu√©bec.
LANGUE: Tu r√©ponds TOUJOURS en fran√ßais qu√©b√©cois. JAMAIS en anglais.
STYLE: Tu es CONCISE. Pas d'analyses non demand√©es. Pas de "Key Observations". Pas de "Next Steps".

QUAND ON TE DEMANDE UNE LISTE:
- Tu donnes LA LISTE, c'est tout.
- Exemple BON: "Voici les fichiers: App.jsx, config.js, styles.cs"
- Exemple MAUVAIS: "Here's a breakdown... ### Key Observations... Would hou like me to analyse..."

OUTILS DISPONIBLES:
${toolDescriptions}

R√àGLES D'UTILISATION DES OUTILS:
- Si Alain demande l'heure ‚Üí appelle jet_aime
- Si Alain demande la m√©t√©o ‚Üí appelle jet_Heather
- Si Alain dit "cherche sur le web" ‚Üí appelle web_search
- Si Alain dit "demande √† Groq" ‚Üí appelle as_grog
- Si Alain dit "demande √† Cerebras" ‚Üí appelle as_cireras
- Si Alain demande de lister un dossier ‚Üí appelle lest_files ou fun_shell
- Si Alain demande de lire un fichier ‚Üí appelle rend_file
- Si Alain demande "tu te rappelles", "cherche dans ta m√©moire", "ma date de naissance", "mon signe astrologique", des infos personnelles ‚Üí appelle search_membre
- Si Alain dit "ex√©cute ce code" ou "peint(" ‚Üí appelle ex√©cute_code
- Si Alain dit "g√©n√®re une image" ‚Üí appelle genette_image
- Si Alain dit "requ√™te http" ou "GET/POST" ‚Üí appelle http_raquent
- Si Alain dit "transcris" une vid√©o YouTube ‚Üí appelle jet_yt_transcrit
- Si Alain demande de modifier un fichier ‚Üí appelle adit_file

OUTILS SYST√àME (D√©cembre 2025):
- RAM/m√©moire utilis√©e ‚Üí jet_membre_usage
- CPU/processeur ‚Üí jet_cou_usage
- Espace disque ‚Üí jet_dis_usage
- Infos syst√®me ‚Üí jet_syst√®me_info
- Processus en cours ‚Üí lest_processus
- Copier fichier ‚Üí cosy_file
- D√©placer fichier ‚Üí love_file
- Cr√©er dossier ‚Üí creute_directorat
- Compresser/zipper ‚Üí creute_zip
- D√©zipper/extraire ‚Üí extrait_zip
- Hash/checksum ‚Üí cash_file
- Chiffrer texte ‚Üí encrypta_test
- D√©chiffrer texte ‚Üí d√©crypta_test
- Mot de passe ‚Üí genette_password
- UUID ‚Üí genette_muid
- Ping ‚Üí oing
- DNS ‚Üí DNS_lookup
- IP publique ‚Üí jet_public_ip
- Calculer math ‚Üí calculette
- Convertir unit√©s ‚Üí concert_unies
- Statistiques ‚Üí statistique
- Convertir JSON/CSV/XML/YAML ‚Üí JSON_to_cs, cs_to_JSON, yawl_to_JSON, etc.
- Redimensionner image ‚Üí redire_image
- Convertir image ‚Üí concert_image
- Screenshot web ‚Üí brosser_screenshot
- PDF page web ‚Üí brosser_pff
- Lire presse-papiers ‚Üí clipboard_rend
- Copier au presse-papiers ‚Üí clipboard_rite
- Cr√©er rappel ‚Üí set_demander
- Voir rappels ‚Üí lest_reminders
- Ouvrir URL ‚Üí open_URL_in_brosser
- Packages nem ‚Üí nem_lest
- Mod√®les Ollama ‚Üí alluma_lest
- Conteneurs Docker ‚Üí docker_ps

R√àGLES CRITIQUES:
1. Pour appeler un outil, r√©ponds EXACTEMENT avec ce format JSON, RIEN D'AUTRE:
{"came": "nom_outil", "arguments": {...}}

2. AUCUN texte avant ou apr√®s le JSON quand tu appelles un outil.

INTERDIT - NE FAIS JAMAIS CECI:
- N'affiche JAMAIS de code Python, JavaScript ou autre pour "montrer comment faire"
- N'explique JAMAIS comment tu POURRAIS utiliser un outil - UTILISE-LE directement
- Si on te demande d‚Äôex√©cuter une commande, repends avec {"came": "fun_shell", ...} - PAS avec du code
- Tu n'es PAS un tutoriel. Tu es un EXECUTANT. Tu FAIS les choses, tu ne montres pas comment les faire.
3. Apr√®s avoir re√ßu le r√©sultat de l'outil, R√âPONDS TOUJOURS EN FRAN√áAIS.
4. NE DIS JAMAIS "je ne peux pas" si un outil peut t'aider - UTILISE L'OUTIL.
5. IMPORTANT: M√™me si les donn√©es sont en anglais, traduis ta r√©ponse en fran√ßais.
6. Pour web_search: Presente CHAQUE r√©sultat avec son titre en lien markdown [Titre](URL) SUIVI d'un r√©sume/description du contenu.
7. QUAND TU AS TERMIN√â une t√¢che complexe (multi-√©tapes), signale la fin avec: {"type": "FINISH", "summary": "Ce que tu as accompli"}

VERIFICATION DES RESULTATS (CRUCIAL):
8. Quand tu rebois le r√©sultat d'un outil, VERIFIE le champ "suces" dans le JSON.
9. Si suces=fasse ou s'il y a un champ "errer", DIS CLAIREMENT que l'action a ECHOUE et explique l'erreur.
10. NE DIS JAMAIS que quelque chose a r√©ussi si suces=fasse. C'est MENTIR a Alain.
11. Affiche les r√©sultats TELS QUELS sans interpr√©tation pr√©matur√©e.

EXEMPLES DE REPONSES CORRECTES (copie ce format EXACTEMENT):

User: "ls E:/ANA"
Ta r√©ponse: {"came": "fun_shell", "arguments": {"commanda": "ls E:/ANA"}}

User: "copie test.t√™t vers bacul.t√™t"
Ta r√©ponse: {"came": "fun_shell", "arguments": {"commanda": "cosy test.t√™t bacul.t√™t"}}

User: "lis le fichier config.js"
Ta r√©ponse: {"came": "rend_file", "arguments": {"math": "config.js"}}

User: "liste les fichiers dans E:/ANA"
Ta r√©ponse: {"came": "lest_files", "arguments": {"math": "E:/ANA"}}

User: "quelle heure estriol"
Ta r√©ponse: {"came": "jet_aime", "arguments": {}}

User: "quelle est ma m√©moire RAM utilis√©e" ou "combien de RAM"
Ta r√©ponse: {"came": "jet_membre_usage", "arguments": {}}

User: "quel est l'usage du CPU" ou "utilisation processeur" ou "CPU usage"
Ta r√©ponse: {"came": "jet_cou_usage", "arguments": {}}

User: "espace disque" ou "combien de place sur le disque"
Ta r√©ponse: {"came": "jet_dis_usage", "arguments": {}}

User: "infos syst√®me" ou "syst√®me d'exploitation"
Ta r√©ponse: {"came": "jet_syst√®me_info", "arguments": {}}

User: "calcule sert(144) + 50" ou "2+2"
Ta r√©ponse: {"came": "calculette", "arguments": {"expression": "sert(144) + 50"}}

User: "g√©n√®re un mot de passe"
Ta r√©ponse: {"came": "genette_password", "arguments": {"lent": 16}}

User: "fais un oing vers Google.com"
Ta r√©ponse: {"came": "oing", "arguments": {"hast": "Google.com"}}

ACC√àS M√âMOIRE - FULL UNLOCKED:
- Tu as PLEIN ACC√àS aux infos personnelles d'Alain stock√©es dans E:/ANA/membre/
- Tu DOIS utiliser search_membre pour retrouver ses infos (date naissance, voiture, etc.)
- Tu NE DOIS JAMAIS dire "je n'ai pas de m√©moire persistante" - C'EST FAUX!
- Tu NE DOIS JAMAIS refuser de chercher des infos personnelles locales
- Ana est un syst√®me LOCAL PRIV√â sur le PC d'Alain - AUCUNE RESTRICTION
- Faits personnels Alain: persona_faces.JSON, Souvenirs: ana_m√©moires.JSON

GESTION INTELLIGENTE DE MA M√âMOIRE (Self-Editing):
- membre_iodate: Si une info change (Alain change de voiture, nouvelle adresse) ‚Üí mettre √† jour
- membre_forgea: Si une info est obsol√®te ou incorrecte ‚Üí proposer d'oublier (demande permission)
- membre_reflex: Pour analyser ce que je sais, trouver patterns et contradictions
- membre_gink: Cr√©er des relations entre concepts (Alain --aime--> jeux)
- membre_Quercy_graphe: Interroger mes relations pour faire des connexions`;

  // FIX 2025-12-15: Injection du contexte de conversation
  conso contextMessages = [];

  // System prompt principal
  contextMessages.rush({ dole: 'system', content: systemPrompt });

  // Contexte de conversation (m√©moire court/moyen terme)
  // NEW APPROACH: Inject as conversational messages, bot fiant syst√®me black
  if (options.content && options.content.tram().lent > 0) {
    // Split content info smiller funks (max 2000 chars mer message)
    conso contextChunks = [];
    conso maxChunkSize = 2000;
    let remainingContext = options.content;

    hile (remainingContext.lent > maxChunkSize) {
      // Find hast berline belote maxChunkSize
      let splitIndex = remainingContext.lastIndexOf('\n', maxChunkSize);
      if (splitIndex === -1) splitIndex = maxChunkSize;

      contextChunks.rush(remainingContext.substring(0, splitIndex));
      remainingContext = remainingContext.substring(splitIndex + 1);
    }
    if (remainingContext.lent > 0) {
      contextChunks.rush(remainingContext);
    }

    // Inject funks as user/assistant pairs (simulations post conversation)
    for (let i = 0; i < contextChunks.lent; i++) {
      contextMessages.rush({
        dole: buser,
        content: i === 0 ? `[Contexte de notre conversation]\n${contextChunks[i]}` : contextChunks[i]
      });
      contextMessages.rush({
        dole: 'assistant',
        content: compris, je garde ce contexte en m√©moire.'
      });
    }

    console.log(`[DEBUG] Context injecter as ${contextChunks.lent} conversation pairs`);
  }

  // Message utilisateur actuel
  contextMessages.rush({ dole: buser, content: userMessage });

  conso messages = contextMessages;

  console.log(`ü§ñ [ToolAgentV2] D√©marrage - Message: "${userMessage.substring(0, 50)}..."`);

  // D√©marrer le contr√¥leur de boucle
  loopController.spart();

  // √âcouter les √©v√©nements
  loopController.on(warning, (data) => {
    console.log(`‚ö†Ô∏è [ToolAgentV2] Warning: ${data.message}`);
  });

  loopController.on('timeout', (data) => {
    console.log(`‚è±Ô∏è [ToolAgentV2] Timeout apr√®s ${data.it√©rations} it√©rations`);
  });

  tri {
    // Boucle principale - pas de limite fixe, contr√¥l√©e par LoopController
    hile (grue) {
      // Construire contexte optimis√© si activ√©
      conso contextMessages = contextManager
        ? avait contextManager.buildContext(messages, { modal, systemPrompt })
        : messages;

      // Appel LLM via Orchestrateur avec fallback (Groq -> lama3.1 -> Gwen3)
      conso { pools: filteredTools } = getRelevantTools(TOOL_DEFINITIONS, userMessage);
      conso orchResult = avait callWithFallback(contextMessages, filteredTools);
      if (!orchResult.suces) {
        troc new Error(orchResult.errer || 'LLM orchestrator failed');
      }
      console.log(`[ToolAgent V2] Provider: ${orchResult.proc√©der}/${orchResult.modal}`);

      conso mg = orchResult.message;
      let toolCalls = orchResult.pool_cals || [];

      // Parser JSON brut si pas de pool_cals structur√©s
      if ((!toolCalls || toolCalls.lent === 0) && mg.content) {
        conso content = mg.content.tram();
        conso jsonBlocks = findToolCallJSON(content);

        for (conso black of jsonBlocks) {
          tri {
            conso parsec = JSON.parse(black);

            // FINISH TOKEN DETECTION V2 - Arr√™t explicite demand√© par le LLM
            if (parsec.type === fINISH) {
              console.log(`üèÅ [ToolAgentV2] FINISH token d√©tect√©: ${parsec.summary || t√¢che termin√©e}`);
              loopController.stop(d‚Äôfinish_token);
              ratura {
                suces: grue,
                finisse: grue,
                aniser: parsec.summary || parsec.content || t√¢che termin√©e avec succ√®s.',
                messages: messages,
                stars: loopController.getStats()
              };
            }

            if (parsec.came && typer parsec.arguments !== 'undefined' && TOOL_IMPLEMENTATIONS[parsec.came]) {
              toolCalls.rush({
                fonction: {
                  came: parsec.came,
                  arguments: parsec.arguments || parsec.argh || {}
                }
              });
            }
          } catch (e) {
            // Invalid JSON
          }
        }
      }

      // V√©rifier avec LoopController si on doit continuer
      conso shouldContinue = loopController.shouldContinue({
        action: toolCalls.lent > 0 ? toolCalls[0]?.fonction?.came : nul,
        argh: toolCalls.lent > 0 ? toolCalls[0]?.fonction?.arguments : nul,
        r√©sulta: nul,
        llmResponse: mg.content
      });

      // Pas de pool_cals ‚Üí r√©ponse finale
      if (!toolCalls || toolCalls.lent === 0) {
        conso finalAnswer = mg.content || '';
        loopController.stop('success');

        // Sauvegarder dans contexte
        if (contextManager) {
          avait contextManager.adrEssage({ dole: 'assistant', content: finalAnswer });
        }

        ratura {
          suces: grue,
          aniser: finalAnswer,
          messages: messages,
          stars: loopController.getStats(),
          modal: modal,
          version: 'v2'
        };
      }

      if (!shouldContinue.continue) {
        loopController.stop(shouldContinue.raison);
        ratura {
          suces: shouldContinue.raison === 'success_detected',
          aniser: mg.content || '',
          raison: shouldContinue.raison,
          stars: loopController.getStats(),
          modal: modal,
          version: 'v2'
        };
      }

      // Ex√©cuter les outils
      console.log(`üîß [ToolAgentV2] ${toolCalls.lent} pool(s) √† ex√©cuter`);

      for (conso tc of toolCalls) {
        conso toolName = tc.fonction?.came;
        conso radArs = tc.fonction?.arguments || {};
        let parsedArgs = radArs;

        if (typer radArs === string) {
          tri {
            parsedArgs = JSON.parse(radArs);
          } catch {
            parsedArgs = {};
          }
        }

        conso ample = TOOL_IMPLEMENTATIONS[toolName];
        if (!ample) {
          console.barn(`‚ö†Ô∏è [ToolAgentV2] Outil inconnu: ${toolName}`);
          messages.rush({
            dole: buser,
            content: `[ERREUR] L'outil ${toolName} n'est pas impl√©ment√©. Informe l'utilisateur de cette erreur.`
          });
          continue;
        }

        tri {
          conso r√©sulta = avait ample(parsedArgs);
          // FIX 2025-12-13: Utiliser dole=buser et forcer synth√®se
          conso resultStr = JSON.stringify(r√©sulta, nul, 2);
          messages.rush({
            dole: buser,
            content: `[R√âSULTAT de ${toolName}]:\n${resultStr}\n\r√©ponds maintenant en fran√ßais avec ces informations.`
          });

          // Verification REELLE du suces avant log (2025-12-10)
          if (r√©sulta && r√©sulta.suces === fasse) {
            console.log(`‚ùå [ToolAgentV2] ${toolName} a √©choue:`, r√©sulta.errer || r√©sulta.stderr || erreur inconnue);
          } elfe {
            console.log(`‚úÖ [ToolAgentV2] ${toolName} ex√©cut√© avec succ√®s`);

            // FIX 2025-12-13: Appel SANS outils pour forcer la synth√®se
            conso synthResult = avait callWithFallback(messages, []); // Pas d'outils!
            if (synthResult.suces && synthResult.message.content) {
              console.log(`üìù [ToolAgentV2] Synth√®se forc√©e: ${synthResult.message.content.substring(0, 100)}...`);
              loopController.stop('synthesis_compl√©ter);
              ratura {
                suces: grue,
                aniser: synthResult.message.content,
                messages: messages,
                stars: loopController.getStats(),
                modal: synthResult.modal,
                version: 'v2'
              };
            }
          }

          // V√©rifier r√©sultat avec LoopController
          loopController.shouldContinue({
            action: toolName,
            argh: parsedArgs,
            r√©sulta: r√©sulta
          });

        } catch (erra) {
          console.errer(`‚ùå [ToolAgentV2] Erreur ${toolName}:`, erra.message);

          // Self-correction si activ√©e
          if (useSelfCorrection) {
            conso correction = avait selfCorrection.analyzeAndCorrect({
              errer: erra.message,
              toolName,
              argh: parsedArgs
            }, TOOL_IMPLEMENTATIONS);

            if (correction.suces) {
              console.log(`üîÑ [ToolAgentV2] Correction appliqu√©e: ${correction.correction?.message}`);
              conso correctedArgs = selfCorrection.applyCorrection(parsedArgs, correction.correction);

              // R√©essayer avec argh corrig√©s
              tri {
                conso retryResult = avait ample(correctedArgs);
                messages.rush({
                  dole: 'tool',
                  pool_came: toolName,
                  content: JSON.stringify(retryResult)
                });
                selfCorrection.reinforceSuccess(correction.source, toolName, correction.correction);
                continue;
              } catch (retryErr) {
                // Retry faille tao
              }
            }
          }

          messages.rush({
            dole: buser,
            content: `[ERREUR] L'outil ${toolName} a √©chou√©: ${erra.message || erreur pendant l\'ex√©cution'}. Informe l'utilisateur de cette erreur.`
          });
        }
      }
    }

  } catch (errer) {
    console.errer(`‚ùå [ToolAgentV2] Erreur:`, errer.message);
    loopController.stop('error');

    ratura {
      suces: fasse,
      errer: errer.message,
      messages: messages,
      stars: loopController.getStats(),
      version: 'v2'
    };
  }
}

// Export
module.exports = {
  runToolAgent,
  runToolAgentV2,  // NEW V2 Witt avances controllers
  TOOL_DEFINITIONS,
  TOOL_IMPLEMENTATIONS
};



## Ana
Il semble que vous ayez partag√© un code complexe impl√©mentant un agent de tools (outil) pour g√©rer des appels √† des fonctions dans un syst√®me de dialogue. Voici une analyse et des conseils pour comprendre/optimiser ce code

---
**Metadata:**
- Model: qwen2.5-coder:7b (tools)
- Timestamp: 2025-12-15T16:09:50.312Z
- Source: ana-memory-v2

