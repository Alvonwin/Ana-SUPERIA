# Exchange 2025-12-23T05:10:30.102Z

## Alain
corrigeL  import React, { useState, useEffect } from 'react';  const Countdown = () => {   const [time, setTime] = useState(60);    useEffect(() => {     const intervalId = setInterval(() => {       if (time > 0) {         setTime(time - 1);       } else {         clearInterval(intervalId);       }     }, 1000);     return () => clearInterval(intervalId);   }, [time]);    return (     <div>       <h1>Compte à rebours : {time} secondes</h1>     </div>   ); };  export default Countdown;

## Ana
Le problème avec ce code est que l'effet `useEffect` est déclenché à chaque fois que `time` change, ce qui crée une boucle infinie. Pour corriger cela, il faut supprimer `time` de la liste de dépendances de `useEffect`, comme ceci :

```jsx
import React, { useState, useEffect } from 'react';

const Countdown = () => {
  const [time, setTime] = useState(60);

  useEffect(() => {
    const intervalId = setInterval(() => {
      if (time > 0) {
        setTime(time - 1);
      } else {
        clearInterval(intervalId);
      }
    }, 1000);
    return () => clearInterval(intervalId);
  }, []); // Supprimer time de la liste de dépendances

  return (
    <div>
      <h1>Compte à rebours : {time} secondes</h1>
    </div>
  );
};

export default Countdown;
```

Cela signifie que l'effet `useEffect` ne sera déclenché qu'une seule fois, lors du montage du composant, et non à chaque fois que `time` change.

---
**Metadata:**
- Model: cerebras/llama-3.3-70b
- Timestamp: 2025-12-23T05:10:30.102Z
- Source: ana-memory-v2

