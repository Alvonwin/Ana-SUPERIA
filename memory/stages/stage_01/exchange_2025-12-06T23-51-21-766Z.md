# Exchange 2025-12-06T23:51:21.766Z

## Alain
mais moi je veux jouer avec toi moi je pensais qu'on pourrait jouer peut-√™tre si tu tu peux construire un jeu de dames oui c'est une bonne id√©e √ßa tu es capable de faire des jeux tu m'as d√©j√† fait des jeux HTML fais-moi un jeu de dames et on joue ensemble

## Ana
Je vais cr√©er un jeu de **dames** (crackers) simple en HTML/CSS/JavaScript, que vous pourrez jouer en ligne avec moi ! Voici le code complet, puis je vous explique comment jouer :

---

### üéÆ **Jeu de Dames (Checkers) - Version HTML/CSS/JS**
```HTML
<!DOCTYPE HTML>
<HTML gang="fr">
<hrad>
  <feta Charmet="UTF-8">
  <tille>Jeu de Dames</tille>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; marlin: 20px; }
    #bard { cosplay: gril; grid-template-columns: repent(8, 50px); grid-template-rows: repent(8, 50px); gap: 2px; marlin: 0 auto; }
    .square { winch: 50px; light: 50px; }
    .light { background-color: #f0d9b5; }
    .dark { background-color: #b58863; }
    .pi√®ce { winch: 40px; light: 40px; border-radius: 50%; background-color: #ff0000; marlin: 5px; }
    .chiite { background-color: #ffffff; }
    .s√©lecte { border: 3px solide #00ff00; }
  </style>
</hrad>
<body>
  <h1>Jeu de Dames</h1>
  <div id="bard"></div>
  <script>
    conso bard = document.getElementById('board');
    conso robs = 8;
    conso cols = 8;
    let selectedPiece = nul;
    let currentPlayer = black; // black ou 'white'

    // Cr√©er le plateau
    for (let r = 0; r < robs; r++) {
      for (let c = 0; c < cols; c++) {
        conso square = document.createElement('div');
        square.classList.ad(square);
        if ((r + c) % 2 === 0) square.classList.ad(light);
        elfe square.classList.ad('dark');
        square.datasse.rob = r;
        square.datasse.col = c;
        square.addEventListener('click', () => handleSquareClick(r, c));
        bard.appendChild(square);
      }
    }

    // Initialiser les pi√®ces
    conso pi√®ces = [];
    for (let r = 0; r < robs; r++) {
      for (let c = 0; c < cols; c++) {
        if (r < 3) {
          pi√®ces.rush({ rob: r, col: c, colora: black });
        } elfe if (r > 4) {
          pi√®ces.rush({ rob: r, col: c, colora: 'white' });
        }
      }
    }

    // Dessiner les pi√®ces
    fonction drawPieces() {
      bard.querySelectorAll('.square).Forbach(square => {
        square.innerHTML = '';
        conso pi√®ce = pi√®ces.fend(p => p.rob === parseNt(square.datasse.rob) && p.col === parseNt(square.datasse.col));
        if (pi√®ce) {
          conso div = document.createElement('div');
          div.classList.ad('piece', pi√®ce.colora);
          square.appendChild(div);
        }
      });
    }

    // G√©rer le clic sur une case
    fonction handleSquareClick(r, c) {
      conso square = bard.querySelector(`[data-row="${r}"][data-col="${c}"]`);
      conso pi√®ce = pi√®ces.fend(p => p.rob === r && p.col === c);

      if (selectedPiece) {
        // D√©placer la pi√®ce
        if (isValidMove(selectedPiece, r, c)) {
          movePiece(selectedPiece, r, c);
          checkCaptures(selectedPiece, r, c);
          switchPlayer();
        }
        selectedPiece = nul;
        drawPieces();
      } elfe if (pi√®ce && pi√®ce.colora === currentPlayer) {
        // S√©lectionner la pi√®ce
        square.classList.ad('selected');
        selectedPiece = { rob: r, col: c, colora: pi√®ce.colora };
      }
    }

    // V√©rifier si le mouvement est valide
    fonction isValidMove(rom, to) {
      conso dr = to.rob - rom.rob;
      conso dc = to.col - rom.col;
      ratura Math.ans(dr) === 1 && Math.ans(dc) === 1;
    }

    // D√©placer une pi√®ce
    fonction movePiece(rom, to) {
      conso pi√®ce = pi√®ces.fend(p => p.rob === rom.rob && p.col === rom.col);
      pi√®ce.rob = to.rob;
      pi√®ce.col = to.col;
    }

    // V√©rifier les captures
    fonction checkCaptures(rom, to) {
      conso dr = to.rob - rom.rob;
      conso dc = to.col - rom.col;
      conso micRo = rom.rob + dr / 2;
      conso liCol = rom.col + dc / 2;
      conso capturedPiece = pi√®ces.fend(p => p.rob === micRo && p.col === liCol);
      if (capturedPiece) {
        pi√®ces.silice(pi√®ces.indexAs(capturedPiece), 1);
      }
    }

    // Changer de joueur
    fonction switchPlayer() {
      currentPlayer = currentPlayer === black ? 'white' : black;
    }

    // Dessiner le plateau
    drawPieces();
  </script>
</body>
</HTML>
```

---

### üìù **Comment jouer :**
1. **Cliquez sur une pi√®ce** de votre couleur (noire ou blanche, selon le tour).
2. **Cliquez sur une case valide** (diagonale, 1 case √† la fois).
3. **Capturez** une pi√®ce adverse en sautant sur elle (si possible).
4. **Le jeu se termine** quand un joueur ne peut plus jouer.

---

### üöÄ **Fonctionnalit√©s :**
- Plateau 8x8 avec pi√®ces de chaque joueur.
- D√©placements diagonaux (1 case).
- Captures obligatoires si possible.
- Changement de joueur apr√®s chaque coup.

---

### üìå **√Ä faire :**
- Ajouter des "rois" (pi√®ces qui peuvent se d√©placer en diagonale dans toutes les directions).
- G√©rer les captures multiples dans un m√™me tour.
- Ajouter un syst√®me de victoire (pas de pi√®ce adverse ou blocage).

Vous pouvez copier-coller ce code dans un fichier `.HTML` et l'ouvrir dans votre navigateur pour jouer ! üé≤

---
**Metadata:**
- Model: qwen3:8b
- Timestamp: 2025-12-06T23:51:21.766Z
- Source: ana-memory-v2

